{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#oastools","title":"oastools","text":"<p>A complete, self-contained OpenAPI toolkit for Go \u2014 parse, validate, fix, convert, diff, join, walk, generate, and build OpenAPI specs (2.0\u20133.2) with an MCP server for AI-assisted development.</p> <p> </p>"},{"location":"#get-started","title":"Get Started","text":""},{"location":"#go-library","title":"\ud83d\udce6 Go Library","text":"<p>Import oastools packages into your Go application for parsing, validation, conversion, code generation, and more. All packages use a consistent functional options API.</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nvResult, _ := validator.ValidateWithOptions(validator.WithParsed(*result))\n</code></pre> <p>\u2192 Developer Guide \u2014 Complete library usage with examples for all 12 packages</p>"},{"location":"#cli-cicd","title":"\ud83d\udda5\ufe0f CLI / CI/CD","text":"<p>Run oastools from the terminal, in shell scripts, or as a CI/CD pipeline step. Supports file and URL inputs, stdin/stdout piping, and JSON output for machine consumption.</p> <pre><code>oastools validate openapi.yaml\noastools diff --breaking --format json v1.yaml v2.yaml | jq\n</code></pre> <p>\u2192 CLI Reference \u2014 All commands, flags, and output formats</p>"},{"location":"#mcp-server","title":"\ud83e\udd16 MCP Server","text":"<p>Connect oastools to Claude Code, Cursor, VS Code, or any MCP-compatible AI agent. All 17 tools are available over stdio via the Model Context Protocol.</p> <pre><code>oastools mcp  # Start the MCP server\n</code></pre> <p>\u2192 MCP Server Guide \u2014 Setup and tool reference \u2192 Claude Code Plugin \u2014 One-command setup for Claude Code</p>"},{"location":"#try-it-online","title":"\ud83c\udf10 Try it Online","text":"<p>No installation required \u2014 use oastools directly in your browser:</p> <p>oastools.robnrob.com \u2014 Validate, convert, diff, fix, join, and apply overlays.</p>"},{"location":"#whats-included","title":"What's Included","text":"Package Description Try parser Parse &amp; analyze OAS files from files, URLs, or readers validator Validate specs with structural &amp; semantic checks \ud83c\udf10 fixer Auto-fix common validation errors \ud83c\udf10 httpvalidator Validate HTTP requests/responses against OAS at runtime converter Convert between OAS 2.0 and 3.x \ud83c\udf10 joiner Merge multiple OAS documents with schema deduplication \ud83c\udf10 overlay Apply OpenAPI Overlay v1.0.0 with JSONPath targeting \ud83c\udf10 differ Detect breaking changes between versions \ud83c\udf10 generator Generate Go client/server code with security support builder Programmatically construct OAS documents with deduplication walker Traverse OAS documents with typed handlers and flow control oaserrors Structured error types for programmatic handling <p>All packages include comprehensive documentation with runnable examples. See individual package pages on pkg.go.dev for API details.</p>"},{"location":"#why-oastools","title":"Why oastools?","text":"<p>\u2192 Full details</p> Minimal Dependencies <p>Only <code>go.yaml.in/yaml</code>, <code>golang.org/x/tools</code>, <code>golang.org/x/text</code>, and the MCP Go SDK at runtime. No sprawling dependency trees.</p> Battle-Tested <p>8,000+ tests validated against 10 production APIs \u2014 Stripe, GitHub, Discord, Microsoft Graph (34MB), and more. Spans OAS 2.0 through 3.1, JSON and YAML, 20KB to 34MB.</p> Performance <p>Pre-parsed workflows are 11\u2013150x faster. JSON marshaling optimized for 25-32% better performance. 340+ benchmarks track regressions. See the whitepaper performance section for detailed analysis.</p> Enterprise-Ready <p>Structured errors with <code>errors.Is()</code>/<code>errors.As()</code>, configurable resource limits, pluggable HTTP clients, deterministic output ordering, and generated <code>DeepCopy()</code> methods for safe document mutation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#cli","title":"CLI","text":"<pre><code>brew install erraggy/oastools/oastools                   # Homebrew (macOS/Linux)\ngo install github.com/erraggy/oastools/cmd/oastools@latest  # Go install\n</code></pre> <p>Pre-built binaries for macOS, Linux, and Windows on the Releases page.</p>"},{"location":"#library","title":"Library","text":"<pre><code>go get github.com/erraggy/oastools@latest\n</code></pre> <p>Requires Go 1.24+.</p>"},{"location":"#examples","title":"Examples","text":"<p>Explore complete, runnable examples demonstrating the full oastools ecosystem:</p> Category Examples Time Getting Started Quickstart, Validation Pipeline 2-5 min Workflows Validate &amp; Fix, Version Conversion, Multi-API Merge, Breaking Changes, Overlays, HTTP Validation 3-5 min each Programmatic Builder with ServerBuilder 5 min Code Generation Petstore (stdlib &amp; chi router) 10 min Walker API Statistics, Security Audit, Public API Filter 3-5 min each <p>See all examples for the full list.</p>"},{"location":"#supported-openapi-versions","title":"Supported OpenAPI Versions","text":"Version Specification 2.0 (Swagger) spec 3.0.0 \u2013 3.0.4 spec 3.1.0 \u2013 3.1.2 spec 3.2.0 spec <p>Automatic format detection and preservation (JSON/YAML), external reference resolution, JSON Pointer array index support, and full JSON Schema Draft 2020-12 compliance for OAS 3.1+.</p>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Fork and create a feature branch</li> <li>Run <code>make check</code> before committing</li> <li>Follow conventional commits (e.g., <code>feat(parser): add feature</code>)</li> <li>Submit a PR</li> </ol> <p>See WORKFLOW.md for guidelines.</p>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>All code generated by Claude Code using claude-4-5-sonnet/opus with minor edits and full control by @erraggy</p>"},{"location":"CONTRIBUTORS/","title":"Contributing to oastools","text":"<p>Thank you for your interest in contributing to oastools! This document provides everything you need to know to contribute effectively.</p>"},{"location":"CONTRIBUTORS/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Development Workflow</li> <li>Project Architecture</li> <li>Code Standards</li> <li>Testing Requirements</li> <li>Submitting Changes</li> <li>CI/CD and Automation</li> <li>Getting Help</li> </ul>"},{"location":"CONTRIBUTORS/#quick-start","title":"Quick Start","text":""},{"location":"CONTRIBUTORS/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+ - Required for development</li> <li>golangci-lint - For linting (optional but recommended)</li> <li>gotestsum - For better test output formatting (optional)</li> </ul>"},{"location":"CONTRIBUTORS/#clone-and-build","title":"Clone and Build","text":"<pre><code># Clone the repository\ngit clone https://github.com/erraggy/oastools.git\ncd oastools\n\n# Install dependencies\nmake deps\n\n# Build the binary\nmake build\n\n# Run tests\nmake test\n\n# Run all quality checks\nmake check\n</code></pre>"},{"location":"CONTRIBUTORS/#development-workflow","title":"Development Workflow","text":""},{"location":"CONTRIBUTORS/#the-golden-rule-always-run-make-check","title":"The Golden Rule: Always Run <code>make check</code>","text":"<p>After making changes, always run:</p> <pre><code>make check\n</code></pre> <p>This command runs:</p> <ol> <li><code>go mod tidy</code> - Clean up dependencies</li> <li><code>go fmt</code> - Format code</li> <li><code>golangci-lint run</code> - Lint code</li> <li><code>go test</code> with race detection - Run tests</li> <li><code>git status</code> - Show what changed</li> </ol>"},{"location":"CONTRIBUTORS/#common-development-commands","title":"Common Development Commands","text":"<pre><code># Build the binary (outputs to bin/oastools)\nmake build\n\n# Install to $GOPATH/bin\nmake install\n\n# Run tests with coverage\nmake test\n\n# Generate HTML coverage report\nmake test-coverage\n\n# Format code\nmake fmt\n\n# Run linter\nmake lint\n\n# Clean build artifacts\nmake clean\n</code></pre>"},{"location":"CONTRIBUTORS/#development-loop","title":"Development Loop","text":"<ol> <li>Make your changes</li> <li>Run <code>make check</code> to validate</li> <li>Fix any issues reported</li> <li>Commit your changes</li> <li>Create a pull request</li> </ol>"},{"location":"CONTRIBUTORS/#project-architecture","title":"Project Architecture","text":""},{"location":"CONTRIBUTORS/#what-is-oastools","title":"What is oastools?","text":"<p>oastools is a Go-based CLI tool and library for working with OpenAPI Specification (OAS) files. It provides:</p> <ul> <li>Validation - Ensure OAS files conform to specifications</li> <li>Parsing - Load and analyze OAS documents</li> <li>Joining - Combine multiple OAS files</li> <li>Converting - Transform between OAS versions (2.0 \u2194 3.x)</li> <li>Diffing - Compare specs and detect breaking changes</li> </ul>"},{"location":"CONTRIBUTORS/#directory-structure","title":"Directory Structure","text":"<pre><code>oastools/\n\u251c\u2500\u2500 cmd/oastools/       # CLI entry point\n\u2502   \u2514\u2500\u2500 main.go         # Command dispatcher\n\u251c\u2500\u2500 parser/             # Parse OAS files (public API)\n\u251c\u2500\u2500 validator/          # Validate OAS files (public API)\n\u251c\u2500\u2500 joiner/             # Join multiple OAS files (public API)\n\u251c\u2500\u2500 converter/          # Convert between OAS versions (public API)\n\u251c\u2500\u2500 differ/             # Compare OAS files (public API)\n\u251c\u2500\u2500 internal/           # Internal utilities (not public API)\n\u2502   \u251c\u2500\u2500 httputil/       # HTTP constants and validation\n\u2502   \u251c\u2500\u2500 severity/       # Issue severity levels\n\u2502   \u251c\u2500\u2500 issues/         # Unified issue reporting\n\u2502   \u2514\u2500\u2500 testutil/       # Test helpers\n\u2514\u2500\u2500 testdata/           # Test fixtures\n</code></pre>"},{"location":"CONTRIBUTORS/#public-vs-internal-packages","title":"Public vs Internal Packages","text":"<p>Public packages (can be imported by external projects):</p> <ul> <li><code>parser</code> - Parse OpenAPI specifications</li> <li><code>validator</code> - Validate OpenAPI specifications</li> <li><code>joiner</code> - Join multiple specifications</li> <li><code>converter</code> - Convert between versions</li> <li><code>differ</code> - Compare specifications</li> </ul> <p>Internal packages (project-only):</p> <ul> <li><code>internal/*</code> - Shared utilities not exposed to external users</li> </ul>"},{"location":"CONTRIBUTORS/#design-principles","title":"Design Principles","text":"<ol> <li>Public API First - Core functionality is exposed as importable Go packages</li> <li>Separation of Concerns - Each package has one responsibility</li> <li>Format Preservation - Input format (JSON/YAML) is automatically preserved</li> <li>Comprehensive Documentation - Every public package has <code>doc.go</code> and <code>example_test.go</code></li> <li>Testability - High test coverage required for all exported functionality</li> </ol>"},{"location":"CONTRIBUTORS/#code-standards","title":"Code Standards","text":""},{"location":"CONTRIBUTORS/#go-style-guidelines","title":"Go Style Guidelines","text":"<ul> <li>Follow standard Go conventions</li> <li>Use <code>gofmt</code> for formatting (run via <code>make fmt</code>)</li> <li>Pass <code>golangci-lint</code> checks (run via <code>make lint</code>)</li> <li>Use meaningful variable and function names</li> <li>Write self-documenting code; add comments only where logic isn't obvious</li> </ul>"},{"location":"CONTRIBUTORS/#documentation-requirements","title":"Documentation Requirements","text":"<p>All exported functionality must have:</p> <ol> <li>Godoc comments - Describe what it does</li> <li>Package-level docs - Update <code>doc.go</code> if adding new public APIs</li> <li>Runnable examples - Add to <code>example_test.go</code> for new features</li> </ol> <p>Example:</p> <pre><code>// Parse parses an OpenAPI specification file from the given path.\n// It automatically detects the file format (JSON or YAML) and validates\n// the document structure if validateStructure is true.\nfunc Parse(specPath string, resolveRefs bool, validateStructure bool) (*ParseResult, error) {\n    // Implementation\n}\n</code></pre>"},{"location":"CONTRIBUTORS/#constant-usage","title":"Constant Usage","text":"<p>Always use package-level constants instead of string literals:</p> <pre><code>// \u274c Bad - hardcoded strings\nif method == \"get\" { ... }\n\n// \u2705 Good - use constants\nif method == httputil.MethodGet { ... }\n</code></pre> <p>This ensures:</p> <ul> <li>Single source of truth</li> <li>Type safety</li> <li>Easy refactoring</li> <li>Clear intent</li> </ul>"},{"location":"CONTRIBUTORS/#format-preservation","title":"Format Preservation","text":"<p>IMPORTANT: The parser, converter, and joiner automatically preserve input file format.</p> <ul> <li>Input JSON \u2192 Output JSON</li> <li>Input YAML \u2192 Output YAML</li> </ul> <p>This is handled automatically via the <code>SourceFormat</code> field in <code>ParseResult</code>. When writing new features:</p> <ol> <li>Don't manually choose output format</li> <li>Do use <code>result.SourceFormat</code> to determine marshaling</li> <li>Test both JSON and YAML format preservation</li> </ol>"},{"location":"CONTRIBUTORS/#error-handling","title":"Error Handling","text":"<ul> <li>Return errors; don't panic (except for programmer errors)</li> <li>Use <code>fmt.Errorf</code> with <code>%w</code> for error wrapping</li> <li>Provide context in error messages</li> </ul> <pre><code>if err != nil {\n    return nil, fmt.Errorf(\"failed to parse spec at %s: %w\", specPath, err)\n}\n</code></pre>"},{"location":"CONTRIBUTORS/#testing-requirements","title":"Testing Requirements","text":""},{"location":"CONTRIBUTORS/#coverage-expectations","title":"Coverage Expectations","text":"<p>All exported functionality MUST have comprehensive test coverage.</p> <p>This includes:</p> <ul> <li>\u2705 Exported functions (e.g., <code>parser.Parse()</code>)</li> <li>\u2705 Exported methods (e.g., <code>Parser.Parse()</code>)</li> <li>\u2705 Exported types and their fields</li> <li>\u2705 Exported constants and variables</li> </ul>"},{"location":"CONTRIBUTORS/#test-types-required","title":"Test Types Required","text":"<ol> <li>Positive tests - Valid inputs produce expected outputs</li> <li>Negative tests - Invalid inputs produce appropriate errors</li> <li>Edge cases - Boundary conditions, empty inputs, nil values</li> <li>Integration tests - Multiple components working together</li> </ol>"},{"location":"CONTRIBUTORS/#test-naming-convention","title":"Test Naming Convention","text":"<pre><code>// Package-level convenience functions\nfunc TestParseConvenience(t *testing.T) { ... }\n\n// Struct methods\nfunc TestParserParse(t *testing.T) { ... }\n\n// Specific features\nfunc TestJSONFormatPreservation(t *testing.T) { ... }\n</code></pre>"},{"location":"CONTRIBUTORS/#benchmark-tests","title":"Benchmark Tests","text":"<p>Use the Go 1.24+ <code>for b.Loop()</code> pattern:</p> <pre><code>func BenchmarkParse(b *testing.B) {\n    // Setup\n    specPath := \"testdata/petstore.yaml\"\n\n    // Benchmark loop\n    for b.Loop() {\n        _, err := Parse(specPath, false, true)\n        if err != nil {\n            b.Fatal(err)\n        }\n    }\n}\n</code></pre> <p>Don't use:</p> <ul> <li>\u274c <code>for i := 0; i &lt; b.N; i++</code> (old pattern)</li> <li>\u274c <code>b.ReportAllocs()</code> (handled automatically by <code>b.Loop()</code>)</li> </ul>"},{"location":"CONTRIBUTORS/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nmake test\n\n# Run tests with coverage\nmake test-coverage\n\n# Run specific package tests\ngo test ./parser/...\n\n# Run specific test\ngo test ./parser -run TestParse\n\n# Run benchmarks\ngo test -bench=. ./parser\n</code></pre>"},{"location":"CONTRIBUTORS/#submitting-changes","title":"Submitting Changes","text":""},{"location":"CONTRIBUTORS/#before-you-commit","title":"Before You Commit","text":"<ol> <li>\u2705 Run <code>make check</code> and ensure it passes</li> <li>\u2705 Add tests for new functionality</li> <li>\u2705 Update documentation (godoc, doc.go, example_test.go)</li> <li>\u2705 Verify test coverage is sufficient</li> <li>\u2705 Update benchmarks with <code>make bench-save</code> for performance-impacting changes</li> </ol>"},{"location":"CONTRIBUTORS/#documentation-checks","title":"Documentation Checks","text":"<p>CI automatically verifies that documentation stays in sync with code through automated checks:</p> <ul> <li>CLI flag tables (<code>TestCLIFlagsDocumented</code>) - CLI flags must match <code>docs/cli-reference.md</code></li> <li>Option tables (<code>TestDeepDiveOptionTables</code>) - <code>With*</code> functions must appear in respective <code>deep_dive.md</code></li> <li>Link checking (lychee) - Broken links caught in CI and via <code>make docs-check</code></li> </ul> <p>If you add a CLI flag or <code>With*</code> option, the tests will tell you which doc to update.</p>"},{"location":"CONTRIBUTORS/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commit format:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code> - New feature</li> <li><code>fix</code> - Bug fix</li> <li><code>docs</code> - Documentation only</li> <li><code>test</code> - Adding/updating tests</li> <li><code>refactor</code> - Code restructuring (no behavior change)</li> <li><code>perf</code> - Performance improvements</li> <li><code>chore</code> - Maintenance tasks</li> </ul> <p>Examples:</p> <pre><code>feat(parser): add support for OAS 3.2.0\n\nImplemented parsing logic for the new OAS 3.2.0 specification,\nincluding support for the updated JSON Schema Draft 2020-12\nalignment and new spec features.\n\n- Added version detection for 3.2.0\n- Updated schema validation\n- Added test fixtures for 3.2.0\n</code></pre> <pre><code>fix(converter): handle nullable types in OAS 3.1 conversion\n\nFixed conversion of OAS 3.1 nullable types that use type arrays\ninstead of the deprecated nullable field.\n\nFixes #123\n</code></pre> <pre><code>chore: run go mod tidy\n\n[skip-review] - automated dependency cleanup\n</code></pre>"},{"location":"CONTRIBUTORS/#skipping-automated-code-review","title":"Skipping Automated Code Review","text":"<p>You can skip the Claude Code Review workflow for trivial commits by adding <code>[skip-review]</code> to your commit message:</p> <pre><code># Example: Skip review for automated formatting\ngit commit -m \"chore: run go fmt\n\n[skip-review] - automated code formatting, no logic changes\"\n\n# Example: Skip review for dependency updates\ngit commit -m \"chore: update dependencies\n\n[skip-review] - go mod tidy only\"\n</code></pre> <p>When to use <code>[skip-review]</code>:</p> <ul> <li>Automated formatting (<code>go fmt</code>, <code>gofmt</code>)</li> <li>Dependency updates (<code>go mod tidy</code>)</li> <li>Minor documentation typos</li> <li>Whitespace or comment-only changes</li> </ul> <p>When NOT to use <code>[skip-review]</code>:</p> <ul> <li>Any logic changes</li> <li>New features</li> <li>Bug fixes</li> <li>Refactoring</li> <li>Test additions/changes</li> </ul> <p>The review will be skipped if any commit in your PR contains <code>[skip-review]</code>.</p>"},{"location":"CONTRIBUTORS/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a feature branch</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make your changes and commit</li> </ol> <pre><code># Make changes\nmake check\ngit add .\ngit commit -m \"feat(scope): description\"\n</code></pre> <ol> <li>Push to your fork</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a Pull Request</li> <li>Use a clear, descriptive title</li> <li>Reference any related issues</li> <li>Describe what changed and why</li> <li> <p>Include testing instructions if applicable</p> </li> <li> <p>Address Review Feedback</p> </li> <li>Respond to comments</li> <li>Make requested changes</li> <li>Push updates to your branch</li> <li>Request re-review when ready</li> </ol>"},{"location":"CONTRIBUTORS/#pr-review-checklist","title":"PR Review Checklist","text":"<p>Before requesting review, ensure:</p> <ul> <li>[ ] <code>make check</code> passes</li> <li>[ ] All tests pass with <code>make test</code></li> <li>[ ] New functionality has tests</li> <li>[ ] Public APIs have godoc comments</li> <li>[ ] Examples added for new features</li> <li>[ ] Benchmarks updated with <code>make bench-save</code> (if changes affect performance)</li> <li>[ ] No unintended files committed (e.g., binaries, editor files)</li> <li>[ ] Commit messages follow conventional format</li> </ul>"},{"location":"CONTRIBUTORS/#cicd-and-automation","title":"CI/CD and Automation","text":""},{"location":"CONTRIBUTORS/#automated-workflows","title":"Automated Workflows","text":"<p>When you create a PR, several automated workflows run:</p> <ol> <li>Go Tests - Runs test suite across multiple Go versions</li> <li>golangci-lint - Lints code for issues</li> <li>Claude Code Review (optional) - AI-powered code review</li> <li>Skipped if <code>[skip-review]</code> in any commit message</li> <li>Provides feedback on code quality, bugs, performance, security</li> </ol>"},{"location":"CONTRIBUTORS/#workflow-status","title":"Workflow Status","text":"<p>Check workflow status:</p> <ul> <li>In your PR - See status checks at the bottom</li> <li>On the Actions tab - https://github.com/erraggy/oastools/actions</li> </ul>"},{"location":"CONTRIBUTORS/#common-ci-issues","title":"Common CI Issues","text":"<p>Tests fail on CI but pass locally:</p> <ul> <li>Ensure you're testing with race detection: <code>go test -race</code></li> <li>Check for timing-dependent tests</li> <li>Verify all test files are committed</li> </ul> <p>Exit code 143 (SIGTERM):</p> <ul> <li>This means the test process was killed by the runner</li> <li>Common with <code>go test -race</code> on GitHub Actions</li> <li>Usually indicates tests hung or timed out</li> <li>Current mitigations in place:</li> <li>Test timeout: 10 minutes per package</li> <li>Job timeout: 15 minutes total</li> <li>Limited parallelism: <code>-parallel=4</code></li> <li><code>GOMAXPROCS=2</code> to prevent resource exhaustion</li> <li>If you see this error intermittently, it's likely a runner resource issue, not your code</li> <li>Related: actions/runner-images#6680, actions/runner-images#7146</li> </ul> <p>Linter fails:</p> <ul> <li>Run <code>make lint</code> locally</li> <li>Fix reported issues</li> <li>Push fixes</li> </ul> <p>Claude Code Review comments:</p> <ul> <li>Review the feedback (visible in PR comments)</li> <li>Address legitimate concerns</li> <li>Respond to questions</li> <li>Push updates if needed</li> </ul>"},{"location":"CONTRIBUTORS/#key-openapi-concepts","title":"Key OpenAPI Concepts","text":""},{"location":"CONTRIBUTORS/#supported-oas-versions","title":"Supported OAS Versions","text":"<p>oastools supports all major OpenAPI Specification versions:</p> <ul> <li>OAS 2.0 (Swagger) - Specification</li> <li>OAS 3.0.x (3.0.0 - 3.0.4) - Specification</li> <li>OAS 3.1.x (3.1.0 - 3.1.2) - Specification</li> <li>OAS 3.2.0 - Specification</li> </ul> <p>All versions use JSON Schema Draft 2020-12 for schema definitions.</p>"},{"location":"CONTRIBUTORS/#version-evolution","title":"Version Evolution","text":"<p>Understanding how OAS evolved helps when working with conversion and validation:</p> <p>OAS 2.0 \u2192 3.0 Changes:</p> <ul> <li><code>host</code>/<code>basePath</code>/<code>schemes</code> \u2192 unified <code>servers</code> array</li> <li><code>definitions</code>/<code>parameters</code>/<code>responses</code> \u2192 <code>components.*</code></li> <li><code>consumes</code> + body param \u2192 <code>requestBody.content</code></li> <li><code>produces</code> + schema \u2192 <code>responses.*.content</code></li> <li>Added: callbacks, links, cookie parameters</li> </ul> <p>OAS 3.0 \u2192 3.1 Changes:</p> <ul> <li>Full JSON Schema alignment</li> <li><code>type</code> can be array: <code>[\"string\", \"null\"]</code></li> <li>Deprecated <code>nullable</code> field</li> <li>Added <code>webhooks</code> for event-driven APIs</li> <li>Added <code>license.identifier</code></li> </ul>"},{"location":"CONTRIBUTORS/#critical-type-handling","title":"Critical Type Handling","text":"<p>Be careful with <code>interface{}</code> fields:</p> <p>Some OAS 3.1+ fields accept multiple types and are defined as <code>interface{}</code>:</p> <pre><code>// schema.Type can be string OR []string\nif typeStr, ok := schema.Type.(string); ok {\n    // Single type: \"string\"\n} else if typeArr, ok := schema.Type.([]string); ok {\n    // Multiple types: [\"string\", \"null\"]\n}\n</code></pre> <p>Always use type assertions - never assume the type!</p>"},{"location":"CONTRIBUTORS/#version-specific-features","title":"Version-Specific Features","text":"<p>OAS 2.0 Only:</p> <ul> <li><code>allowEmptyValue</code> (removed in 3.0+)</li> <li><code>collectionFormat</code> (replaced by <code>style</code>/<code>explode</code>)</li> </ul> <p>OAS 3.0+ Only:</p> <ul> <li><code>requestBody</code> (replaces body parameters)</li> <li><code>callbacks</code> (async operations)</li> <li><code>links</code> (operation relationships)</li> <li>Cookie parameters (<code>in: cookie</code>)</li> <li>TRACE HTTP method</li> </ul> <p>OAS 3.1+ Only:</p> <ul> <li><code>webhooks</code> (event subscriptions)</li> <li>Type arrays for nullable</li> <li><code>license.identifier</code></li> </ul> <p>When working with conversions, these differences matter!</p>"},{"location":"CONTRIBUTORS/#getting-help","title":"Getting Help","text":""},{"location":"CONTRIBUTORS/#resources","title":"Resources","text":"<ul> <li>Documentation: See CLAUDE.md for technical details</li> <li>Release Process: See RELEASES.md for release workflow</li> <li>Issues: GitHub Issues</li> <li>Pull Requests: GitHub PRs</li> </ul>"},{"location":"CONTRIBUTORS/#openapi-specifications","title":"OpenAPI Specifications","text":"<ul> <li>OAS 2.0 Specification</li> <li>OAS 3.0 Specification</li> <li>OAS 3.1 Specification</li> <li>JSON Schema Draft 2020-12</li> </ul>"},{"location":"CONTRIBUTORS/#asking-questions","title":"Asking Questions","text":"<ul> <li>Open a GitHub Issue for bugs or feature requests</li> <li>Start a GitHub Discussion for questions</li> <li>Check existing issues/discussions first - your question may already be answered</li> </ul>"},{"location":"CONTRIBUTORS/#before-filing-an-issue","title":"Before Filing an Issue","text":"<ol> <li>Search existing issues</li> <li>Provide a minimal reproduction case</li> <li>Include relevant version information:</li> </ol> <pre><code>oastools --version\ngo version\n</code></pre> <ol> <li>Include error messages and stack traces</li> <li>Describe expected vs actual behavior</li> </ol>"},{"location":"CONTRIBUTORS/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"CONTRIBUTORS/#type-assertions","title":"Type Assertions","text":"<p>Problem: Assuming <code>schema.Type</code> is always a string</p> <pre><code>// \u274c Wrong - will panic if Type is []string\ntypeStr := schema.Type.(string)\n\n// \u2705 Correct - safe type assertion\nif typeStr, ok := schema.Type.(string); ok {\n    // Handle string case\n} else if typeArr, ok := schema.Type.([]string); ok {\n    // Handle array case\n}\n</code></pre>"},{"location":"CONTRIBUTORS/#pointer-slices","title":"Pointer Slices","text":"<p>Problem: Creating value slices instead of pointer slices</p> <pre><code>// \u274c Wrong - OAS3Document.Servers expects []*parser.Server\nservers := []parser.Server{{URL: \"http://api.example.com\"}}\n\n// \u2705 Correct - use pointer slice\nservers := []*parser.Server{{URL: \"http://api.example.com\"}}\n</code></pre>"},{"location":"CONTRIBUTORS/#document-mutation","title":"Document Mutation","text":"<p>Problem: Modifying source documents unintentionally</p> <pre><code>// \u274c Wrong - may mutate original\nmodified := sourceDoc\nmodified.Info.Title = \"New Title\"  // Changes sourceDoc too!\n\n// \u2705 Correct - deep copy first\nmodified := sourceDoc.DeepCopy()\nmodified.Info.Title = \"New Title\"  // Safe\n</code></pre>"},{"location":"CONTRIBUTORS/#hardcoded-strings","title":"Hardcoded Strings","text":"<p>Problem: Using string literals instead of constants</p> <pre><code>// \u274c Wrong\nif method == \"get\" { ... }\n\n// \u2705 Correct\nif method == httputil.MethodGet { ... }\n</code></pre>"},{"location":"CONTRIBUTORS/#missing-tests","title":"Missing Tests","text":"<p>Problem: Not testing exported functionality</p> <pre><code>// \u274c Wrong - exported but no tests\nfunc NewParser() *Parser { ... }\n\n// \u2705 Correct - exported with tests\nfunc TestNewParser(t *testing.T) { ... }\n</code></pre>"},{"location":"CONTRIBUTORS/#license","title":"License","text":"<p>By contributing to oastools, you agree that your contributions will be licensed under the MIT License.</p> <p>Happy Contributing! \ud83c\udf89</p> <p>We appreciate your time and effort in helping make oastools better. If you have questions or need clarification on anything in this guide, please don't hesitate to ask.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright 2025 Robbie Coleman</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"benchmarks/","title":"Performance Benchmarks","text":"<p>This document provides detailed performance analysis and benchmark results for the oastools library.</p>"},{"location":"benchmarks/#overview","title":"Overview","text":"<p>As of v1.18.0, oastools includes comprehensive performance benchmarking infrastructure covering all major operations across the parser, validator, fixer, converter, joiner, differ, generator, builder, and overlay packages. The library has undergone targeted optimizations to achieve significant performance improvements while maintaining correctness and code quality.</p> <p>CI Platform (for cross-version comparisons): linux/amd64, AMD EPYC 7763, Go 1.24 Local Platform (historical reference): darwin/arm64, Apple M4, Go 1.24</p> <p>Note: CI-generated benchmarks (<code>benchmarks/benchmark-v*.txt</code>) provide consistent, reproducible results for cross-version comparisons. Local benchmarks (<code>benchmarks/local/</code>) are preserved for historical reference but have \u00b150% I/O variance.</p>"},{"location":"benchmarks/#benchmark-reliability-notice","title":"\u26a0\ufe0f Benchmark Reliability Notice","text":""},{"location":"benchmarks/#io-variance-can-mask-reality","title":"I/O Variance Can Mask Reality","text":"<p>IMPORTANT: File-based benchmarks (e.g., <code>BenchmarkParse</code>, <code>BenchmarkJoin</code>) include file I/O in every iteration. This makes them unreliable for detecting code-level performance regressions because:</p> <ul> <li>Filesystem caching state varies between benchmark runs</li> <li>System load affects disk access times</li> <li>I/O variance can be +/- 50% or more</li> </ul> <p>Example: An investigation in v1.28.1 found that comparing saved benchmarks showed apparent 51-82% regressions. However, running both versions live on the same machine showed 0% actual code performance difference.</p>"},{"location":"benchmarks/#which-benchmarks-to-trust","title":"Which Benchmarks to Trust","text":"Benchmark Type Pattern Use For Reliable? I/O-Isolated <code>*Core</code>, <code>*Bytes</code> Regression detection \u2705 Yes Pre-Parsed <code>*Parsed</code> Regression detection \u2705 Yes End-to-End <code>BenchmarkParse</code>, <code>BenchmarkJoin</code>, etc. User documentation \u26a0\ufe0f Informational only"},{"location":"benchmarks/#recommended-benchmarks-for-regression-detection","title":"Recommended Benchmarks for Regression Detection","text":"<pre><code># Parser: Use BenchmarkParseCore (not BenchmarkParse)\ngo test -bench=BenchmarkParseCore -benchmem ./parser\n\n# Joiner: Use BenchmarkJoinParsed (not BenchmarkJoin)\ngo test -bench=BenchmarkJoinParsed -benchmem ./joiner\n\n# All packages: Filter to reliable benchmarks only\ngo test -bench='ParseCore|JoinParsed|ValidateParsed|FixParsed|ConvertParsed|Diff/Parsed' -benchmem ./...\n</code></pre> <p>See CLAUDE.md and BENCHMARK_UPDATE_PROCESS.md for detailed guidance on investigating suspected regressions.</p>"},{"location":"benchmarks/#key-performance-achievements","title":"Key Performance Achievements","text":""},{"location":"benchmarks/#phase-2-optimization-json-marshaling-v170","title":"Phase 2 Optimization: JSON Marshaling (v1.7.0)","text":"<p>The v1.7.0 release includes a major optimization to JSON marshaling that eliminates the double-marshal pattern across all 29 custom JSON marshalers in the parser package.</p> <p>Performance Improvements:</p> <ul> <li>25-32% faster JSON marshaling for types with specification extensions (Extra fields)</li> <li>29-37% fewer memory allocations</li> <li>Zero overhead for types without Extra fields (fast path optimization)</li> </ul> <p>Implementation Strategy:</p> <ul> <li>Eliminated marshal\u2192unmarshal\u2192marshal pattern (4 operations \u2192 2 operations)</li> <li>Direct map building approach for types with Extra fields</li> <li>Replaced knownFields map lookups with efficient prefix checking (<code>x-</code>)</li> <li>Early return optimization when no Extra fields present</li> </ul> <p>Benchmark Results:</p> Type Before (baseline) After (optimized) Time Improvement Alloc Improvement Info 2,323 ns/op 1,707 ns/op 26% faster 32% fewer Contact 2,336 ns/op 1,599 ns/op 32% faster 37% fewer Server 2,837 ns/op 2,160 ns/op 25% faster 29% fewer"},{"location":"benchmarks/#benchmark-suite","title":"Benchmark Suite","text":"<p>The benchmark suite includes 250+ benchmark runs across ten packages:</p>"},{"location":"benchmarks/#parser-package-44-benchmarks","title":"Parser Package (44 benchmarks)","text":"<p>Marshaling Operations:</p> <ul> <li>Info marshaling: no extra fields, with extra fields, varying extra field counts (1, 5, 10, 20)</li> <li>Contact marshaling: no extra fields, with extra fields</li> <li>Server marshaling: no extra fields, with extra fields</li> <li>Document marshaling: small, medium, and large OAS 2.0 and OAS 3.x documents</li> </ul> <p>Parsing Operations:</p> <ul> <li>Small, medium, and large OAS 3.x documents</li> <li>Small and medium OAS 2.0 documents</li> <li>Parsing with and without validation</li> <li>ParseBytes vs Parse (file-based)</li> <li>ParseWithOptions convenience API (file path, reader, reference resolution)</li> <li>ParseReader I/O performance</li> <li>ParseResult.Copy() deep copy performance</li> <li>Reference resolution overhead measurement</li> <li>FormatBytes utility function</li> </ul> <p>DeepCopy Operations:</p> <ul> <li>OAS3Document.DeepCopy() for small, medium, and large documents</li> <li>OAS2Document.DeepCopy() for small and medium documents</li> <li>Type-aware copying that preserves nil vs empty distinction</li> </ul> <p>Unmarshaling Operations:</p> <ul> <li>Info unmarshaling: no extra fields, with extra fields</li> </ul> <p>Order-Preserving Marshaling:</p> <ul> <li>MarshalOrderedJSON: small, medium, and large OAS 3.x documents</li> <li>MarshalOrderedYAML: small, medium, and large OAS 3.x documents</li> <li>MarshalOrderedJSONIndent: indented JSON output</li> <li>Order-preserving vs standard marshaling comparison</li> <li>PreserveOrder parsing overhead measurement</li> </ul>"},{"location":"benchmarks/#validator-package-16-benchmarks","title":"Validator Package (16 benchmarks)","text":"<p>Validation Operations:</p> <ul> <li>Small, medium, and large OAS 3.x documents</li> <li>Small and medium OAS 2.0 documents</li> <li>With and without warnings</li> <li>ValidateParsed (pre-parsed documents) vs Validate (parse + validate)</li> <li>ValidateWithOptions convenience API (basic and pre-parsed variants)</li> <li>Strict mode validation (small, medium, and large documents)</li> <li>Large document validation without warnings</li> </ul>"},{"location":"benchmarks/#fixer-package-13-benchmarks","title":"Fixer Package (13 benchmarks)","text":"<p>Fixing Operations:</p> <ul> <li>Small, medium, and large OAS 3.x documents</li> <li>Small and medium OAS 2.0 documents</li> <li>With and without type inference</li> <li>FixParsed (pre-parsed documents) vs Fix (parse + fix)</li> <li>FixWithOptions convenience API (basic and pre-parsed variants)</li> </ul>"},{"location":"benchmarks/#converter-package-13-benchmarks","title":"Converter Package (13 benchmarks)","text":"<p>Conversion Operations:</p> <ul> <li>OAS 2.0 \u2192 OAS 3.x (small and medium documents)</li> <li>OAS 3.x \u2192 OAS 2.0 (small and medium documents)</li> <li>OAS 3.0 \u2192 OAS 3.1 version updates</li> <li>ConvertParsed (pre-parsed) vs Convert (parse + convert)</li> <li>ConvertWithOptions convenience API (basic and pre-parsed variants)</li> <li>Conversion with and without info messages</li> </ul>"},{"location":"benchmarks/#joiner-package-14-benchmarks","title":"Joiner Package (14 benchmarks)","text":"<p>Joining Operations:</p> <ul> <li>Join 2, 3, and 5 small documents</li> <li>JoinParsed (pre-parsed) vs Join (parse + join)</li> <li>JoinWithOptions convenience API (basic and pre-parsed variants)</li> <li>Different collision resolution strategies (AcceptLeft, AcceptRight)</li> <li>Array merge strategies</li> <li>Tag deduplication</li> <li>WriteResult I/O performance</li> <li>Configuration utilities (DefaultConfig, IsValidStrategy, ValidStrategies)</li> </ul>"},{"location":"benchmarks/#differ-package-10-benchmarks","title":"Differ Package (10 benchmarks)","text":"<p>Diffing Operations:</p> <ul> <li>Diff (parse + diff) vs DiffParsed (pre-parsed)</li> <li>DiffWithOptions convenience API</li> <li>Simple mode vs Breaking mode</li> <li>Configuration options (IncludeInfo)</li> <li>Edge cases (identical specifications)</li> <li>Parse-once pattern efficiency</li> <li>Change.String() formatting performance</li> </ul>"},{"location":"benchmarks/#generator-package-4-benchmarks","title":"Generator Package (4 benchmarks)","text":"<p>Code Generation Operations:</p> <ul> <li>Types-only generation</li> <li>Client code generation</li> <li>Server code generation</li> <li>Full generation (types + client + server)</li> </ul>"},{"location":"benchmarks/#overlay-package-18-benchmarks","title":"Overlay Package (18 benchmarks)","text":"<p>Overlay Application Operations:</p> <ul> <li>Apply overlays to small, medium, and large documents</li> <li>Apply with in-memory overlays vs file-based</li> <li>ApplyParsed performance (pre-parsed documents)</li> <li>ApplyWithOptions functional API</li> <li>DryRun preview functionality</li> </ul> <p>JSONPath Operations:</p> <ul> <li>Parse expressions of varying complexity</li> <li>Get operations with wildcards, filters, recursive descent</li> <li>Modify operations for document transformation</li> <li>Compound filter evaluation (&amp;&amp;, ||)</li> </ul>"},{"location":"benchmarks/#builder-package-17-benchmarks","title":"Builder Package (17 benchmarks)","text":"<p>Builder Construction Operations:</p> <ul> <li>Builder instantiation (New)</li> <li>Info configuration (SetTitle, SetVersion, SetDescription)</li> <li>Schema generation from reflection (primitives, structs, nested structs, slices, maps)</li> <li>Operation building (simple operations, with parameters, with request bodies)</li> <li>Full document building (Build)</li> <li>Serialization (MarshalYAML, MarshalJSON)</li> <li>OAS tag parsing and application</li> </ul>"},{"location":"benchmarks/#http-validator-package-9-benchmarks","title":"HTTP Validator Package (9 benchmarks)","text":"<p>Request/Response Validation:</p> <ul> <li>Request validation (path, query, header, body)</li> <li>Response validation (status code, headers, body)</li> <li>Path matching performance (single path, multiple paths)</li> <li>Schema validation for request/response bodies</li> <li>Parameter deserialization benchmarks</li> <li>Strict mode validation overhead</li> <li>Pre-parsed validator reuse performance</li> </ul>"},{"location":"benchmarks/#current-performance-metrics","title":"Current Performance Metrics","text":""},{"location":"benchmarks/#parser-performance","title":"Parser Performance","text":"<p>Document Parsing (with validation, no ref resolution):</p> Document Size Lines Time (\u03bcs) Memory (KB) Allocations Small OAS3 ~60 138 197 2,070 Medium OAS3 ~570 1,119 1,447 17,389 Large OAS3 ~6000 13,880 16,425 194,712 Small OAS2 ~60 134 174 2,059 Medium OAS2 ~570 1,016 1,230 16,027 <p>Parsing without validation provides ~3-5% improvement over validated parsing.</p> <p>JSON Marshaling (post-optimization):</p> Type Extra Fields Time (ns) Memory (bytes) Allocations Info None 432 192 2 Info 5 fields 1,762 1,705 26 Contact None 449 192 2 Contact With extras 1,686 1,377 24 Server None 371 160 2 Server With extras 2,275 2,010 29 OAS3Document Small 19,891 7,003 66 OAS3Document Medium 221,137 65,753 471 OAS3Document Large 2,724,839 840,948 5,336 <p>Observation: Marshaling performance scales linearly with document size and extra field count. The fast path (no extra fields) has minimal overhead.</p> <p>DeepCopy Performance (code-generated, type-aware copying):</p> Document Size Time (ns) Memory (KB) Allocations Small OAS3 1,769 7.2 44 Medium OAS3 24,596 106.01 466 Large OAS3 342,732 1,136 4,877 Small OAS2 1,499 6.2 38 Medium OAS2 20,699 92.5 387 <p>Observation: DeepCopy uses code-generated methods that are type-aware, preserving nil vs empty distinction and handling OAS-specific polymorphic fields (Schema.Type, AdditionalProperties, etc.) correctly. This replaces the previous JSON marshal/unmarshal approach which was ~20-40x slower and corrupted <code>$ref</code> parameters.</p> <p>Order-Preserving Marshaling (pre-parsed with PreserveOrder=true):</p> Format Document Size Time Memory Allocations JSON Small OAS3 9.0 us 4.7 KB 160 JSON Medium OAS3 98.8 us 63.4 KB 1,532 JSON Large OAS3 1.08 ms 631 KB 17,433 YAML Small OAS3 46.1 us 187 KB 390 YAML Medium OAS3 544 us 1.79 MB 3,495 YAML Large OAS3 5.11 ms 22.1 MB 38,850 JSON Indent Medium OAS3 148 us 148 KB 1,535 <p>Order-Preserving vs Standard Marshaling (Medium OAS3):</p> Method Time Memory Allocations Order-Preserving JSON 99.5 us 63.4 KB 1,532 Standard JSON 222 us 65.9 KB 471 <p>PreserveOrder Parsing Overhead (Medium OAS3):</p> Mode Time Memory Allocations With PreserveOrder 1.50 ms 1.71 MB 22,119 Without PreserveOrder 1.10 ms 1.45 MB 17,389 <p>Observation: Order-preserving JSON marshaling is 2.2x faster than standard JSON marshaling (99.5us vs 222us) because it writes directly to a buffer using the source node order, avoiding the overhead of reflection-based encoding. YAML marshaling requires building an intermediate node tree, making it ~5.5x slower than JSON. Enabling PreserveOrder during parsing adds ~37% overhead (storing the yaml.Node tree) but this is amortized when the document is marshaled multiple times with consistent field ordering.</p>"},{"location":"benchmarks/#validator-performance","title":"Validator Performance","text":"<p>Validation (with warnings):</p> Document Size Lines Time (\u03bcs) Memory (KB) Allocations Small OAS3 ~60 139 204 2,162 Medium OAS3 ~570 1,133 1,492 18,307 Large OAS3 ~6000 14,409 16,844 205,022 Small OAS2 ~60 134 181 2,135 Medium OAS2 ~570 1,058 1,268 16,851 <p>Validating pre-parsed documents (ValidateParsed):</p> Document Size Time (\u03bcs) Memory (KB) Allocations Small OAS3 4.7 5.1 90 Medium OAS3 40.4 32.6 914 Large OAS3 462 367 10,297 <p>Observation: ValidateParsed is 31x faster than Validate for small documents (4.7\u03bcs vs 147\u03bcs) because it skips parsing. This is ideal for workflows where documents are parsed once and validated multiple times.</p>"},{"location":"benchmarks/#fixer-performance","title":"Fixer Performance","text":"<p>Fixing (parse + fix):</p> Document Size Lines Time (\u03bcs) Memory (KB) Allocations Small OAS3 ~60 220 279 3,252 Medium OAS3 ~570 2,034 2,208 28,422 Large OAS3 ~6000 24,957 25,028 320,120 Small OAS2 ~60 209 239 3,100 Medium OAS2 ~570 1,733 1,797 24,946 <p>Fixing pre-parsed documents (FixParsed):</p> Document Size Time (\u03bcs) Memory (KB) Allocations Small OAS3 2.4 8.17 52 Medium OAS3 28.6 115.1 530 Large OAS3 354 1,161 5,021 <p>Observation: FixParsed is 60x faster than Fix for small documents (2.3\u03bcs vs 141\u03bcs) because it skips parsing. The v1.20.0 release dramatically improved FixParsed performance by replacing JSON marshal/unmarshal with code-generated DeepCopy methods, resulting in ~37x faster deep copying operations. Type inference has negligible overhead (~3% slower). The fixer is I/O and parse-bound for most workflows.</p>"},{"location":"benchmarks/#converter-performance","title":"Converter Performance","text":"<p>Conversion (parse + convert):</p> Conversion Document Size Time (\u03bcs) Memory (KB) Allocations OAS2 \u2192 OAS3 Small 152 191 2,359 OAS2 \u2192 OAS3 Medium 1,258 1,461 19,640 OAS3 \u2192 OAS2 Small 160 216 2,390 OAS3 \u2192 OAS2 Medium 1,438 1,696 21,369 <p>Converting pre-parsed documents (ConvertParsed):</p> Conversion Document Size Time (\u03bcs) Memory (KB) Allocations OAS2 \u2192 OAS3 Small 3.2 10.0 83 OAS2 \u2192 OAS3 Medium 37.9 119 687 OAS3 \u2192 OAS2 Small 3.6 8.4 89 OAS3 \u2192 OAS2 Medium 44.8 114 821 <p>Observation: ConvertParsed is 42x faster than Convert for small documents (3.2\u03bcs vs 135\u03bcs) because it skips parsing. The v1.20.0 release improved ConvertParsed by ~5x through code-generated DeepCopy methods replacing JSON marshal/unmarshal. Conversion overhead is minimal compared to parsing.</p>"},{"location":"benchmarks/#joiner-performance","title":"Joiner Performance","text":"<p>Joining (parse + join):</p> Documents Time (\u03bcs) Memory (KB) Allocations 2 small 110 141 1,602 3 small 162 210 2,363 <p>Joining pre-parsed documents (JoinParsed):</p> Documents Time (ns) Memory (bytes) Allocations 2 small 732 1,816 22 3 small 934 1,960 23 <p>Observation: JoinParsed is 150x faster than Join for 2 small documents (732ns vs 110\u03bcs) because it skips parsing. The actual joining operation has minimal overhead.</p>"},{"location":"benchmarks/#differ-performance","title":"Differ Performance","text":"<p>Diffing (parse + diff):</p> Mode Time (\u03bcs) Memory (KB) Allocations Simple 463 594 7,182 Breaking 467 597 7,183 <p>Diffing pre-parsed documents (DiffParsed):</p> Mode Time (\u03bcs) Memory (KB) Allocations Simple 5.7 7.6 162 Breaking 6.9 7.9 177 <p>Special cases:</p> Case Time (\u03bcs) Memory (KB) Allocations Identical specs 3.8 3.2 115 With info changes 6.8 7.9 177 Without info 6.9 9.0 178 <p>Observation: DiffParsed is 81x faster than Diff (5.7\u03bcs vs 463\u03bcs) because it skips parsing. The differ includes a fast path for identical specifications that runs in ~3.8\u03bcs. Breaking mode vs Simple mode has negligible performance difference (~1.2\u03bcs), making breaking change detection essentially free.</p>"},{"location":"benchmarks/#generator-performance","title":"Generator Performance","text":"<p>Code Generation (pre-parsed documents):</p> Generation Mode Time (\u03bcs) Memory (KB) Allocations Types only 39 28 724 Client 272 187 4,088 Server 57 48 1,040 All (full) 249 182 3,882 <p>Observation: Types-only generation is fastest at 39\u03bcs. Client generation is most expensive due to HTTP client method generation. Full generation (all modes) is comparable to client-only because client code dominates the generation time.</p>"},{"location":"benchmarks/#builder-performance","title":"Builder Performance","text":"<p>Builder Construction:</p> Operation Time (ns) Memory (bytes) Allocations New 203 736 13 SetInfo (fluent chain) 221 848 14 <p>Schema Generation (reflection-based):</p> Type Time (ns) Memory (bytes) Allocations Primitive 166 768 1 Struct 3,229 15,280 75 Nested struct 4,684 22,960 95 Slice 3,356 16,048 76 Map 3,389 16,048 76 <p>Operation Building:</p> Operation Type Time (ns) Memory (bytes) Allocations Simple operation 4,087 18,633 99 With parameters 5,741 26,925 140 With request body 6,835 31,504 151 <p>Document Building:</p> Operation Time (ns) Memory (bytes) Allocations Build (3 ops) 8,013 35,490 211 MarshalYAML 32,841 93,870 482 MarshalJSON 18,704 8,429 38 <p>Tag Processing:</p> Operation Time (ns) Memory (bytes) Allocations Parse OAS tag 181 432 3 Apply OAS tag 267 1,184 6 <p>Observation: Builder provides efficient programmatic construction of OAS documents. Schema generation from reflection is ~3-5\u03bcs for typical structs, making it suitable for runtime use. JSON marshaling is ~2x faster than YAML marshaling (18.7\u03bcs vs 32.8\u03bcs). Tag parsing is highly optimized at ~181ns per tag.</p>"},{"location":"benchmarks/#http-validator-performance","title":"HTTP Validator Performance","text":"<p>Request Validation (Pre-parsed):</p> Document Size Time (ns) Memory (bytes) Allocations Small (3 paths) 210 528 8 Medium (20 paths) 268 528 8 Large (100+ paths) 502 528 8 <p>Validation Components:</p> Component Time (ns) Memory (bytes) Allocations Path matching only 210-1017 528 8 With parameters 212 528 8 With JSON body 455 1,521 16 Response validation 110 256 2 Strict mode 212 528 8 <p>API Comparison:</p> API Time (ns) Memory (bytes) Allocations ValidateRequestWithOptions (file path) 217,277 207,185 2,203 ValidateRequestWithOptions (parsed) 3,250 9,153 127 Validator.ValidateRequest 210 528 8 <p>Observation: HTTP validation is extremely fast when using a pre-created Validator instance (~210ns per request). The functional options API with file path includes parsing overhead (217\u03bcs), while using pre-parsed results is ~67x faster (3.2\u03bcs). Path matching scales sub-linearly with path count. Response validation is even faster at ~110ns. This makes the httpvalidator package suitable for high-throughput API gateway use cases.</p>"},{"location":"benchmarks/#performance-best-practices","title":"Performance Best Practices","text":""},{"location":"benchmarks/#for-library-users","title":"For Library Users","text":"<ol> <li>Reuse parser/validator/fixer/converter/joiner/differ/httpvalidator instances when processing multiple files with the same configuration</li> <li>Use ParseOnce workflows: For operations on the same document (validate, fix, convert, join, diff), parse once and pass the <code>ParseResult</code> to subsequent operations:</li> </ol> <pre><code>result, _ := parser.Parse(\"spec.yaml\", false, true)\nvalidator.ValidateParsed(result, true, false)   // 30x faster than Validate\nfixer.FixParsed(result)                         // 2.6x faster than Fix\nconverter.ConvertParsed(result, \"3.0.3\")        // 9x faster than Convert\ndiffer.DiffParsed(result1, result2)             // 81x faster than Diff\n</code></pre> <ol> <li>Disable reference resolution (<code>ResolveRefs=false</code>) when not needed</li> <li>Disable validation during parsing (<code>ValidateStructure=false</code>) if you'll validate separately</li> <li>Minimize specification extensions: Documents with many Extra fields (<code>x-*</code>) will be slower to marshal</li> </ol>"},{"location":"benchmarks/#for-high-throughput-scenarios","title":"For High-Throughput Scenarios","text":"<ul> <li>Use the struct-based API (e.g., <code>parser.New()</code>) instead of convenience functions for reusable instances</li> <li>Consider parallel processing of independent documents (oastools is safe for concurrent use)</li> <li>Profile your specific workload to identify bottlenecks</li> </ul>"},{"location":"benchmarks/#benchmark-methodology","title":"Benchmark Methodology","text":"<p>All benchmarks follow these standards:</p> <ul> <li>Run with <code>-benchmem</code> to track memory allocations</li> <li>Use realistic test data from <code>testdata/bench/</code></li> <li>Deterministic and repeatable</li> <li>Measure both CPU time and memory performance</li> </ul> <p>Test Data:</p> <ul> <li>Small documents: ~60 lines</li> <li>Medium documents: ~570 lines</li> <li>Large documents: ~6000 lines</li> </ul> <p>Running Benchmarks:</p> <pre><code># Run all benchmarks\nmake bench-parser\nmake bench-validator\nmake bench-fixer\nmake bench-converter\nmake bench-joiner\nmake bench-differ\nmake bench-generator\nmake bench-builder\n\n# Or individually\ngo test -bench=. -benchmem ./parser\ngo test -bench=. -benchmem ./validator\ngo test -bench=. -benchmem ./fixer\ngo test -bench=. -benchmem ./converter\ngo test -bench=. -benchmem ./joiner\ngo test -bench=. -benchmem ./differ\ngo test -bench=. -benchmem ./generator\ngo test -bench=. -benchmem ./builder\n\n# Save baseline for comparison\ngo test -bench=. -benchmem ./... &gt; benchmark-baseline.txt\n\n# Compare before/after\ngo test -bench=. -benchmem ./... &gt; benchmark-new.txt\nbenchstat benchmark-baseline.txt benchmark-new.txt\n</code></pre>"},{"location":"benchmarks/#future-optimization-opportunities","title":"Future Optimization Opportunities","text":"<p>Based on profiling and analysis, several low-risk optimization opportunities remain available for future releases:</p>"},{"location":"benchmarks/#available-low-risk-optimizations","title":"Available Low-Risk Optimizations","text":"<ol> <li>Memory pre-allocation (5-15% improvement)</li> <li>Pre-allocate slices with capacity hints</li> <li> <p>Reduces GC pressure in high-throughput scenarios</p> </li> <li> <p>Validation early exits (10-20% improvement for invalid documents)</p> </li> <li>Return early when possible for malformed inputs</li> <li> <p>Fast-fail scenarios</p> </li> <li> <p>Reference resolution two-pass (20-30% improvement for docs without refs)</p> </li> <li>Skip resolution when no <code>$ref</code> fields present</li> <li>Benefits simple documents</li> </ol>"},{"location":"benchmarks/#available-medium-risk-optimizations","title":"Available Medium-Risk Optimizations","text":"<ol> <li>Validation caching (20-40% improvement for docs with repeated schemas)</li> <li>Cache validation results by schema hash</li> <li> <p>Helps documents with many references to the same schema</p> </li> <li> <p>Parallel validation (30-50% improvement for large documents)</p> </li> <li>Validate independent paths/schemas concurrently</li> <li> <p>Utilize multiple CPU cores</p> </li> <li> <p>Parallel reference resolution (30-50% improvement for multi-ref docs)</p> </li> <li>Resolve independent references concurrently</li> <li>Benefits documents with many external references</li> </ol> <p>These optimizations are on hold pending real-world performance feedback. The current performance is sufficient for v1.7.0, and future optimization efforts will be prioritized based on demonstrated user needs rather than speculation.</p>"},{"location":"benchmarks/#historical-performance","title":"Historical Performance","text":""},{"location":"benchmarks/#v1290-oas-320-and-json-schema-2020-12-support","title":"v1.29.0 - OAS 3.2.0 and JSON Schema 2020-12 Support","text":"<p>Parser Performance (I/O-Isolated):</p> Benchmark Time Memory Allocations ParseCore/SmallOAS3 134 \u00b5s 196 KB 2,065 ParseCore/MediumOAS3 1.18 ms 1.4 MB 17,384 ParseCore/LargeOAS3 14.0 ms 16.4 MB 194,707 <p>Pre-Parsed Benchmarks (Core Operations):</p> Package Benchmark Time Memory Allocations Validator ValidateParsed 4.8 \u00b5s 5.8 KB 90 Fixer FixParsed 2.8 \u00b5s 9.1 KB 54 Converter ConvertParsed 3.3 \u00b5s 11.1 KB 83 Joiner JoinParsed/TwoDocs 803 ns 1.9 KB 22 Differ Diff/Parsed 12.7 \u00b5s 21.7 KB 369 <p>Changes from v1.28.4: Added support for OAS 3.2.0 fields (<code>$self</code>, <code>Query</code>, <code>additionalOperations</code>, <code>mediaTypes</code>) and JSON Schema 2020-12 keywords (<code>unevaluatedProperties</code>, <code>unevaluatedItems</code>, <code>contentEncoding</code>, <code>contentMediaType</code>, <code>contentSchema</code>). Performance impact: ~0% (new fields are only processed when present).</p>"},{"location":"benchmarks/#baseline-pre-optimization","title":"Baseline (Pre-Optimization)","text":"<p>JSON Marshaling (before v1.7.0):</p> Type Time (ns) Allocations Info 2,323 38 Contact 2,336 38 Server 2,837 41 <p>Post-v1.7.0 Improvement: 25-32% faster, 29-37% fewer allocations</p>"},{"location":"benchmarks/#related-documentation","title":"Related Documentation","text":"<ul> <li>CLAUDE.md - Development guidelines and architecture</li> <li>BENCHMARK_UPDATE_PROCESS.md - How to update benchmarks for releases</li> </ul>"},{"location":"benchmarks/#questions-and-feedback","title":"Questions and Feedback","text":"<p>If you have specific performance requirements or encounter performance issues in your use case, please open an issue on GitHub. Real-world performance feedback helps prioritize future optimization efforts.</p>"},{"location":"breaking-changes/","title":"Detecting API Breaking Changes","text":""},{"location":"breaking-changes/#overview","title":"Overview","text":"<p>The <code>differ</code> package classifies changes between OpenAPI specifications by severity based on their impact on API consumers. This document provides a comprehensive reference for understanding breaking changes and how to handle them.</p>"},{"location":"breaking-changes/#severity-levels","title":"Severity Levels","text":""},{"location":"breaking-changes/#critical-api-consumers-will-break","title":"Critical (API consumers WILL break)","text":"<p>Changes classified as Critical will definitively break existing API consumers. These require immediate attention and typically demand a major version bump.</p> <p>Examples:</p> <ul> <li>Removed endpoints (<code>DELETE /paths/users/{id}</code>)</li> <li>Removed operations (removing <code>GET</code>, <code>POST</code>, <code>DELETE</code>, etc. from an existing path)</li> <li>Removed required request parameters</li> <li>Changed parameter location (<code>query</code> \u2192 <code>header</code>, <code>path</code> \u2192 <code>query</code>)</li> <li>Removed required request body fields</li> <li>Changed response status codes (removing <code>200</code>, <code>201</code>, or other success codes)</li> <li>Removed required response fields</li> <li>Removed security schemes that operations depend on</li> </ul> <p>Impact: Consumers making requests will receive errors or unexpected responses.</p> <p>Action Required: Major version bump (e.g., <code>v1</code> \u2192 <code>v2</code>)</p>"},{"location":"breaking-changes/#error-api-consumers-may-break","title":"Error (API consumers MAY break)","text":"<p>Changes classified as Error severity have a high likelihood of breaking consumers, especially those not written defensively.</p> <p>Examples:</p> <ul> <li>Changed parameter or property types (<code>string</code> \u2192 <code>integer</code>, <code>number</code> \u2192 <code>string</code>)</li> <li>Added new required parameters or fields (existing clients won't send them)</li> <li>Removed optional fields that were commonly used</li> <li>Changed enum values to a more restricted set (<code>[\"A\", \"B\", \"C\"]</code> \u2192 <code>[\"A\", \"B\"]</code>)</li> <li>Removed response content types (<code>application/json</code> \u2192 only <code>application/xml</code>)</li> <li>Changed from single value to array or vice versa</li> <li>Made existing optional parameter required</li> </ul> <p>Impact: Consumers may receive validation errors, type errors, or unexpected behavior.</p> <p>Action Required: Major version bump for public APIs, thorough testing for internal APIs</p>"},{"location":"breaking-changes/#warning-api-consumers-should-be-aware","title":"Warning (API consumers SHOULD be aware)","text":"<p>Changes classified as Warning typically won't break consumers but may affect behavior or require updates for best practices.</p> <p>Examples:</p> <ul> <li>Added new optional parameters</li> <li>Deprecated operations, parameters, or fields</li> <li>Changed descriptions that affect semantics (e.g., documenting new behavior)</li> <li>Added new enum values to an expandable set (<code>[\"A\", \"B\"]</code> \u2192 <code>[\"A\", \"B\", \"C\"]</code>)</li> <li>Changed examples or default values</li> <li>Modified error response structures</li> <li>Changed authentication requirements (added optional security)</li> </ul> <p>Impact: Consumers may miss new functionality or receive deprecation warnings.</p> <p>Action Required: Minor version bump, document in release notes</p>"},{"location":"breaking-changes/#info-non-breaking-changes","title":"Info (Non-breaking changes)","text":"<p>Changes classified as Info are backward compatible and generally improve the API without affecting existing consumers.</p> <p>Examples:</p> <ul> <li>Added new optional fields</li> <li>Relaxed constraints (<code>maxLength</code> increased, <code>minimum</code> decreased)</li> <li>Added new endpoints</li> <li>Added new operations to existing paths</li> <li>Improved documentation, descriptions, or examples</li> <li>Added new response status codes (e.g., adding <code>201</code> when <code>200</code> already exists)</li> <li>Added new content types (while keeping existing ones)</li> <li>Added nullable to optional fields</li> </ul> <p>Impact: No negative impact on consumers; may enable new use cases.</p> <p>Action Required: Patch version bump, document as enhancement</p>"},{"location":"breaking-changes/#version-compatibility","title":"Version Compatibility","text":""},{"location":"breaking-changes/#semantic-versioning-guidance","title":"Semantic Versioning Guidance","text":"<p>Based on the severity of changes detected by the differ:</p> Severity Level Version Change Example Reason Critical or Error MAJOR <code>1.0.0 \u2192 2.0.0</code> Breaking change Warning MINOR <code>1.0.0 \u2192 1.1.0</code> New features, deprecations Info PATCH <code>1.0.0 \u2192 1.0.1</code> Backward-compatible enhancements <p>Mixed Changes: If a release contains changes of multiple severities, use the highest severity level to determine the version bump.</p> <p>For example, if you have:</p> <ul> <li>3 Critical changes</li> <li>5 Warning changes</li> <li>10 Info changes</li> </ul> <p>Use a MAJOR version bump (<code>1.0.0 \u2192 2.0.0</code>).</p>"},{"location":"breaking-changes/#detection-and-usage","title":"Detection and Usage","text":""},{"location":"breaking-changes/#using-the-differ-package","title":"Using the differ Package","text":"<p>The <code>differ</code> package provides two modes:</p> <ol> <li>ModeSimple: Detects all changes without severity classification</li> <li>ModeBreaking: Classifies changes by severity (Critical, Error, Warning, Info)</li> </ol> <p>Example:</p> <pre><code>import \"github.com/erraggy/oastools/differ\"\n\nd := differ.New()\nd.Mode = differ.ModeBreaking\nd.IncludeInfo = true\n\nresult, err := d.Diff(\"api-v1.yaml\", \"api-v2.yaml\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Check for breaking changes\nif result.HasBreakingChanges {\n    fmt.Printf(\"\u26a0\ufe0f  Found %d breaking changes\\n\", result.BreakingCount)\n\n    // Review critical changes\n    for _, change := range result.Changes {\n        if change.Severity == differ.SeverityCritical {\n            fmt.Printf(\"CRITICAL: %s\\n\", change.Message)\n        }\n    }\n}\n</code></pre>"},{"location":"breaking-changes/#command-line","title":"Command Line","text":"<pre><code># Detect breaking changes\noastools diff --breaking api-v1.yaml api-v2.yaml\n\n# Focus on breaking and error-level changes only\noastools diff --breaking --no-info api-v1.yaml api-v2.yaml\n</code></pre>"},{"location":"breaking-changes/#common-scenarios","title":"Common Scenarios","text":""},{"location":"breaking-changes/#adding-a-new-endpoint","title":"Adding a New Endpoint","text":"<pre><code># v1.yaml\npaths:\n  /users:\n    get: ...\n\n# v2.yaml (added /posts)\npaths:\n  /users:\n    get: ...\n  /posts:\n    get: ...\n</code></pre> <p>Severity: Info (non-breaking) Version Change: Patch (<code>1.0.0 \u2192 1.0.1</code>)</p>"},{"location":"breaking-changes/#removing-a-required-parameter","title":"Removing a Required Parameter","text":"<pre><code># v1.yaml\npaths:\n  /users:\n    get:\n      parameters:\n        - name: id\n          in: query\n          required: true\n\n# v2.yaml (removed required parameter)\npaths:\n  /users:\n    get:\n      parameters: []\n</code></pre> <p>Severity: Critical (breaking) Version Change: Major (<code>1.0.0 \u2192 2.0.0</code>) Impact: Existing clients sending <code>id</code> parameter may not receive expected data</p>"},{"location":"breaking-changes/#making-an-optional-parameter-required","title":"Making an Optional Parameter Required","text":"<pre><code># v1.yaml\nparameters:\n  - name: filter\n    in: query\n    required: false\n\n# v2.yaml\nparameters:\n  - name: filter\n    in: query\n    required: true\n</code></pre> <p>Severity: Error (likely breaking) Version Change: Major (<code>1.0.0 \u2192 2.0.0</code>) Impact: Existing clients not sending <code>filter</code> will receive validation errors</p>"},{"location":"breaking-changes/#adding-a-new-optional-parameter","title":"Adding a New Optional Parameter","text":"<pre><code># v1.yaml\nparameters:\n  - name: id\n    required: true\n\n# v2.yaml (added optional parameter)\nparameters:\n  - name: id\n    required: true\n  - name: filter\n    required: false\n</code></pre> <p>Severity: Warning (non-breaking, but noteworthy) Version Change: Minor (<code>1.0.0 \u2192 1.1.0</code>) Impact: Existing clients continue to work; new functionality available</p>"},{"location":"breaking-changes/#changing-a-response-type","title":"Changing a Response Type","text":"<pre><code># v1.yaml\nresponses:\n  200:\n    schema:\n      type: string\n\n# v2.yaml\nresponses:\n  200:\n    schema:\n      type: object\n</code></pre> <p>Severity: Critical (breaking) Version Change: Major (<code>1.0.0 \u2192 2.0.0</code>) Impact: Clients expecting a string will fail to parse the response</p>"},{"location":"breaking-changes/#best-practices","title":"Best Practices","text":""},{"location":"breaking-changes/#for-api-developers","title":"For API Developers","text":"<ol> <li>Always run differ before releasing to understand the impact of your changes</li> <li>Use ModeBreaking to get severity classifications</li> <li>Document all breaking changes in release notes with migration guides</li> <li>Consider deprecation first before removing features (use Warning-level changes)</li> <li>Version your API properly based on severity levels</li> </ol>"},{"location":"breaking-changes/#for-api-consumers","title":"For API Consumers","text":"<ol> <li>Monitor deprecation warnings to prepare for future breaking changes</li> <li>Write defensive code that handles new optional fields gracefully</li> <li>Pin to specific major versions of APIs you depend on</li> <li>Test against new API versions before upgrading</li> <li>Subscribe to API change notifications if available</li> </ol>"},{"location":"breaking-changes/#for-cicd-integration","title":"For CI/CD Integration","text":"<pre><code>#!/bin/bash\n# Example: Fail CI if breaking changes are detected\n\noastools diff \\\n  --breaking \\\n  current-api.yaml \\\n  proposed-api.yaml \\\n  &gt; diff-result.txt\n\n# Check for breaking changes\nif grep -q \"CRITICAL\\|ERROR\" diff-result.txt; then\n  echo \"\u274c Breaking changes detected! Review required.\"\n  exit 1\nfi\n\necho \"\u2713 No breaking changes detected\"\nexit 0\n</code></pre>"},{"location":"breaking-changes/#additional-resources","title":"Additional Resources","text":"<ul> <li>OpenAPI Specification: spec.openapis.org/oas</li> <li>Semantic Versioning: semver.org</li> <li>oastools differ package: pkg.go.dev/github.com/erraggy/oastools/differ</li> </ul> <p>For questions or issues, please open an issue.</p>"},{"location":"claude-code-plugin/","title":"Claude Code Plugin","text":"<p>oastools provides a Claude Code plugin that gives Claude direct access to all OpenAPI tooling through the built-in MCP server. Once installed, Claude can validate, fix, convert, diff, walk, and generate code from your OpenAPI specs without any manual setup.</p>"},{"location":"claude-code-plugin/#prerequisites","title":"Prerequisites","text":"<p>The plugin runs <code>oastools mcp</code> under the hood, so the oastools binary must be installed and available on your <code>PATH</code> before the plugin will work.</p> <p>Install via any of these methods:</p> <p>Homebrew (macOS/Linux):</p> <pre><code>brew install erraggy/oastools/oastools\n</code></pre> <p>Go install:</p> <pre><code># Requires Go 1.24+\ngo install github.com/erraggy/oastools/cmd/oastools@latest\n</code></pre> <p>Binary download:</p> <p>Download a pre-built binary from the Releases page and place it on your <code>PATH</code>.</p> <p>Verify the binary is available:</p> <pre><code>oastools --version\n</code></pre>"},{"location":"claude-code-plugin/#installation","title":"Installation","text":""},{"location":"claude-code-plugin/#option-1-plugin-marketplace-recommended","title":"Option 1: Plugin Marketplace (recommended)","text":"<p>This is the easiest method. Run these commands inside Claude Code (the <code>/plugin</code> commands are Claude Code slash commands, not shell commands):</p> <pre><code>/plugin marketplace add erraggy/oastools\n/plugin install oastools\n</code></pre> <p>The first command registers the oastools marketplace. The second installs the plugin. You'll be prompted to choose an installation scope:</p> Scope Effect User Available in all your projects Project Shared with collaborators (saved to <code>.claude/settings.json</code>) Local Only for you, only in this repository"},{"location":"claude-code-plugin/#option-2-manual-mcp-configuration","title":"Option 2: Manual MCP Configuration","text":"<p>If you prefer not to use the plugin system, you can configure the MCP server directly. Add this to your project's <code>.mcp.json</code> (or create the file if it doesn't exist):</p> <pre><code>{\n  \"mcpServers\": {\n    \"oastools\": {\n      \"type\": \"stdio\",\n      \"command\": \"oastools\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>The manual approach gives you the 17 MCP tools but not the guided skills or CLAUDE.md instructions that come with the plugin. For the full experience, use Option 1.</p>"},{"location":"claude-code-plugin/#verifying-the-installation","title":"Verifying the Installation","text":"<p>After installing, restart Claude Code (or start a new session) and check that the tools are available:</p> <pre><code>/mcp\n</code></pre> <p>You should see <code>oastools</code> listed as an MCP server with 17 tools. You can also ask Claude directly:</p> <p>\"What oastools MCP tools do you have access to?\"</p>"},{"location":"claude-code-plugin/#what-the-plugin-provides","title":"What the Plugin Provides","text":""},{"location":"claude-code-plugin/#17-mcp-tools","title":"17 MCP Tools","text":"<p>The plugin configures the oastools MCP server, which exposes 17 tools that Claude can call directly:</p> <p>Core (9): <code>validate</code>, <code>parse</code>, <code>fix</code>, <code>convert</code>, <code>diff</code>, <code>join</code>, <code>overlay_apply</code>, <code>overlay_validate</code>, <code>generate</code></p> <p>Walk (8): <code>walk_operations</code>, <code>walk_schemas</code>, <code>walk_parameters</code>, <code>walk_responses</code>, <code>walk_headers</code>, <code>walk_security</code>, <code>walk_paths</code>, <code>walk_refs</code></p> <p>See the MCP Server reference for detailed documentation of each tool.</p>"},{"location":"claude-code-plugin/#5-guided-skills","title":"5 Guided Skills","text":"<p>The plugin includes skills that teach Claude best-practice workflows for common tasks:</p> Skill What it does validate-spec Validate a spec, explain errors in plain language, suggest or apply fixes fix-spec Preview fixes with dry run, apply with confirmation, re-validate explore-api Parse for an overview, walk endpoints and schemas, drill into specifics diff-specs Compare two versions, categorize by severity, suggest migration steps generate-code Parse the spec, generate Go code, review output, suggest integration"},{"location":"claude-code-plugin/#claudemd-instructions","title":"CLAUDE.md Instructions","text":"<p>The plugin includes a <code>CLAUDE.md</code> that teaches Claude:</p> <ul> <li>The input model (file vs URL vs inline content)</li> <li>When to prefer <code>file</code> over <code>content</code></li> <li>Common workflows (validate-then-fix, explore-then-modify)</li> <li>Best practices (filter walk results, use dry-run for fix, check breaking changes)</li> </ul>"},{"location":"claude-code-plugin/#usage-examples","title":"Usage Examples","text":"<p>Once the plugin is installed, you can ask Claude to work with your OpenAPI specs naturally:</p> <p>Validate a spec:</p> <p>\"Validate my openapi.yaml and explain any errors\"</p> <p>Claude will call the <code>validate</code> tool, interpret the results, and explain each error with suggested fixes.</p> <p>Explore an API:</p> <p>\"What endpoints does this API have? Show me the user-related ones.\"</p> <p>Claude will <code>parse</code> for an overview, then <code>walk_operations</code> with a tag or path filter.</p> <p>Compare API versions:</p> <p>\"Compare api-v1.yaml and api-v2.yaml \u2014 are there any breaking changes?\"</p> <p>Claude will call <code>diff</code> with both specs and categorize changes by severity.</p> <p>Fix common issues:</p> <p>\"Fix the duplicate operationIds in my spec\"</p> <p>Claude will preview with <code>dry_run</code>, show you the planned fixes, then apply them.</p> <p>Generate a Go client:</p> <p>\"Generate a Go HTTP client from openapi.yaml into ./client\"</p> <p>Claude will call <code>generate</code> with <code>client: true</code> and report the generated files.</p>"},{"location":"claude-code-plugin/#updating-the-plugin","title":"Updating the Plugin","text":"<p>If you installed via the marketplace, Claude Code will check for updates automatically. You can also update manually:</p> <pre><code>/plugin update oastools\n</code></pre>"},{"location":"claude-code-plugin/#uninstalling","title":"Uninstalling","text":"<pre><code>/plugin uninstall oastools\n</code></pre>"},{"location":"claude-code-plugin/#plugin-structure","title":"Plugin Structure","text":"<pre><code>plugin/\n\u251c\u2500\u2500 .claude-plugin/\n\u2502   \u2514\u2500\u2500 plugin.json           # Plugin manifest (name, version, author)\n\u251c\u2500\u2500 .mcp.json                 # MCP server configuration\n\u251c\u2500\u2500 CLAUDE.md                 # Instructions for Claude (tools, best practices)\n\u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 hooks.json            # SessionStart hook configuration\n\u2502   \u2514\u2500\u2500 scripts/\n\u2502       \u2514\u2500\u2500 check-binary.sh   # Verify oastools binary is on PATH\n\u2514\u2500\u2500 skills/\n    \u251c\u2500\u2500 validate-spec/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Guided validation workflow\n    \u251c\u2500\u2500 fix-spec/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Guided fix workflow\n    \u251c\u2500\u2500 explore-api/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Guided exploration workflow\n    \u251c\u2500\u2500 diff-specs/\n    \u2502   \u2514\u2500\u2500 SKILL.md          # Guided diff workflow\n    \u2514\u2500\u2500 generate-code/\n        \u2514\u2500\u2500 SKILL.md          # Guided code generation workflow\n</code></pre>"},{"location":"claude-code-plugin/#troubleshooting","title":"Troubleshooting","text":"<p>\"oastools: command not found\"</p> <p>The MCP server requires the <code>oastools</code> binary on your PATH. See Prerequisites above for installation options. After installing, you may need to restart your terminal or Claude Code session.</p> <p>Tools aren't appearing in Claude Code</p> <ol> <li>Verify the plugin is installed: <code>/plugin list</code></li> <li>Check that <code>oastools mcp</code> runs without errors: <code>echo '{}' | oastools mcp</code></li> <li>Restart Claude Code to pick up configuration changes</li> </ol> <p>\"spec input is required\" errors</p> <p>Every tool requires a spec input. Make sure you're providing exactly one of <code>file</code>, <code>url</code>, or <code>content</code> inside the <code>spec</code> object:</p> <pre><code>{\"spec\": {\"file\": \"openapi.yaml\"}}\n</code></pre>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete command-line reference for oastools.</p>"},{"location":"cli-reference/#global-usage","title":"Global Usage","text":"<pre><code>oastools &lt;command&gt; [options] [arguments]\n</code></pre>"},{"location":"cli-reference/#flag-syntax","title":"Flag Syntax","text":"<p>All flags accept both single-hyphen (<code>-flag</code>) and double-hyphen (<code>--flag</code>) syntax:</p> <pre><code># These are equivalent:\noastools validate -strict openapi.yaml\noastools validate --strict openapi.yaml\n\n# Short flags use single hyphen:\noastools generate -o ./out -p api openapi.yaml\n\n# Long flags typically use double hyphen (convention):\noastools generate --output ./out --package api openapi.yaml\n\n# Boolean flags can be set with or without =true:\noastools validate -strict         # equivalent to -strict=true\noastools validate --strict=false  # explicitly disable\n</code></pre>"},{"location":"cli-reference/#commands-overview","title":"Commands Overview","text":"Command Description <code>validate</code> Validate an OpenAPI specification file or URL <code>fix</code> Automatically fix common validation errors <code>parse</code> Parse and display an OpenAPI specification <code>convert</code> Convert between OpenAPI specification versions <code>join</code> Join multiple OpenAPI specifications <code>diff</code> Compare two OpenAPI specifications <code>generate</code> Generate Go code from an OpenAPI specification <code>overlay</code> Apply OpenAPI Overlay transformations <code>walk</code> Query and inspect spec elements (operations, schemas, parameters, responses, security, paths) <code>mcp</code> Start an MCP server over stdio for AI-assisted development <code>version</code> Show version information <code>help</code> Show help information"},{"location":"cli-reference/#validate","title":"validate","text":"<p>Validate an OpenAPI specification file, URL, or stdin against the specification version it declares.</p>"},{"location":"cli-reference/#synopsis","title":"Synopsis","text":"<pre><code>oastools validate [flags] &lt;file|url|-&gt;\n</code></pre>"},{"location":"cli-reference/#flags","title":"Flags","text":"Flag Description <code>--strict</code> Enable stricter validation beyond spec requirements <code>--no-warnings</code> Suppress warning messages (only show errors) <code>--validate-structure</code> Perform basic structure validation during parsing (default: true) <code>-s, --source-map</code> Include line numbers in output (IDE-friendly format) <code>-q, --quiet</code> Quiet mode: only output validation result, no diagnostic messages <code>--format</code> Output format: text, json, or yaml (default: \"text\") <code>--include-document</code> Include the full OAS document in JSON/YAML output <code>-h, --help</code> Display help for validate command"},{"location":"cli-reference/#examples","title":"Examples","text":"<pre><code># Validate a local YAML file\noastools validate openapi.yaml\n\n# Validate a local JSON file\noastools validate openapi.json\n\n# Validate from a URL\noastools validate https://example.com/api/openapi.yaml\n\n# Enable strict mode (treats warnings as errors)\noastools validate --strict openapi.yaml\n\n# Show only errors, suppress warnings\noastools validate --no-warnings openapi.yaml\n\n# Combine flags\noastools validate --strict --no-warnings openapi.yaml\n\n# Skip parser structure validation (useful for examining partially valid specs)\noastools validate --validate-structure=false openapi.yaml\n\n# Output as JSON for programmatic processing\noastools validate --format json openapi.yaml | jq '.valid'\n\n# Output as YAML\noastools validate --format yaml openapi.yaml\n\n# Read from stdin (for pipelines)\ncat openapi.yaml | oastools validate -\n\n# Pipeline with quiet mode\ncat openapi.yaml | oastools validate -q -\n</code></pre>"},{"location":"cli-reference/#pipelining","title":"Pipelining","text":"<p>The validate command supports shell pipelines:</p> <ul> <li>Use <code>-</code> as the file path to read from stdin</li> <li>Use <code>--quiet/-q</code> to suppress diagnostic output for clean pipelining</li> <li>Use <code>--format json/yaml</code> for structured output that can be parsed by other tools</li> </ul> <pre><code># Validate and extract just the valid field\ncat openapi.yaml | oastools validate --format json - | jq '.valid'\n\n# Chain with other tools\ncurl -s https://example.com/openapi.yaml | oastools validate -q -\n</code></pre>"},{"location":"cli-reference/#output-format","title":"Output Format","text":"<pre><code>OpenAPI Specification Validator\n================================\n\noastools version: v1.17.1\nSpecification: openapi.yaml\nOAS Version: 3.0.3\nSource Size: 2.5 KB\nPaths: 5\nOperations: 12\nSchemas: 8\nLoad Time: 125ms\nTotal Time: 140ms\n\nErrors (2):\n  \u2717 paths./users.get.responses: missing required field '200' or 'default'\n    Spec: https://spec.openapis.org/oas/v3.0.3.html#responses-object\n  \u2717 components.schemas.User.properties.id: missing required 'type' field\n    Spec: https://spec.openapis.org/oas/v3.0.3.html#schema-object\n\nWarnings (1):\n  \u26a0 paths./users/{id}.get: Operation should have a description or summary\n    Spec: https://spec.openapis.org/oas/v3.0.3.html#operation-object\n\n\u2717 Validation failed: 2 error(s), 1 warning(s)\n</code></pre>"},{"location":"cli-reference/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Validation passed 1 Validation failed (errors found)"},{"location":"cli-reference/#fix","title":"fix","text":"<p>Automatically fix common validation errors in an OpenAPI specification file, URL, or stdin.</p>"},{"location":"cli-reference/#synopsis_1","title":"Synopsis","text":"<pre><code>oastools fix [flags] &lt;file|url|-&gt;\n</code></pre>"},{"location":"cli-reference/#description","title":"Description","text":"<p>The fix command automatically corrects common validation errors in OpenAPI specifications. Currently supported fixes:</p> <ul> <li>Missing path parameters: Adds missing path parameters (e.g., <code>{userId}</code>) that are referenced in the path but not declared in the parameters list</li> <li>Invalid schema names (<code>--fix-schema-names</code>): Renames schemas with invalid characters (brackets, special characters) using configurable naming strategies</li> <li>Stub missing references (<code>--stub-missing-refs</code>): Creates stub definitions for unresolved local <code>$ref</code> pointers. Schemas get empty <code>{}</code> stubs, responses get stubs with configurable descriptions</li> <li>Prune unused schemas (<code>--prune-schemas</code>): Removes schema definitions that are not referenced anywhere in the document</li> <li>Prune empty paths (<code>--prune-paths</code>): Removes path items that have no HTTP operations defined</li> <li>Duplicate operationIds (<code>--fix-duplicate-operationids</code>): Renames duplicate operationId values using a configurable template</li> </ul>"},{"location":"cli-reference/#flags_1","title":"Flags","text":"Flag Description <code>--infer</code> Infer parameter types from naming conventions (e.g., <code>userId</code> \u2192 integer) <code>-s, --source-map</code> Include line numbers in output (IDE-friendly format) <code>-o, --output</code> Output file path (default: stdout) <code>-q, --quiet</code> Quiet mode: only output the fixed document, no diagnostic messages <code>--fix-schema-names</code> Fix invalid schema names (brackets, special characters) <code>--generic-naming</code> Strategy for renaming generic types: <code>underscore</code>, <code>of</code>, <code>for</code>, <code>flat</code>, <code>dot</code> (default: underscore) <code>--generic-separator</code> Separator for underscore strategy (default: <code>_</code>) <code>--generic-param-separator</code> Separator between multiple type parameters (default: <code>_</code>) <code>--preserve-casing</code> Preserve original casing of type parameters <code>--stub-missing-refs</code> Create stubs for unresolved local $ref pointers <code>--stub-response-desc</code> Description text for stub responses (default: auto-generated message) <code>--prune-schemas</code> Remove unreferenced schema definitions <code>--prune-paths</code> Remove paths with no operations <code>--prune-all, --prune</code> Apply all pruning fixes (schemas, paths) <code>--fix-duplicate-operationids</code> Rename duplicate operationId values <code>--operationid-template</code> Template for renamed operationIds (default: <code>{operationId}{n}</code>) <code>--operationid-path-sep</code> Separator for path segments in operationId template (default: <code>_</code>) <code>--operationid-tag-sep</code> Separator for tags in operationId template (default: <code>_</code>) <code>--dry-run</code> Preview changes without modifying the document <code>-h, --help</code> Display help for fix command"},{"location":"cli-reference/#type-inference","title":"Type Inference","text":"<p>When <code>--infer</code> is enabled, parameter types are inferred from naming conventions:</p> Pattern Type Format Names ending in <code>id</code>, <code>Id</code>, <code>ID</code> <code>integer</code> - Names containing <code>uuid</code>, <code>guid</code> <code>string</code> <code>uuid</code> All other names <code>string</code> -"},{"location":"cli-reference/#generic-naming-strategies","title":"Generic Naming Strategies","text":"<p>When <code>--fix-schema-names</code> is enabled, schemas with invalid names (containing brackets or special characters) are renamed using the selected strategy:</p> Strategy Example Input Output <code>underscore</code> (default) <code>Response[User]</code> <code>Response_User_</code> <code>of</code> <code>Response[User]</code> <code>ResponseOfUser</code> <code>for</code> <code>Response[User]</code> <code>ResponseForUser</code> <code>flat</code> <code>Response[User]</code> <code>ResponseUser</code> <code>dot</code> <code>Response[User]</code> <code>Response.User</code> <p>For multi-parameter types like <code>Map[string,int]</code>:</p> <ul> <li><code>underscore</code>: <code>Map_String_Int_</code></li> <li><code>of</code>: <code>MapOfStringOfInt</code></li> </ul>"},{"location":"cli-reference/#duplicate-operationid-templates","title":"Duplicate OperationId Templates","text":"<p>When <code>--fix-duplicate-operationids</code> is enabled, duplicate operationId values are renamed using a configurable template. The template supports placeholders and modifiers:</p> <p>Placeholders:</p> Placeholder Description Example <code>{operationId}</code> Original operationId <code>getUser</code> <code>{method}</code> HTTP method (lowercase) <code>get</code> <code>{path}</code> URL path (sanitized) <code>users_id</code> <code>{tag}</code> First operation tag <code>users</code> <code>{tags}</code> All tags joined <code>users_admin</code> <code>{n}</code> Collision counter (2, 3, ...) <code>2</code> <p>Modifiers:</p> <p>Append to placeholders with colon syntax: <code>{operationId:pascal}</code>, <code>{path:camel}</code>, etc.</p> Modifier Effect Example Input Example Output <code>:pascal</code> PascalCase <code>get_user</code> <code>GetUser</code> <code>:camel</code> camelCase <code>GetUser</code> <code>getUser</code> <code>:snake</code> snake_case <code>GetUser</code> <code>get_user</code> <code>:kebab</code> kebab-case <code>GetUser</code> <code>get-user</code> <code>:upper</code> UPPERCASE <code>getUser</code> <code>GETUSER</code> <code>:lower</code> lowercase <code>GetUser</code> <code>getuser</code> <p>Default template: <code>{operationId}{n}</code> produces <code>getUser</code>, <code>getUser2</code>, <code>getUser3</code>, etc.</p>"},{"location":"cli-reference/#examples_1","title":"Examples","text":"<pre><code># Fix a local file and output to stdout\noastools fix openapi.yaml\n\n# Fix and write to a specific file\noastools fix openapi.yaml -o fixed.yaml\n\n# Fix with type inference\noastools fix --infer openapi.yaml -o fixed.yaml\n\n# Fix from a URL\noastools fix https://example.com/api/openapi.yaml -o fixed.yaml\n\n# Fix invalid schema names with \"Of\" strategy\noastools fix --fix-schema-names --generic-naming of api.yaml\n\n# Remove unused schemas and empty paths\noastools fix --prune-all api.yaml\n\n# Preview changes without modifying (dry run)\noastools fix --dry-run --prune-schemas api.yaml\n\n# Create stubs for missing $ref targets\noastools fix --stub-missing-refs api.yaml\n\n# Create stubs with custom response description\noastools fix --stub-missing-refs --stub-response-desc \"TODO: implement\" api.yaml\n\n# Fix duplicate operationIds (default template: {operationId}{n})\noastools fix --fix-duplicate-operationids api.yaml\n\n# Fix duplicate operationIds with custom template\noastools fix --fix-duplicate-operationids --operationid-template \"{method:pascal}{path:pascal}\" api.yaml\n\n# Fix from stdin (for pipelines)\ncat openapi.yaml | oastools fix - &gt; fixed.yaml\n\n# Pipeline: fix then validate\noastools fix api.yaml | oastools validate -q -\n\n# Pipeline with quiet mode\ncat openapi.yaml | oastools fix -q - | oastools validate -q -\n</code></pre>"},{"location":"cli-reference/#pipelining_1","title":"Pipelining","text":"<p>The fix command supports shell pipelines:</p> <ul> <li>Use <code>-</code> as the file path to read from stdin</li> <li>Use <code>--quiet/-q</code> to suppress diagnostic output for clean pipelining</li> <li>Output goes to stdout by default (use <code>-o</code> for file output)</li> </ul> <pre><code># Fix and pipe to validate\ncat openapi.yaml | oastools fix -q - | oastools validate -q -\n\n# Chain with curl\ncurl -s https://example.com/openapi.yaml | oastools fix -q - &gt; fixed.yaml\n</code></pre>"},{"location":"cli-reference/#output-format_1","title":"Output Format","text":"<pre><code>OpenAPI Specification Fixer\n===========================\n\noastools version: v1.17.1\nSpecification: openapi.yaml\nOAS Version: 3.0.3\nSource Size: 2.5 KB\nPaths: 5\nOperations: 12\nSchemas: 8\nLoad Time: 125ms\nTotal Time: 140ms\n\nFixes Applied (3):\n  \u2713 paths./users/{userId}.get.parameters: Added missing path parameter 'userId' (type: string)\n  \u2713 paths./projects/{projectId}.get.parameters: Added missing path parameter 'projectId' (type: integer)\n  \u2713 paths./docs/{documentUuid}.get.parameters: Added missing path parameter 'documentUuid' (type: string, format: uuid)\n\n\u2713 Fixed: 3 issue(s) corrected\n</code></pre>"},{"location":"cli-reference/#exit-codes_1","title":"Exit Codes","text":"Code Meaning 0 Fix completed successfully 1 Fix failed (parse error or invalid input)"},{"location":"cli-reference/#parse","title":"parse","text":"<p>Parse and output OpenAPI document structure and metadata.</p>"},{"location":"cli-reference/#synopsis_2","title":"Synopsis","text":"<pre><code>oastools parse [flags] &lt;file|url|-&gt;\n</code></pre>"},{"location":"cli-reference/#flags_2","title":"Flags","text":"Flag Description <code>--resolve-refs</code> Resolve external $ref references <code>--resolve-http-refs</code> Resolve HTTP/HTTPS $ref URLs (requires --resolve-refs) <code>--insecure</code> Disable TLS certificate verification for HTTPS refs <code>--validate-structure</code> Validate document structure during parsing <code>-q, --quiet</code> Quiet mode: only output the document, no diagnostic messages <code>-h, --help</code> Display help for parse command"},{"location":"cli-reference/#examples_2","title":"Examples","text":"<pre><code># Parse a local file\noastools parse openapi.yaml\n\n# Parse from a URL\noastools parse https://petstore.swagger.io/v2/swagger.yaml\n\n# Parse with external reference resolution\noastools parse --resolve-refs openapi.yaml\n\n# Parse with structure validation\noastools parse --validate-structure openapi.yaml\n\n# Combine both options\noastools parse --resolve-refs --validate-structure openapi.yaml\n\n# Read from stdin (for pipelines)\ncat openapi.yaml | oastools parse -\n\n# Pipeline with quiet mode (output only JSON)\ncat openapi.yaml | oastools parse -q -\n</code></pre>"},{"location":"cli-reference/#pipelining_2","title":"Pipelining","text":"<p>The parse command supports shell pipelines:</p> <ul> <li>Use <code>-</code> as the file path to read from stdin</li> <li>Use <code>--quiet/-q</code> to suppress diagnostic output and get clean JSON output</li> </ul> <pre><code># Parse and pipe to jq for processing\ncat openapi.yaml | oastools parse -q - | jq '.info.title'\n\n# Chain with other tools\ncurl -s https://example.com/openapi.yaml | oastools parse -q -\n</code></pre>"},{"location":"cli-reference/#output-format_2","title":"Output Format","text":"<pre><code>OpenAPI Specification Parser\n============================\n\noastools version: v1.17.1\nSpecification: petstore.yaml\nOAS Version: 3.0.3\nSource Size: 15.2 KB\nPaths: 8\nOperations: 15\nSchemas: 12\nLoad Time: 45ms\n\nDocument Type: OpenAPI 3.x\nTitle: Petstore API\nDescription: A sample API for a pet store\nVersion: 1.0.0\nServers: 2\nPaths: 8\n\nRaw Data (JSON):\n{\n  \"openapi\": \"3.0.3\",\n  \"info\": {\n    \"title\": \"Petstore API\",\n    ...\n  }\n}\n\nParsing completed successfully!\n</code></pre>"},{"location":"cli-reference/#exit-codes_2","title":"Exit Codes","text":"Code Meaning 0 Parsing succeeded 1 Parsing failed (errors found)"},{"location":"cli-reference/#convert","title":"convert","text":"<p>Convert an OpenAPI specification from one version to another.</p>"},{"location":"cli-reference/#synopsis_3","title":"Synopsis","text":"<pre><code>oastools convert [flags] &lt;file|url|-&gt;\n</code></pre>"},{"location":"cli-reference/#flags_3","title":"Flags","text":"Flag Short Description <code>--target</code> <code>-t</code> Target OAS version (required). Examples: \"3.0.3\", \"2.0\", \"3.1.0\" <code>--output</code> <code>-o</code> Output file path (default: stdout) <code>--strict</code> Fail on any conversion issues (even warnings) <code>--no-warnings</code> Suppress warning and info messages <code>--source-map</code> <code>-s</code> Include line numbers in output (IDE-friendly format) <code>-q, --quiet</code> Quiet mode: only output the document, no diagnostic messages <code>-h, --help</code> Display help for convert command"},{"location":"cli-reference/#supported-conversions","title":"Supported Conversions","text":"Source Target Notes OAS 2.0 OAS 3.0.x Full support OAS 2.0 OAS 3.1.x Full support OAS 2.0 OAS 3.2.x Full support OAS 3.x OAS 2.0 Some features cannot be converted OAS 3.x OAS 3.y Version updates supported"},{"location":"cli-reference/#examples_3","title":"Examples","text":"<pre><code># Convert Swagger 2.0 to OpenAPI 3.0.3\noastools convert -t 3.0.3 swagger.yaml -o openapi.yaml\n\n# Convert from URL\noastools convert -t 3.0.3 https://example.com/swagger.yaml -o openapi.yaml\n\n# Convert to stdout (for piping)\noastools convert -t 3.0.3 swagger.yaml &gt; openapi.yaml\n\n# Convert OpenAPI 3.x back to Swagger 2.0\noastools convert -t 2.0 openapi.yaml -o swagger.yaml\n\n# Strict mode: fail on any conversion issues\noastools convert --strict -t 3.0.3 swagger.yaml -o openapi.yaml\n\n# Suppress informational messages\noastools convert --no-warnings -t 3.0.3 swagger.yaml -o openapi.yaml\n\n# Update OpenAPI 3.0.x to 3.1.0\noastools convert -t 3.1.0 openapi-3.0.yaml -o openapi-3.1.yaml\n\n# Read from stdin (for pipelines)\ncat swagger.yaml | oastools convert -t 3.0.3 - -o openapi.yaml\n\n# Pipeline with quiet mode (output to stdout)\ncat swagger.yaml | oastools convert -q -t 3.0.3 - &gt; openapi.yaml\n</code></pre>"},{"location":"cli-reference/#pipelining_3","title":"Pipelining","text":"<p>The convert command supports shell pipelines:</p> <ul> <li>Use <code>-</code> as the file path to read from stdin</li> <li>Use <code>--quiet/-q</code> to suppress diagnostic output for clean pipelining</li> <li>Output goes to stdout by default (use <code>-o</code> for file output)</li> </ul> <pre><code># Convert and write to file\ncat swagger.yaml | oastools convert -q -t 3.0.3 - &gt; openapi.yaml\n\n# Chain conversions\ncurl -s https://example.com/swagger.yaml | oastools convert -q -t 3.0.3 - &gt; openapi.yaml\n</code></pre>"},{"location":"cli-reference/#output-format_3","title":"Output Format","text":"<pre><code>OpenAPI Specification Converter\n===============================\n\noastools version: v1.17.1\nSpecification: swagger.yaml\nSource Version: 2.0\nTarget Version: 3.0.3\nSource Size: 8.5 KB\nPaths: 5\nOperations: 12\nSchemas: 8\nLoad Time: 85ms\nTotal Time: 95ms\n\nConversion Issues (3):\n  [INFO] servers: Converted host 'api.example.com' to server URL 'https://api.example.com/v1'\n  [WARNING] parameters.filter.allowEmptyValue: OAS 3.x does not support allowEmptyValue; dropped\n  [INFO] securityDefinitions: Converted to components.securitySchemes\n\n\u2713 Conversion successful (2 info, 1 warnings)\n\nOutput written to: openapi.yaml\n</code></pre>"},{"location":"cli-reference/#exit-codes_3","title":"Exit Codes","text":"Code Meaning 0 Conversion successful 1 Conversion failed (critical issues)"},{"location":"cli-reference/#join","title":"join","text":"<p>Join multiple OpenAPI specification files into a single document.</p>"},{"location":"cli-reference/#synopsis_4","title":"Synopsis","text":"<pre><code>oastools join [flags] &lt;file1&gt; &lt;file2&gt; [file3...]\n</code></pre>"},{"location":"cli-reference/#flags_4","title":"Flags","text":"Flag Short Description <code>--output</code> <code>-o</code> Output file path (required) <code>--path-strategy</code> Collision strategy for paths <code>--schema-strategy</code> Collision strategy for schemas/definitions <code>--component-strategy</code> Collision strategy for other components <code>--rename-template</code> Go template for renamed schemas (default: <code>{{.Name}}_{{.Source}}</code>) <code>--operation-context</code> Enable operation-aware schema renaming <code>--primary-operation-policy</code> Policy for selecting primary operation: <code>first</code>, <code>most-specific</code>, <code>alphabetical</code> (default: <code>first</code>) <code>--semantic-dedup</code> Enable semantic deduplication to consolidate identical schemas <code>--equivalence-mode</code> Schema comparison mode for deduplication: <code>none</code>, <code>shallow</code>, <code>deep</code> (default: <code>none</code>) <code>--collision-report</code> Generate detailed collision analysis report <code>--namespace-prefix</code> Namespace prefix for source file (format: source=prefix, can be repeated) <code>--always-prefix</code> Apply namespace prefix to all schemas, not just on collision <code>--no-merge-arrays</code> Don't merge arrays (servers, security, etc.) <code>--no-dedup-tags</code> Don't deduplicate tags by name <code>--pre-overlay</code> Overlay file to apply before joining (can be repeated) <code>--post-overlay</code> Overlay file to apply to merged result <code>--source-map</code> <code>-s</code> Include line numbers in output (IDE-friendly format) <code>-q, --quiet</code> Quiet mode: suppress diagnostic messages (for pipelining) <code>-h, --help</code> Display help for join command"},{"location":"cli-reference/#collision-strategies","title":"Collision Strategies","text":"Strategy Description <code>accept-left</code> Keep the first value when collisions occur <code>accept-right</code> Keep the last value when collisions occur (overwrite) <code>fail</code> Fail with an error on any collision <code>fail-on-paths</code> Fail only on path collisions, allow schema collisions <code>rename-left</code> Rename left schema, keep right under original name <code>rename-right</code> Rename right schema, keep left under original name <code>dedup-equivalent</code> Merge structurally identical schemas"},{"location":"cli-reference/#schema-renaming","title":"Schema Renaming","text":"<p>When using <code>rename-left</code> or <code>rename-right</code> strategies, schemas are renamed using Go templates. The <code>--rename-template</code> flag controls the naming pattern.</p>"},{"location":"cli-reference/#basic-template-variables","title":"Basic Template Variables","text":"Variable Description Example <code>{{.Name}}</code> Original schema name <code>Response</code> <code>{{.Source}}</code> Source file name (sanitized) <code>orders_service</code> <code>{{.Index}}</code> Document index (0-based) <code>1</code>"},{"location":"cli-reference/#operation-context-variables","title":"Operation Context Variables","text":"<p>When <code>--operation-context</code> is enabled, additional variables become available based on the operations that reference each schema:</p> Variable Description Example <code>{{.Path}}</code> API path from primary operation <code>/orders</code> <code>{{.Method}}</code> HTTP method (lowercase) <code>get</code> <code>{{.OperationID}}</code> Operation ID if defined <code>listOrders</code> <code>{{.Tags}}</code> Tags from primary operation <code>[\"orders\"]</code> <code>{{.UsageType}}</code> Where schema is used <code>response</code> <code>{{.StatusCode}}</code> Response status code <code>200</code> <code>{{.ParamName}}</code> Parameter name (for parameter usage) <code>filter</code> <code>{{.MediaType}}</code> Content media type <code>application/json</code> <code>{{.PrimaryResource}}</code> First path segment <code>orders</code>"},{"location":"cli-reference/#aggregate-variables-multi-operation-schemas","title":"Aggregate Variables (Multi-Operation Schemas)","text":"Variable Description Example <code>{{.AllPaths}}</code> All paths referencing this schema <code>[\"/orders\", \"/orders/{id}\"]</code> <code>{{.AllMethods}}</code> All HTTP methods (deduplicated) <code>[\"get\", \"post\"]</code> <code>{{.AllOperationIDs}}</code> All operation IDs <code>[\"listOrders\", \"getOrder\"]</code> <code>{{.AllTags}}</code> All tags (deduplicated, sorted) <code>[\"admin\", \"orders\"]</code> <code>{{.RefCount}}</code> Total operation references <code>3</code> <code>{{.IsShared}}</code> True if used by multiple operations <code>true</code>"},{"location":"cli-reference/#template-functions","title":"Template Functions","text":"<p>The following functions are available in rename templates:</p>"},{"location":"cli-reference/#path-functions","title":"Path Functions","text":"Function Description Example <code>pathSegment</code> Extract nth segment (0-indexed, negative from end) <code>{{pathSegment .Path 0}}</code> -&gt; <code>users</code> <code>pathResource</code> First non-parameter segment <code>{{pathResource .Path}}</code> -&gt; <code>users</code> <code>pathLast</code> Last non-parameter segment <code>{{pathLast .Path}}</code> -&gt; <code>orders</code> <code>pathClean</code> Sanitize path for naming <code>{{pathClean .Path}}</code> -&gt; <code>users_id</code>"},{"location":"cli-reference/#case-functions","title":"Case Functions","text":"Function Description Example <code>pascalCase</code> PascalCase conversion <code>{{pascalCase \"list_orders\"}}</code> -&gt; <code>ListOrders</code> <code>camelCase</code> camelCase conversion <code>{{camelCase \"list_orders\"}}</code> -&gt; <code>listOrders</code> <code>snakeCase</code> snake_case conversion <code>{{snakeCase \"ListOrders\"}}</code> -&gt; <code>list_orders</code> <code>kebabCase</code> kebab-case conversion <code>{{kebabCase \"ListOrders\"}}</code> -&gt; <code>list-orders</code>"},{"location":"cli-reference/#tag-functions","title":"Tag Functions","text":"Function Description Example <code>firstTag</code> First tag or empty string <code>{{firstTag .Tags}}</code> -&gt; <code>orders</code> <code>joinTags</code> Join tags with separator <code>{{joinTags .Tags \"_\"}}</code> -&gt; <code>admin_orders</code> <code>hasTag</code> Check if tag exists <code>{{if hasTag .Tags \"admin\"}}...{{end}}</code>"},{"location":"cli-reference/#conditional-helpers","title":"Conditional Helpers","text":"Function Description Example <code>default</code> Return fallback if value empty <code>{{.OperationID \\| default \"Unknown\"}}</code> <code>coalesce</code> First non-empty value <code>{{coalesce .OperationID .Path .Name}}</code>"},{"location":"cli-reference/#primary-operation-policy","title":"Primary Operation Policy","text":"<p>When a schema is referenced by multiple operations, the <code>--primary-operation-policy</code> flag determines which operation provides the context variables:</p> Policy Behavior <code>first</code> Uses the first operation found during graph traversal (default) <code>most-specific</code> Prefers operations with operationId, then those with tags <code>alphabetical</code> Sorts by path+method, uses alphabetically first"},{"location":"cli-reference/#examples_4","title":"Examples","text":"<pre><code># Basic join of two files\noastools join -o merged.yaml base.yaml extension.yaml\n\n# Join multiple files\noastools join -o api.yaml users.yaml posts.yaml comments.yaml\n\n# Keep first value on collision\noastools join --path-strategy accept-left -o merged.yaml base.yaml ext.yaml\n\n# Keep last value on collision (overwrite)\noastools join --path-strategy accept-right -o merged.yaml base.yaml ext.yaml\n\n# Fail on any collision\noastools join --path-strategy fail -o merged.yaml base.yaml ext.yaml\n\n# Different strategies for different components\noastools join \\\n  --path-strategy fail \\\n  --schema-strategy accept-left \\\n  --component-strategy accept-right \\\n  -o merged.yaml base.yaml ext.yaml\n\n# Don't merge arrays\noastools join --no-merge-arrays -o merged.yaml base.yaml ext.yaml\n\n# Don't deduplicate tags\noastools join --no-dedup-tags -o merged.yaml base.yaml ext.yaml\n\n# Enable semantic deduplication to consolidate identical schemas\noastools join --semantic-dedup -o merged.yaml api1.yaml api2.yaml\n\n# Rename colliding schemas with source file suffix\noastools join --schema-strategy rename-right \\\n  --rename-template \"{{.Name}}_{{.Source}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Operation-aware renaming with OperationID\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{.OperationID | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Path-based renaming (uses first path segment as prefix)\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{pathResource .Path | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Most specific operation policy (prefers operations with operationId)\noastools join --schema-strategy rename-right --operation-context \\\n  --primary-operation-policy most-specific \\\n  --rename-template \"{{.OperationID | default .Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Apply overlays for pre/post processing\noastools join --pre-overlay normalize.yaml --post-overlay enhance.yaml \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Multiple pre-overlays (applied in order)\noastools join \\\n  --pre-overlay strip-internal.yaml \\\n  --pre-overlay standardize-responses.yaml \\\n  --post-overlay add-metadata.yaml \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Complex template with fallbacks\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{coalesce .OperationID (pathResource .Path) .Source | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Handle shared schemas differently\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{if .IsShared}}Shared{{else}}{{.OperationID | pascalCase}}{{end}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n</code></pre>"},{"location":"cli-reference/#output-format_4","title":"Output Format","text":"<pre><code>OpenAPI Specification Joiner\n============================\n\noastools version: v1.17.1\nSuccessfully joined 3 specification files\nOutput: merged.yaml\nOAS Version: 3.0.3\nPaths: 12\nOperations: 28\nSchemas: 15\nTotal Time: 250ms\n\nCollisions resolved: 2\n\nWarnings (1):\n  - Schema 'User' collision resolved with accept-left strategy\n\n\u2713 Join completed successfully!\n</code></pre> <p>With Semantic Deduplication:</p> <p>When <code>--semantic-dedup</code> is enabled, the output includes deduplication information:</p> <pre><code>Warnings (2):\n  - Schema 'User' collision resolved with accept-left strategy\n  - semantic deduplication: consolidated 3 duplicate definition(s)\n</code></pre>"},{"location":"cli-reference/#exit-codes_4","title":"Exit Codes","text":"Code Meaning 0 Join successful 1 Join failed (collision with fail strategy, version mismatch, etc.)"},{"location":"cli-reference/#notes","title":"Notes","text":"<ul> <li>All input files must be the same major OAS version (2.0 or 3.x)</li> <li>The output uses the version and format (JSON/YAML) of the first input file</li> <li>Info section is taken from the first document</li> <li>Output file is written with restrictive permissions (0600) for security</li> <li>Warning is displayed if output file already exists (will be overwritten)</li> <li>Semantic deduplication identifies structurally identical schemas and consolidates them, reducing document size</li> <li>Operation-aware renaming traces schemas back to their originating operations for semantic naming</li> <li>Pre-overlays are applied to each input document before merging; post-overlays are applied to the final result</li> <li>For detailed template function documentation, see the joiner deep dive</li> </ul>"},{"location":"cli-reference/#diff","title":"diff","text":"<p>Compare two OpenAPI specification files or URLs and report differences.</p>"},{"location":"cli-reference/#synopsis_5","title":"Synopsis","text":"<pre><code>oastools diff [flags] &lt;source&gt; &lt;target&gt;\n</code></pre>"},{"location":"cli-reference/#flags_5","title":"Flags","text":"Flag Description <code>--breaking</code> Enable breaking change detection and categorization <code>--no-info</code> Exclude informational changes from output <code>-s, --source-map</code> Include line numbers in output (IDE-friendly format) <code>--format</code> Output format: text, json, or yaml (default: \"text\") <code>-h, --help</code> Display help for diff command"},{"location":"cli-reference/#examples_5","title":"Examples","text":"<pre><code># Simple diff (all changes)\noastools diff api-v1.yaml api-v2.yaml\n\n# Breaking change detection\noastools diff --breaking api-v1.yaml api-v2.yaml\n\n# Exclude informational changes\noastools diff --breaking --no-info api-v1.yaml api-v2.yaml\n\n# Compare from URLs\noastools diff \\\n  https://example.com/api/v1/openapi.yaml \\\n  https://example.com/api/v2/openapi.yaml\n\n# Compare local with remote\noastools diff local-api.yaml https://example.com/api/openapi.yaml\n\n# Output as JSON for programmatic processing\noastools diff --format json --breaking api-v1.yaml api-v2.yaml | jq '.HasBreakingChanges'\n\n# Output as YAML\noastools diff --format yaml api-v1.yaml api-v2.yaml\n</code></pre>"},{"location":"cli-reference/#output-format-simple-mode","title":"Output Format (Simple Mode)","text":"<p>The diff output includes document statistics showing paths, operations, and schemas for both source and target. The layout adapts automatically: side-by-side columns for short paths, single column for longer paths.</p> <pre><code>OpenAPI Specification Diff\n==========================\n\noastools version: v1.22.0\n\nSource: api-v1.yaml                      Target: api-v2.yaml\n  OAS Version: 3.0.3                       OAS Version: 3.0.3\n  Source Size: 12.5 KB                     Target Size: 14.2 KB\n  Paths: 5                                 Paths: 6\n  Operations: 12                           Operations: 15\n  Schemas: 8                               Schemas: 10\n\nTotal Time: 125ms\n\nChanges (8):\n  Path '/users/{id}' removed\n  Path '/posts' added\n  Operation GET '/users' modified\n  Parameter 'limit' added to GET '/users'\n  Schema 'User' modified\n  ...\n</code></pre>"},{"location":"cli-reference/#output-format-breaking-mode","title":"Output Format (Breaking Mode)","text":"<pre><code>OpenAPI Specification Diff\n==========================\n\noastools version: v1.22.0\n\nSource: api-v1.yaml                      Target: api-v2.yaml\n  OAS Version: 3.0.3                       OAS Version: 3.0.3\n  Source Size: 12.5 KB                     Target Size: 14.2 KB\n  Paths: 5                                 Paths: 6\n  Operations: 12                           Operations: 15\n  Schemas: 8                               Schemas: 10\n\nTotal Time: 125ms\n\nEndpoint Changes (2):\n  [CRITICAL] /users/{id}: Endpoint removed\n  [INFO] /posts: Endpoint added\n\nOperation Changes (1):\n  [WARNING] GET /users: Operation deprecated\n\nParameter Changes (2):\n  [ERROR] GET /users: Required parameter 'limit' added\n  [INFO] GET /users: Optional parameter 'filter' added\n\nSummary:\n  Total changes: 5\n  \u26a0\ufe0f  Breaking changes: 2\n  Warnings: 1\n  Info: 2\n</code></pre>"},{"location":"cli-reference/#severity-levels-breaking-mode","title":"Severity Levels (Breaking Mode)","text":"Severity Impact Examples CRITICAL API consumers WILL break Removed endpoints, operations ERROR API consumers MAY break Type changes, new required parameters WARNING Consumers SHOULD be aware Deprecated operations, new optional fields INFO Non-breaking changes Added endpoints, documentation updates"},{"location":"cli-reference/#exit-codes_5","title":"Exit Codes","text":"Code Meaning 0 No differences found (or no breaking changes in <code>--breaking</code> mode) 1 Differences found (or breaking changes in <code>--breaking</code> mode)"},{"location":"cli-reference/#notes_1","title":"Notes","text":"<ul> <li>Both specifications must be valid OpenAPI documents</li> <li>Cross-version comparison (2.0 vs 3.x) is supported with limitations</li> <li>Breaking change detection helps identify backward compatibility issues</li> <li>Use in CI/CD pipelines to prevent accidental breaking changes</li> </ul>"},{"location":"cli-reference/#generate","title":"generate","text":"<p>Generate idiomatic Go code (clients, servers, or types) from an OpenAPI specification.</p>"},{"location":"cli-reference/#synopsis_6","title":"Synopsis","text":"<pre><code>oastools generate [flags] &lt;file|url|-&gt;\n</code></pre>"},{"location":"cli-reference/#description_1","title":"Description","text":"<p>The generate command creates Go code from OpenAPI specifications. It can generate:</p> <ul> <li>HTTP clients with methods for each API operation</li> <li>Server interfaces defining the endpoints your implementation must satisfy</li> <li>Type definitions for all schemas in the specification</li> </ul> <p>Generated code follows Go idioms, includes proper error handling, and is suitable for production use.</p>"},{"location":"cli-reference/#flags_6","title":"Flags","text":"Flag Description <code>-o, --output string</code> Output directory for generated files (required) <code>-p, --package string</code> Go package name for generated code (default: \"api\") <code>--client</code> Generate HTTP client code <code>--server</code> Generate server interface code <code>--types</code> Generate type definitions from schemas (default: true) <code>--no-pointers</code> Don't use pointer types for optional fields <code>--no-validation</code> Don't include validation tags in generated code <code>-s, --source-map</code> Include line numbers in output (IDE-friendly format) <code>--strict</code> Fail on any generation issues (even warnings) <code>--no-warnings</code> Suppress warning and info messages <code>-h, --help</code> Display help for generate command <p>Security Generation Flags:</p> Flag Description <code>--no-security</code> Don't generate security helper functions (default: false, security is generated) <code>--oauth2-flows</code> Generate full OAuth2 token flow helpers <code>--credential-mgmt</code> Generate credential management interfaces <code>--security-enforce</code> Generate security enforcement middleware <code>--oidc-discovery</code> Generate OpenID Connect discovery client <code>--no-readme</code> Don't generate README.md documentation (default: false, README is generated) <p>Server Extension Flags (require <code>--server</code>):</p> Flag Description <code>--server-responses</code> Generate typed response writers and helpers (<code>server_responses.go</code>) <code>--server-binder</code> Generate request parameter binding (<code>server_binder.go</code>) <code>--server-middleware</code> Generate validation middleware using httpvalidator (<code>server_middleware.go</code>) <code>--server-router string</code> Generate HTTP router: <code>stdlib</code> (net/http) or <code>chi</code> (go-chi/chi) (<code>server_router.go</code>) <code>--server-stubs</code> Generate stub server for testing (<code>server_stubs.go</code>) <code>--server-embed-spec</code> Embed OpenAPI spec in generated code <code>--server-all</code> Enable all server extensions (responses, binder, middleware, router=stdlib, stubs) <p>File Splitting Flags (for large APIs):</p> Flag Description <code>--max-lines-per-file int</code> Maximum lines per generated file (default: 2000) <code>--max-types-per-file int</code> Maximum types per generated file (default: 200) <code>--max-ops-per-file int</code> Maximum operations per generated file (default: 100) <code>--no-split-by-tag</code> Disable splitting files by operation tag (splitting is enabled by default) <code>--no-split-by-path</code> Disable splitting files by path prefix (splitting is enabled by default)"},{"location":"cli-reference/#examples_6","title":"Examples","text":"<p>Generate HTTP client:</p> <pre><code>oastools generate --client -o ./client -p petstore openapi.yaml\n</code></pre> <p>Generate server interface:</p> <pre><code>oastools generate --server -o ./server -p petstore openapi.yaml\n</code></pre> <p>Generate both client and server:</p> <pre><code>oastools generate --client --server -o ./generated -p myapi openapi.yaml\n</code></pre> <p>Generate types only:</p> <pre><code>oastools generate --types -o ./models openapi.yaml\n</code></pre> <p>Generate from URL:</p> <pre><code>oastools generate --client -o ./client https://example.com/api/openapi.yaml\n</code></pre> <p>Generate client with OAuth2 flows:</p> <pre><code>oastools generate --client --oauth2-flows -o ./client -p api openapi.yaml\n</code></pre> <p>Generate with all security features:</p> <pre><code>oastools generate --client --oauth2-flows --credential-mgmt --oidc-discovery --readme \\\n  -o ./client -p api openapi.yaml\n</code></pre> <p>Generate server with security enforcement:</p> <pre><code>oastools generate --server --security-enforce -o ./server -p api openapi.yaml\n</code></pre> <p>Generate with file splitting for large APIs:</p> <pre><code>oastools generate --client --max-lines-per-file 1500 \\\n  -o ./client -p api large-api.yaml\n</code></pre> <p>Generate server with all extensions (router, validation, binding, stubs):</p> <pre><code>oastools generate --server --server-all -o ./server -p api openapi.yaml\n</code></pre> <p>Generate server with specific extensions:</p> <pre><code># Router with validation middleware\noastools generate --server --server-router=stdlib --server-middleware \\\n  -o ./server -p api openapi.yaml\n\n# Just typed responses and request binding\noastools generate --server --server-responses --server-binder \\\n  -o ./server -p api openapi.yaml\n</code></pre>"},{"location":"cli-reference/#output","title":"Output","text":"<p>The command generates the following files in the output directory:</p> <ul> <li><code>types.go</code> - Struct definitions generated from schema definitions</li> <li>Includes JSON marshaling/unmarshaling</li> <li>Validation tags if <code>--no-validation</code> is not set</li> <li> <p>Comments from schema descriptions</p> </li> <li> <p><code>client.go</code> (when <code>--client</code> is used)</p> </li> <li>HTTP client struct with configurable base URL</li> <li>Methods for each operation in the specification</li> <li>Automatic request/response marshaling</li> <li> <p>Comprehensive error handling</p> </li> <li> <p><code>server.go</code> (when <code>--server</code> is used)</p> </li> <li>Server interface defining all endpoints</li> <li>Request/response types for type safety</li> <li> <p>Framework-agnostic (implement the interface in your chosen framework)</p> </li> <li> <p><code>server_responses.go</code> (when <code>--server-responses</code> or <code>--server-all</code> is used)</p> </li> <li>Per-operation response types (e.g., <code>ListPetsResponse</code>)</li> <li>Status-specific methods (e.g., <code>Status200()</code>, <code>StatusDefault()</code>)</li> <li><code>WriteTo()</code> method for writing responses</li> <li> <p><code>WriteJSON()</code>, <code>WriteError()</code>, <code>WriteNoContent()</code> helpers</p> </li> <li> <p><code>server_binder.go</code> (when <code>--server-binder</code> or <code>--server-all</code> is used)</p> </li> <li><code>RequestBinder</code> type with validator integration</li> <li>Per-operation binding methods (e.g., <code>BindListPetsRequest()</code>)</li> <li>Type-safe parameter extraction from HTTP requests</li> <li> <p><code>BindingError</code> type with validation error details</p> </li> <li> <p><code>server_middleware.go</code> (when <code>--server-middleware</code> or <code>--server-all</code> is used)</p> </li> <li><code>ValidationMiddleware()</code> for request/response validation</li> <li><code>ValidationConfig</code> for customizing validation behavior</li> <li><code>DefaultValidationConfig()</code> with sensible defaults</li> <li> <p>Integration with <code>httpvalidator</code> package</p> </li> <li> <p><code>server_router.go</code> (when <code>--server-router</code> or <code>--server-all</code> is used)</p> </li> <li><code>ServerRouter</code> type implementing <code>http.Handler</code></li> <li><code>NewServerRouter()</code> factory with options</li> <li>Automatic path parameter extraction</li> <li> <p>Middleware support via <code>WithMiddleware()</code> option</p> </li> <li> <p><code>server_stubs.go</code> (when <code>--server-stubs</code> or <code>--server-all</code> is used)</p> </li> <li><code>StubServer</code> type implementing <code>ServerInterface</code></li> <li>Configurable per-operation function fields</li> <li><code>NewStubServerWithOptions()</code> for test setup</li> <li> <p><code>Reset()</code> to clear custom handlers</p> </li> <li> <p><code>security_helpers.go</code> (generated by default with <code>--client</code>, disable with <code>--no-security</code>)</p> </li> <li>ClientOption functions for each security scheme</li> <li>API key helpers (header, query, cookie)</li> <li>HTTP basic/bearer authentication helpers</li> <li> <p>OAuth2 token helpers</p> </li> <li> <p><code>{scheme}_oauth2.go</code> (when <code>--oauth2-flows</code> is used)</p> </li> <li>OAuth2Config and OAuth2Token types</li> <li>OAuth2Client with flow-specific methods</li> <li>Authorization code, client credentials, password flows</li> <li>PKCE support (RFC 7636) for secure authorization code flows</li> <li> <p>Token refresh and auto-refresh support</p> </li> <li> <p><code>credentials.go</code> (when <code>--credential-mgmt</code> is used)</p> </li> <li>CredentialProvider interface</li> <li>MemoryCredentialProvider for testing</li> <li>EnvCredentialProvider for environment variables</li> <li> <p>CredentialChain for fallback providers</p> </li> <li> <p><code>security_enforce.go</code> (when <code>--security-enforce</code> is used)</p> </li> <li>SecurityRequirement struct</li> <li>OperationSecurityRequirements map</li> <li>SecurityValidator for request validation</li> <li> <p>RequireSecurityMiddleware</p> </li> <li> <p><code>oidc_discovery.go</code> (when <code>--oidc-discovery</code> is used)</p> </li> <li>OIDCConfiguration struct</li> <li>OIDCDiscoveryClient for .well-known discovery</li> <li> <p>NewOAuth2ClientFromOIDC helper</p> </li> <li> <p><code>README.md</code> (generated by default, disable with <code>--no-readme</code>)</p> </li> <li>API overview and version info</li> <li>Generated file descriptions</li> <li>Security configuration examples</li> <li>Regeneration command</li> </ul>"},{"location":"cli-reference/#type-mapping","title":"Type Mapping","text":"<p>OpenAPI types are mapped to Go types as follows:</p> OpenAPI Type Go Type Notes <code>string</code> <code>string</code> Respects format hints (uuid, email, date-time, etc.) <code>integer</code> (format: int32) <code>int32</code> <code>integer</code> <code>int64</code> Default for integers <code>number</code> (format: float) <code>float32</code> <code>number</code> <code>float64</code> Default for numbers <code>boolean</code> <code>bool</code> <code>array</code> <code>[]T</code> T depends on item type <code>object</code> <code>struct</code> Generated with fields from properties <code>null</code> (OAS 3.1+) <code>*T</code> Using pointers for optional fields <p>Optional fields (not in required array) use pointer types when <code>--no-pointers</code> is not set.</p>"},{"location":"cli-reference/#notes_2","title":"Notes","text":"<ul> <li>Format Preservation: Input files determine output format (JSON \u2192 JSON, YAML \u2192 YAML)</li> <li>At least one generation mode required: If none of <code>--client</code>, <code>--server</code>, or <code>--types</code> are specified, types generation is enabled by default</li> <li>Package naming: Go package names must be valid identifiers (lowercase, no hyphens)</li> <li>Schema support: Generates code for all OAS versions (2.0, 3.0.x, 3.1.x, 3.2.0)</li> <li>Validation tags: Generated structs include <code>validate</code> struct tags for integration with validation libraries</li> </ul>"},{"location":"cli-reference/#exit-codes_6","title":"Exit Codes","text":"Code Meaning 0 Code generation successful 1 Output directory is required 2 At least one generation mode must be enabled 3 Generation failed (file read, parsing, or code generation error)"},{"location":"cli-reference/#overlay","title":"overlay","text":"<p>Apply OpenAPI Overlay Specification transformations to OpenAPI documents.</p>"},{"location":"cli-reference/#synopsis_7","title":"Synopsis","text":"<pre><code>oastools overlay &lt;subcommand&gt; [flags]\n</code></pre>"},{"location":"cli-reference/#subcommands","title":"Subcommands","text":"Subcommand Description <code>apply</code> Apply an overlay to an OpenAPI specification <code>validate</code> Validate an overlay document"},{"location":"cli-reference/#overlay-apply","title":"overlay apply","text":"<p>Apply an overlay transformation to an OpenAPI specification.</p> <pre><code>oastools overlay apply [flags] &lt;overlay-file&gt;\n</code></pre>"},{"location":"cli-reference/#flags_7","title":"Flags","text":"Flag Short Description <code>--spec</code> <code>-s</code> Path to the OpenAPI specification file (required) <code>--output</code> <code>-o</code> Output file path (default: stdout) <code>--strict</code> Fail if any target matches nothing <code>--dry-run</code> <code>-n</code> Preview changes without applying <code>--quiet</code> <code>-q</code> Suppress diagnostic output <code>-h, --help</code> Display help"},{"location":"cli-reference/#examples_7","title":"Examples","text":"<pre><code># Apply overlay and write to file\noastools overlay apply --spec openapi.yaml -o result.yaml changes.yaml\n\n# Apply overlay to stdout\noastools overlay apply -s openapi.yaml changes.yaml\n\n# Preview changes without applying\noastools overlay apply --dry-run -s openapi.yaml changes.yaml\n\n# Strict mode (fail if targets don't match)\noastools overlay apply --strict -s openapi.yaml changes.yaml\n\n# From stdin\ncat openapi.yaml | oastools overlay apply -s - changes.yaml\n\n# Quiet mode for pipelines\noastools overlay apply -q -s openapi.yaml changes.yaml &gt; result.yaml\n</code></pre>"},{"location":"cli-reference/#output-format_5","title":"Output Format","text":"<pre><code>OpenAPI Overlay Application\n============================\n\noastools version: v1.46.2\nSpecification: openapi.yaml\nOverlay: changes.yaml\nTotal Time: 1.2ms\n\nActions applied: 3\nActions skipped: 0\n\nChanges:\n  [0] update: $.info (1 match(es))\n  [1] update: $.paths.*.get (5 match(es))\n  [2] remove: $.paths[?@.x-internal==true] (2 match(es))\n\n\u2713 Overlay applied successfully\n</code></pre>"},{"location":"cli-reference/#dry-run-output","title":"Dry-Run Output","text":"<p>When using <code>--dry-run</code> / <code>-n</code>, no changes are made to the document. The output shows what would happen:</p> <pre><code>OpenAPI Overlay Dry Run\n=======================\n\noastools version: v1.46.2\nSpecification: openapi.yaml\nOverlay: changes.yaml\nTotal Time: 1.1ms\n\nWould apply: 3 action(s)\nWould skip:  0 action(s)\n\nProposed Changes:\n  [0] update: Update API info (1 match(es))\n       \u2192 $.info\n  [1] update: Add headers to all GET operations (5 match(es))\n       \u2192 $.paths./pets.get\n       \u2192 $.paths./users.get\n       ...\n  [2] remove: Remove internal endpoints (2 match(es))\n       \u2192 $.paths./internal/health\n       \u2192 $.paths./internal/metrics\n\n\u2139\ufe0f  No changes were made (dry-run mode)\n</code></pre>"},{"location":"cli-reference/#overlay-validate","title":"overlay validate","text":"<p>Validate an overlay document against the OpenAPI Overlay Specification.</p> <pre><code>oastools overlay validate [flags] &lt;overlay-file&gt;\n</code></pre>"},{"location":"cli-reference/#flags_8","title":"Flags","text":"Flag Short Description <code>--quiet</code> <code>-q</code> Suppress diagnostic output <code>-h, --help</code> Display help"},{"location":"cli-reference/#examples_8","title":"Examples","text":"<pre><code># Validate an overlay file\noastools overlay validate overlay.yaml\n\n# Quiet mode\noastools overlay validate -q overlay.yaml\n</code></pre>"},{"location":"cli-reference/#output-format_6","title":"Output Format","text":"<pre><code>OpenAPI Overlay Validator\n=========================\n\noastools version: v1.24.0\nOverlay: overlay.yaml\nTitle: Update API Metadata\nVersion: 1.0.0\nActions: 5\n\n\u2713 Overlay is valid\n</code></pre>"},{"location":"cli-reference/#validation-errors","title":"Validation Errors","text":"<pre><code>OpenAPI Overlay Validator\n=========================\n\noastools version: v1.24.0\nOverlay: invalid-overlay.yaml\n\nErrors (2):\n  \u2717 info.version: version is required\n  \u2717 actions: at least one action is required\n\n\u2717 Validation failed: 2 error(s)\n</code></pre>"},{"location":"cli-reference/#exit-codes_7","title":"Exit Codes","text":"Code Meaning 0 Success (overlay applied or validated) 1 Failure (errors in overlay or application)"},{"location":"cli-reference/#jsonpath-support","title":"JSONPath Support","text":"<p>The overlay package supports these JSONPath expressions:</p> Expression Description Example <code>$.field</code> Root field access <code>$.info</code> <code>$.a.b.c</code> Nested field access <code>$.info.title</code> <code>$['field']</code> Bracket notation <code>$.paths['/users']</code> <code>$.*</code> Wildcard (all children) <code>$.paths.*</code> <code>$[0]</code> Array index <code>$.servers[0]</code> <code>$..field</code> Recursive descent <code>$..description</code> <code>$[?@.x==y]</code> Filter expression <code>$.paths[?@.x-internal==true]</code> <code>$[?@ &amp;&amp; @]</code> Compound AND filter <code>$.paths[?@.deprecated==true &amp;&amp; @.x-internal==true]</code> <code>$[?@ \\|\\| @]</code> Compound OR filter <code>$.paths[?@.deprecated==true \\|\\| @.x-obsolete==true]</code>"},{"location":"cli-reference/#walk","title":"walk","text":"<p>Query and inspect elements within an OpenAPI specification. The walk command provides 6 subcommands for exploring different aspects of your API spec.</p>"},{"location":"cli-reference/#synopsis_8","title":"Synopsis","text":"<pre><code>oastools walk &lt;subcommand&gt; [flags] &lt;spec-file&gt;\n</code></pre>"},{"location":"cli-reference/#subcommands_1","title":"Subcommands","text":"Subcommand Description <code>operations</code> List or inspect operations with method, path, tag filters <code>schemas</code> List or inspect schemas with name, type, component/inline filters <code>parameters</code> List or inspect parameters with name, location, path filters <code>responses</code> List or inspect responses with status code, path, method filters <code>security</code> List or inspect security schemes with name, type filters <code>paths</code> List or inspect path items with path pattern filters"},{"location":"cli-reference/#common-flags","title":"Common Flags","text":"Flag Description <code>--format &lt;text\\|json\\|yaml&gt;</code> Output format (default: text) <code>-q</code>, <code>--quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full node instead of summary table <code>--extension &lt;expr&gt;</code> Filter by extension (e.g., <code>x-internal=true</code>) <code>--resolve-refs</code> Resolve <code>$ref</code> pointers in detail output"},{"location":"cli-reference/#examples_9","title":"Examples","text":"<pre><code># List all operations\noastools walk operations api.yaml\n\n# Filter operations by method and path\noastools walk operations --method get --path '/pets*' api.yaml\n\n# Show full schema detail in JSON\noastools walk schemas --name Pet --detail --format json api.yaml\n\n# List only component schemas\noastools walk schemas --component api.yaml\n\n# Filter responses by status code wildcard\noastools walk responses --status '4xx' api.yaml\n\n# Pipe response details to jq\noastools walk responses --status '2xx' -q --detail --format json api.yaml | jq\n\n# List security schemes\noastools walk security api.yaml\n\n# Filter by extension with value matching\noastools walk operations --extension 'x-internal=true' api.yaml\n\n# Extension filter DSL: AND (+), OR (,), negation (!)\noastools walk operations --extension 'x-audited,!x-deprecated' api.yaml\n</code></pre>"},{"location":"cli-reference/#extension-filter-dsl","title":"Extension Filter DSL","text":"<p>The <code>--extension</code> flag supports a mini DSL for filtering by vendor extensions:</p> Syntax Meaning Example <code>x-foo</code> Has extension <code>--extension x-internal</code> <code>!x-foo</code> Does not have extension <code>--extension '!x-deprecated'</code> <code>x-foo=val</code> Extension equals value <code>--extension x-internal=true</code> <code>x-foo!=val</code> Extension not equal to value <code>--extension 'x-status!=draft'</code> <code>a,b</code> OR (either matches) <code>--extension 'x-public,x-external'</code> <code>a+b</code> AND (both match) <code>--extension 'x-audited+x-public'</code>"},{"location":"cli-reference/#walk-operations","title":"walk operations","text":"<p>List or inspect operations with method, path, tag filters.</p>"},{"location":"cli-reference/#flags_9","title":"Flags","text":"Flag Description <code>--method</code> Filter by HTTP method (e.g., get, post) <code>--path</code> Filter by path pattern (supports glob with *) <code>--tag</code> Filter by tag <code>--deprecated</code> Only show deprecated operations <code>--operationId</code> Select by operationId <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full operation instead of summary table <code>--extension</code> Filter by extension (e.g., x-internal=true) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#walk-schemas","title":"walk schemas","text":"<p>List or inspect schemas with name, type, component/inline filters.</p>"},{"location":"cli-reference/#flags_10","title":"Flags","text":"Flag Description <code>--name</code> Select by schema name <code>--component</code> Only show component schemas <code>--inline</code> Only show inline schemas <code>--type</code> Filter by schema type (object, array, string, etc.) <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full node instead of summary table <code>--extension</code> Filter by extension (e.g., x-internal=true) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#walk-parameters","title":"walk parameters","text":"<p>List or inspect parameters with name, location, path filters.</p>"},{"location":"cli-reference/#flags_11","title":"Flags","text":"Flag Description <code>--in</code> Filter by location (path, query, header, cookie) <code>--name</code> Filter by parameter name <code>--path</code> Filter by owning path pattern (supports glob with *) <code>--method</code> Filter by owning operation method <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full parameter instead of summary table <code>--extension</code> Filter by extension (e.g., x-internal=true) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#walk-responses","title":"walk responses","text":"<p>List or inspect responses with status code, path, method filters.</p>"},{"location":"cli-reference/#flags_12","title":"Flags","text":"Flag Description <code>--status</code> Filter by status code (200, 4xx, etc.) <code>--path</code> Filter by owning path pattern (supports glob) <code>--method</code> Filter by owning operation method <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full node instead of summary table <code>--extension</code> Filter by extension (e.g., x-internal=true) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#walk-security","title":"walk security","text":"<p>List or inspect security schemes with name, type filters.</p>"},{"location":"cli-reference/#flags_13","title":"Flags","text":"Flag Description <code>--name</code> Filter by security scheme name <code>--type</code> Filter by type (apiKey, http, oauth2, openIdConnect) <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full security scheme instead of summary table <code>--extension</code> Filter by extension (e.g., x-scope=internal) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#walk-paths","title":"walk paths","text":"<p>List or inspect path items with path pattern filters.</p>"},{"location":"cli-reference/#flags_14","title":"Flags","text":"Flag Description <code>--path</code> Filter by path pattern (supports glob with *) <code>--format</code> Output format: text, json, yaml (default: \"text\") <code>-q, --quiet</code> Suppress headers and decoration for piping <code>--detail</code> Show full path item instead of summary table <code>--extension</code> Filter by extension (e.g., x-internal=true) <code>--resolve-refs</code> Resolve $ref pointers in detail output"},{"location":"cli-reference/#mcp","title":"mcp","text":"<p>Start a Model Context Protocol (MCP) server over stdio, exposing all oastools capabilities as tools for AI-assisted development environments.</p>"},{"location":"cli-reference/#synopsis_9","title":"Synopsis","text":"<pre><code>oastools mcp\n</code></pre>"},{"location":"cli-reference/#description_2","title":"Description","text":"<p>The MCP command launches a server that communicates over stdio using the Model Context Protocol. It exposes 17 tools (9 core tools + 8 walk tools) that AI agents can invoke to parse, validate, fix, convert, join, diff, overlay, generate, and query OpenAPI specifications.</p> <p>The server is designed for use with MCP-compatible clients such as Claude Code, Cursor, VS Code, and other AI development environments.</p>"},{"location":"cli-reference/#configuration","title":"Configuration","text":"<p>The MCP server is configured via environment variables. MCP clients typically set these via their <code>env</code> field in server configuration.</p> Variable Default Description <code>OASTOOLS_CACHE_ENABLED</code> <code>true</code> Enable/disable spec caching <code>OASTOOLS_CACHE_MAX_SIZE</code> <code>10</code> Maximum cached specifications <code>OASTOOLS_CACHE_FILE_TTL</code> <code>15m</code> File spec TTL <code>OASTOOLS_CACHE_URL_TTL</code> <code>5m</code> URL-fetched spec TTL <code>OASTOOLS_WALK_LIMIT</code> <code>100</code> Default walk result limit <code>OASTOOLS_WALK_DETAIL_LIMIT</code> <code>25</code> Detail mode result limit <code>OASTOOLS_VALIDATE_STRICT</code> <code>false</code> Enable strict validation by default <code>OASTOOLS_ALLOW_PRIVATE_IPS</code> <code>false</code> Allow resolution of private/loopback IPs"},{"location":"cli-reference/#example","title":"Example","text":"<p>Claude Code <code>mcp_servers</code> configuration in <code>~/.claude/settings.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"oastools\": {\n      \"command\": \"oastools\",\n      \"args\": [\"mcp\"],\n      \"env\": {\n        \"OASTOOLS_CACHE_FILE_TTL\": \"30m\"\n      }\n    }\n  }\n}\n</code></pre> <p>For complete tool reference and setup guides, see:</p> <ul> <li>MCP Server Guide \u2014 Full tool reference and configuration</li> <li>Claude Code Plugin \u2014 One-command setup for Claude Code</li> </ul>"},{"location":"cli-reference/#version","title":"version","text":"<p>Display oastools version and build information.</p>"},{"location":"cli-reference/#synopsis_10","title":"Synopsis","text":"<pre><code>oastools version\noastools -v\noastools --version\n</code></pre>"},{"location":"cli-reference/#output_1","title":"Output","text":"<pre><code>oastools v1.17.1\ncommit: 540e27a\nbuilt: 2025-12-06T20:05:42Z\ngo: go1.24.0\n</code></pre> <p>The version command displays:</p> <ul> <li>version: The release version</li> <li>commit: The git commit hash of the build</li> <li>built: The build timestamp (RFC3339 format)</li> <li>go: The Go version used to compile the binary</li> </ul>"},{"location":"cli-reference/#help","title":"help","text":"<p>Display help information.</p>"},{"location":"cli-reference/#synopsis_11","title":"Synopsis","text":"<pre><code>oastools help\noastools -h\noastools --help\noastools &lt;command&gt; --help\n</code></pre>"},{"location":"cli-reference/#output_2","title":"Output","text":"<pre><code>oastools - OpenAPI Specification Tools\n\nUsage:\n  oastools &lt;command&gt; [options]\n\nCommands:\n  validate    Validate an OpenAPI specification file or URL\n  fix         Automatically fix common validation errors\n  convert     Convert between OpenAPI specification versions\n  diff        Compare two OpenAPI specifications and detect changes\n  generate    Generate Go client/server code from an OpenAPI specification\n  join        Join multiple OpenAPI specification files\n  overlay     Apply OpenAPI Overlay transformations\n  parse       Parse and display an OpenAPI specification file or URL\n  version     Show version information\n  help        Show this help message\n\nExamples:\n  oastools validate openapi.yaml\n  oastools validate https://example.com/api/openapi.yaml\n  oastools fix --infer api.yaml -o fixed.yaml\n  oastools convert -t 3.0.3 swagger.yaml -o openapi.yaml\n  oastools diff --breaking api-v1.yaml api-v2.yaml\n  oastools generate --client -o ./client openapi.yaml\n  oastools join -o merged.yaml base.yaml extensions.yaml\n  oastools overlay apply -s openapi.yaml -o result.yaml changes.yaml\n  oastools parse https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/examples/v3.0/petstore.yaml\n\nRun 'oastools &lt;command&gt; --help' for more information on a command.\n</code></pre>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"<p>The <code>mcp</code> subcommand reads <code>OASTOOLS_*</code> environment variables for server configuration (cache TTLs, walk limits, join strategies, etc.). See the MCP Server Guide for the full list of supported variables.</p>"},{"location":"cli-reference/#file-format-support","title":"File Format Support","text":"Format Extensions Auto-Detection YAML <code>.yaml</code>, <code>.yml</code> Yes JSON <code>.json</code> Yes <p>The output format matches the input format (JSON input \u2192 JSON output, YAML input \u2192 YAML output).</p>"},{"location":"cli-reference/#url-support","title":"URL Support","text":"<p>The following commands support loading specifications from URLs:</p> <ul> <li><code>validate</code></li> <li><code>fix</code></li> <li><code>parse</code></li> <li><code>convert</code></li> <li><code>diff</code></li> <li><code>generate</code></li> </ul> <p>Supported URL schemes:</p> <ul> <li><code>http://</code></li> <li><code>https://</code></li> </ul> <p>Note: When loading from URLs, relative <code>$ref</code> paths resolve against the current working directory (where the CLI is executed), not relative to the remote URL location.</p>"},{"location":"cli-reference/#stdin-and-pipeline-support","title":"Stdin and Pipeline Support","text":"<p>The following commands support reading from stdin using <code>-</code> as the file path:</p> <ul> <li><code>validate</code></li> <li><code>fix</code></li> <li><code>parse</code></li> <li><code>convert</code></li> <li><code>generate</code></li> </ul>"},{"location":"cli-reference/#pipeline-usage","title":"Pipeline Usage","text":"<pre><code># Validate from stdin\ncat openapi.yaml | oastools validate -\n\n# Parse from stdin with quiet mode\ncat openapi.yaml | oastools parse -q -\n\n# Convert from stdin to stdout\ncat swagger.yaml | oastools convert -q -t 3.0.3 - &gt; openapi.yaml\n\n# Chain with curl\ncurl -s https://example.com/openapi.yaml | oastools validate -q -\n\n# Chain multiple operations\ncat swagger.yaml | oastools convert -q -t 3.0.3 - | oastools validate -q -\n\n# Generate client from stdin\ncat openapi.yaml | oastools generate --client -o ./client -\n</code></pre>"},{"location":"cli-reference/#quiet-mode","title":"Quiet Mode","text":"<p>Use <code>-q</code> or <code>--quiet</code> to suppress diagnostic messages for clean pipeline output:</p> Command Quiet Mode Behavior <code>validate</code> Only outputs validation result (no banners/stats) <code>fix</code> Only outputs the fixed document (no banners/stats) <code>parse</code> Only outputs the document JSON (no banners/stats) <code>convert</code> Only outputs the converted document (no banners/issues)"},{"location":"cli-reference/#structured-output","title":"Structured Output","text":"<p>Use <code>--format json</code> or <code>--format yaml</code> for machine-readable output:</p> <pre><code># Get validation result as JSON\noastools validate --format json openapi.yaml | jq '.valid'\n\n# Get diff result as JSON for CI/CD\noastools diff --format json --breaking v1.yaml v2.yaml | jq '.HasBreakingChanges'\n</code></pre>"},{"location":"cli-reference/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>External References: By default, only local file <code>$ref</code> values are resolved. HTTP(S) references require explicit opt-in via <code>--resolve-http-refs</code> (which also requires <code>--resolve-refs</code>). Use <code>--insecure</code> only in trusted environments to bypass TLS certificate verification.</p> </li> <li> <p>Path Traversal: External file references are restricted to the base directory and subdirectories to prevent path traversal attacks.</p> </li> <li> <p>Output Permissions: The <code>join</code> command writes output files with restrictive permissions (0600).</p> </li> <li> <p>Credential Handling: URLs may include basic authentication, but this is not recommended. Use environment-specific configuration instead.</p> </li> </ol>"},{"location":"corpus-analysis/","title":"Corpus Analysis: 10 Real-World OpenAPI Specs","text":"<p>Generated 2026-02-15 using only the oastools MCP server tools (<code>parse</code>, <code>walk_operations</code>, <code>walk_schemas</code>, <code>walk_parameters</code>, <code>walk_responses</code>, <code>walk_security</code>, <code>walk_headers</code>, <code>walk_refs</code>) with the <code>group_by</code> aggregation feature from #321.</p> <p>The corpus lives in <code>testdata/corpus/</code> and contains specs from major API providers spanning Swagger 2.0 through OAS 3.1.</p>"},{"location":"corpus-analysis/#parse-summary","title":"Parse Summary","text":"Spec OAS Format Paths Operations Schemas Tags Petstore 2.0 JSON 14 20 6 3 Google Maps 3.0.3 JSON 17 17 75 9 NWS Weather 3.0.3 JSON 60 60 103 0 Asana 3.0.0 YAML 158 217 244 42 Discord 3.1.0 JSON 137 227 492 0 Plaid 3.0.0 YAML 334 324 2,179 1 DigitalOcean 3.0.0 YAML 356 544 658 48 Stripe 3.0.0 JSON 415 588 1,321 0 GitHub 3.0.3 JSON 720 1,078 904 46 MS Graph 3.0.4 YAML 10,405 16,098 4,294 457 TOTALS 12,616 19,173 10,276 <p>The corpus spans 3 orders of magnitude in every dimension (20 to 16,098 operations), covers all major OAS versions (2.0, 3.0.0, 3.0.3, 3.0.4, 3.1.0), and includes both JSON (6 specs) and YAML (4 specs).</p>"},{"location":"corpus-analysis/#operations-by-method","title":"Operations by Method","text":"<p>Using <code>walk_operations</code> with <code>group_by=method</code>:</p> Spec GET POST PUT PATCH DELETE Petstore 8 7 2 - 3 Google Maps 16 1 - - - NWS Weather 60 - - - - Asana 101 75 21 - 20 Discord 97 42 20 31 37 Plaid 2 322 - - - DigitalOcean 283 110 55 12 84 Stripe 263 293 - - 32 GitHub 568 171 112 61 166 MS Graph 8,473 3,361 179 1,976 2,109"},{"location":"corpus-analysis/#patterns","title":"Patterns","text":"<ul> <li>NWS is read-only: all 60 operations are GET. A pure data-retrieval API.</li> <li>Plaid is POST-only (99.4%): the RPC-over-HTTP pattern where every endpoint is a command, not a resource operation.</li> <li>Stripe leans POST &gt; GET (293 vs 263): payment domain is write-heavy. Zero PUT/PATCH -- all mutations use POST.</li> <li>MS Graph favors PATCH over PUT (1,976 vs 179): OData convention for partial updates.</li> <li>GitHub uses all 5 methods with the widest distribution, reflecting classic REST design.</li> </ul>"},{"location":"corpus-analysis/#component-schema-types","title":"Component Schema Types","text":"<p>Using <code>walk_schemas</code> with <code>group_by=type</code> and <code>component=true</code>:</p> Spec object string array integer boolean number (none) nullable unions Petstore 6 14 2 9 1 - 1 - Google Maps 64 161 63 15 25 44 74 - NWS 78 228 60 12 4 6 225 - Asana 262 590 85 30 57 16 416 - Discord 425 451 165 330 145 10 1,634 771 Plaid 1,674 2,978 567 317 211 384 3,624 - DigitalOcean 786 1,511 391 423 161 46 1,169 - Stripe 1,439 3,277 296 685 394 23 2,746 - GitHub 2,508 20,123 661 2,810 3,157 64 2,636 - MS Graph 6,660 7,747 2,835 4 1,394 1,018 10,007 -"},{"location":"corpus-analysis/#patterns_1","title":"Patterns","text":"<ul> <li>Discord is the only OAS 3.1 spec and uniquely shows nullable union types (<code>string, null</code>: 312, <code>integer, null</code>: 158, etc. -- 771 total). This is the 3.1 way of expressing nullability via JSON Schema's <code>type: [string, null]</code> instead of 3.0's <code>nullable: true</code>.</li> <li>GitHub has a massive string bias (20,123 string schemas, 63% of all component schemas). Many enums and scalar properties are expanded as individual schemas.</li> <li>Typeless schemas <code>\"\"</code> are pervasive: every OAS 3.0 spec has large counts of schemas without an explicit <code>type</code>. These are typically <code>allOf</code>/<code>anyOf</code>/<code>oneOf</code> compositions or <code>$ref</code> wrappers.</li> <li>MS Graph uses almost zero integers (only 4!) but 1,018 <code>number</code> types. Their OData convention prefers <code>number</code> even for ID/count fields.</li> </ul>"},{"location":"corpus-analysis/#response-status-codes","title":"Response Status Codes","text":"<p>Using <code>walk_responses</code> with <code>group_by=status_code</code>:</p> Spec 2xx 3xx 4xx 5xx default other Petstore 9 - 20 - 4 3 Google Maps 17 - 3 - - - NWS 59 3 - - 60 7 Asana 217 - 886 218 - 34 Discord 237 - 454 - - 2 Plaid 325 - 1 - 279 - DigitalOcean 544 - 993 1,088 541 277 Stripe 588 - - - 588 - GitHub 1,081 33 1,269 141 - 410 MS Graph 16,098 - 16,098 16,098 - 1,157"},{"location":"corpus-analysis/#error-handling-styles","title":"Error-handling styles","text":"<ul> <li>Stripe: <code>default</code> catch-all -- every operation has exactly <code>200</code> + <code>default</code>. Simplest pattern.</li> <li>MS Graph: wildcard ranges -- uses <code>2XX</code>, <code>4XX</code>, <code>5XX</code> on every operation. Most systematic but least specific.</li> <li>Discord: mixed wildcards -- <code>4XX</code> wildcard alongside exact <code>429</code>. Combines range and exact codes.</li> <li>GitHub: most granular -- 25 distinct status codes including rare ones like <code>405</code>, <code>406</code>, <code>413</code>. Best client error-handling guidance.</li> <li>Asana: exhaustive error codes -- every operation specifies <code>400</code>, <code>401</code>, <code>403</code>, <code>404</code>, <code>500</code> individually.</li> </ul>"},{"location":"corpus-analysis/#parameters-by-location","title":"Parameters by Location","text":"<p>Using <code>walk_parameters</code> with <code>group_by=location</code>:</p> Spec path query header body/formData (unresolved $ref) Petstore 9 4 1 11 - Google Maps - 77 - - 114 NWS 44 73 2 - 92 Asana 39 299 - - 414 Discord 170 91 - - - Plaid 1 - 2 - 5 DigitalOcean 142 103 4 - 719 Stripe 436 951 - - - GitHub 169 302 - - 2,832 MS Graph 21,825 13,471 2,611 - 15,304"},{"location":"corpus-analysis/#patterns_2","title":"Patterns","text":"<ul> <li>Empty location <code>\"\"</code> = unresolved <code>$ref</code>: parameters that reference <code>#/components/parameters/...</code> show empty location until <code>resolve_refs=true</code> is used. GitHub has 2,832 of these.</li> <li>Petstore is the only spec with <code>body</code> and <code>formData</code>: these are Swagger 2.0 parameter locations, replaced by <code>requestBody</code> in OAS 3.0.</li> <li>MS Graph has 2,611 header parameters: OData-standard headers like <code>ConsistencyLevel</code>, <code>$top</code>, <code>$filter</code>.</li> <li>Stripe is query-heavy (951 query params): filtering and pagination options on list endpoints.</li> </ul>"},{"location":"corpus-analysis/#security-schemes","title":"Security Schemes","text":"<p>Using <code>walk_security</code>:</p> Spec Scheme(s) Type(s) Petstore api_key, petstore_auth apiKey (header), OAuth2 Google Maps ApiKeyAuth apiKey (query) NWS apiKeyAuth, userAgent apiKey (header) x2 Asana oauth2, personalAccessToken OAuth2, HTTP Bearer Discord BotToken, OAuth2 apiKey (header), OAuth2 Plaid clientId, plaidVersion, secret apiKey (header) x3 DigitalOcean bearer_auth HTTP Bearer Stripe basicAuth, bearerAuth HTTP Basic, HTTP Bearer GitHub (none defined) - MS Graph (none defined) -"},{"location":"corpus-analysis/#patterns_3","title":"Patterns","text":"<ul> <li>GitHub and MS Graph define zero security schemes despite being authenticated APIs. Auth is handled outside the spec.</li> <li>Google Maps puts the API key in the query string -- the only spec to do this.</li> <li>NWS uses User-Agent as a security scheme -- creative abuse tracking via a required header.</li> <li>Plaid requires 3 simultaneous header keys (clientId + secret + plaidVersion) -- multi-key auth.</li> </ul>"},{"location":"corpus-analysis/#response-headers","title":"Response Headers","text":"<p>Using <code>walk_headers</code> with <code>group_by=name</code>:</p> Spec Total Headers Top Header Occurrences Discord 1,200 X-RateLimit-Bucket/Limit/Remaining/Reset/Reset-After 240 each DigitalOcean 1,069 ratelimit-limit/remaining/reset 354 each GitHub 244 Link 193 NWS 137 X-Correlation-Id / X-Request-Id / X-Server-Id 44 each Stripe 0 - - Asana 0 - - Plaid 0 - -"},{"location":"corpus-analysis/#patterns_4","title":"Patterns","text":"<ul> <li>Discord and DigitalOcean document rate-limiting headers on every response: Discord has 5 rate-limit headers per response (1,200 total across 240 operations).</li> <li>GitHub's <code>Link</code> header appears 193 times: the HATEOAS pagination mechanism (<code>rel=\"next\"</code>, <code>rel=\"last\"</code>).</li> <li>Stripe documents zero response headers despite having rate limits in practice.</li> <li>GitHub has a casing inconsistency: both <code>Link</code> and <code>link</code>, <code>Location</code> and <code>location</code> appear as separate header names. HTTP headers are case-insensitive, so these should be merged.</li> </ul>"},{"location":"corpus-analysis/#top-ref-hotspots","title":"Top $ref Hotspots","text":"<p>Using <code>walk_refs</code> (top 10 per spec, ranked by reference count):</p> Spec #1 Most-Referenced Count Type Stripe <code>schemas/error</code> 588 schema Discord <code>schemas/SnowflakeType</code> 554 schema DigitalOcean <code>responses/server_error</code> 544 response GitHub <code>responses/not_found</code> 487 response Plaid <code>schemas/APIClientID</code> 324 schema Asana <code>responses/BadRequest</code> 216 response NWS <code>responses/Error</code> 60 response Google Maps <code>schemas/LatLngLiteral</code> 13 schema"},{"location":"corpus-analysis/#patterns_5","title":"Patterns","text":"<ul> <li>Error responses dominate: the most-referenced component in 4/8 specs is an error response. This validates extracting errors into reusable <code>$ref</code> components.</li> <li>Discord's SnowflakeType is referenced 554 times: their Snowflake ID system permeates every schema.</li> <li>GitHub's <code>owner</code> and <code>repo</code> path parameters are referenced 480 and 479 times -- nearly every endpoint is scoped to a repository.</li> <li>Plaid's <code>APIClientID</code> (324 refs) reflects their triple-key auth pattern embedded in every request schema.</li> </ul>"},{"location":"corpus-analysis/#github-full-top-10","title":"GitHub -- Full Top 10","text":"Ref Count Type responses/not_found 487 response parameters/owner 480 parameter parameters/repo 479 parameter schemas/simple-user 399 schema parameters/org 330 parameter responses/forbidden 318 response schemas/organization-simple-webhooks 263 schema schemas/simple-installation 252 schema parameters/per-page 241 parameter schemas/enterprise-webhooks 234 schema"},{"location":"corpus-analysis/#discord-full-top-10","title":"Discord -- Full Top 10","text":"Ref Count Type schemas/SnowflakeType 554 schema headers/X-RateLimit-Bucket 239 header headers/X-RateLimit-Limit 239 header headers/X-RateLimit-Remaining 239 header headers/X-RateLimit-Reset 239 header headers/X-RateLimit-Reset-After 239 header responses/ClientErrorResponse 227 response responses/ClientRatelimitedResponse 227 response schemas/UserResponse 49 schema schemas/MessageComponentTypes 39 schema"},{"location":"corpus-analysis/#tag-distribution","title":"Tag Distribution","text":"<p>Using <code>walk_operations</code> with <code>group_by=tag</code> (top 15):</p>"},{"location":"corpus-analysis/#github-46-tags","title":"GitHub (46 tags)","text":"Tag Operations repos 204 actions 184 orgs 104 issues 49 codespaces 48 users 47 apps 37 activity 32 teams 32 packages 27 pulls 27 projects 26 dependabot 22 migrations 22 code-scanning 21"},{"location":"corpus-analysis/#digitalocean-48-tags","title":"DigitalOcean (48 tags)","text":"Tag Operations GradientAI Platform 84 Databases 69 Monitoring 61 Apps 34 Kubernetes 28 Container Registries 19 Droplets 19 Container Registry 18 Firewalls 11 Uptime 11 Load Balancers 10 VPCs 10 Block Storage 9 Functions 9 Partner Network Connect 9"},{"location":"corpus-analysis/#asana-42-tags","title":"Asana (42 tags)","text":"Tag Operations Tasks 27 Projects 19 Goals 12 Portfolios 12 Custom fields 8 Tags 8 Users 8 Sections 7 Teams 7 Time tracking entries 6 Workspaces 6 Allocations 5 Budgets 5 Goal relationships 5 Memberships 5"},{"location":"corpus-analysis/#corpus-fingerprint","title":"Corpus Fingerprint","text":"Dimension Smallest Largest Ratio Operations Petstore (20) MS Graph (16,098) 805x Schemas Petstore (6) MS Graph (4,294) 716x Paths Petstore (14) MS Graph (10,405) 743x $ref targets Petstore (6) Plaid (2,049) 341x Response headers Stripe (0) Discord (1,200) --"},{"location":"corpus-analysis/#coverage-matrix","title":"Coverage matrix","text":"Dimension Values in Corpus OAS versions 2.0, 3.0.0, 3.0.3, 3.0.4, 3.1.0 Formats JSON (6), YAML (4) API styles REST (GitHub), RPC-over-HTTP (Plaid), OData (MS Graph), read-only (NWS, Google Maps) Auth types OAuth2, Bearer, Basic, API Key (header &amp; query), multi-key, User-Agent, undeclared Error patterns default catch-all, wildcard ranges, exhaustive codes, mixed"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>This guide provides comprehensive documentation for developers using oastools as both a library and a command-line tool.</p>"},{"location":"developer-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>CLI Usage</li> <li>Quick Reference</li> <li>Pipeline Support</li> <li>Library Usage</li> <li>Parser Package</li> <li>Validator Package</li> <li>Fixer Package</li> <li>HTTP Validator Package</li> <li>Converter Package</li> <li>Joiner Package</li> <li>Differ Package</li> <li>Generator Package</li> <li>Builder Package</li> <li>Overlay Package</li> <li>Walker Package</li> <li>Advanced Patterns</li> <li>Parse-Once Pattern</li> <li>Package Chaining</li> <li>Error Handling</li> <li>Working with Different OAS Versions</li> <li>Troubleshooting</li> </ul>"},{"location":"developer-guide/#installation","title":"Installation","text":""},{"location":"developer-guide/#cli-tool","title":"CLI Tool","text":"<pre><code># Homebrew (macOS and Linux)\nbrew install erraggy/oastools/oastools\n\n# Go install\ngo install github.com/erraggy/oastools/cmd/oastools@latest\n\n# From source\ngit clone https://github.com/erraggy/oastools.git\ncd oastools\nmake install\n</code></pre>"},{"location":"developer-guide/#library","title":"Library","text":"<pre><code>go get github.com/erraggy/oastools@latest\n</code></pre>"},{"location":"developer-guide/#cli-usage","title":"CLI Usage","text":"<p>This section provides quick examples of common CLI operations. For complete documentation including all flags, options, and output formats, see the CLI Reference.</p>"},{"location":"developer-guide/#quick-reference","title":"Quick Reference","text":"<pre><code># Validate\noastools validate openapi.yaml\noastools validate --strict --format json openapi.yaml\n\n# Fix common errors\noastools fix openapi.yaml -o fixed.yaml\noastools fix --infer openapi.yaml -o fixed.yaml  # Type inference\n\n# Parse and inspect\noastools parse openapi.yaml\noastools parse --resolve-refs openapi.yaml\n\n# Convert between versions\noastools convert -t 3.0.3 swagger.yaml -o openapi.yaml\noastools convert -t 2.0 openapi.yaml -o swagger.yaml\n\n# Join multiple specs\noastools join -o merged.yaml base.yaml ext.yaml\noastools join --path-strategy accept-left -o merged.yaml base.yaml ext.yaml\n\n# Compare specs (breaking change detection)\noastools diff api-v1.yaml api-v2.yaml\noastools diff --breaking api-v1.yaml api-v2.yaml\n\n# Generate Go code\noastools generate --client -o ./client -p petstore openapi.yaml\noastools generate --server -o ./server -p petstore openapi.yaml\n\n# Apply overlay transformations\noastools overlay apply -s openapi.yaml -o result.yaml changes.yaml\noastools overlay validate overlay.yaml\noastools overlay apply --dry-run -s openapi.yaml changes.yaml\n</code></pre>"},{"location":"developer-guide/#pipeline-support","title":"Pipeline Support","text":"<p>All commands support stdin (<code>-</code>) and quiet mode (<code>-q</code>) for shell pipelines:</p> <pre><code># Fix then validate\noastools fix api.yaml | oastools validate -q -\n\n# Convert via pipeline\ncat swagger.yaml | oastools convert -q -t 3.0.3 - &gt; openapi.yaml\n\n# Chain operations\ncurl -s https://example.com/swagger.yaml | oastools convert -q -t 3.0.3 - | oastools validate -q -\n</code></pre> <p>For detailed documentation on each command including all flags, output formats, exit codes, and examples, see the CLI Reference.</p>"},{"location":"developer-guide/#library-usage","title":"Library Usage","text":""},{"location":"developer-guide/#parser-package","title":"Parser Package","text":"<p>The parser package provides parsing for OpenAPI Specification documents.</p> <p>Basic Parsing:</p> <pre><code>import \"github.com/erraggy/oastools/parser\"\n\n// Using functional options (recommended for simple cases)\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithValidateStructure(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Access parsed document (version-specific)\nswitch doc := result.Document.(type) {\ncase *parser.OAS2Document:\n    fmt.Printf(\"Swagger %s: %s\\n\", doc.Swagger, doc.Info.Title)\ncase *parser.OAS3Document:\n    fmt.Printf(\"OpenAPI %s: %s\\n\", doc.OpenAPI, doc.Info.Title)\n}\n\n// Or use version-agnostic access with DocumentAccessor\nif accessor := result.AsAccessor(); accessor != nil {\n    fmt.Printf(\"API: %s\\n\", accessor.GetInfo().Title)\n    fmt.Printf(\"Schemas: %d\\n\", len(accessor.GetSchemas()))\n}\n</code></pre> <p>Reusable Parser Instance:</p> <pre><code>// Create a reusable parser for processing multiple files\np := parser.New()\np.ResolveRefs = false\np.ValidateStructure = true\n\n// Process multiple files with same configuration\nresult1, _ := p.Parse(\"api1.yaml\")\nresult2, _ := p.Parse(\"api2.yaml\")\nresult3, _ := p.Parse(\"api3.yaml\")\n</code></pre> <p>Parsing from Different Sources:</p> <pre><code>// From file\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n)\n\n// From URL\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://example.com/openapi.yaml\"),\n)\n\n// From bytes\nyamlContent := []byte(`openapi: \"3.0.0\"\ninfo:\n  title: My API\n  version: \"1.0\"\npaths: {}`)\nresult, err := parser.ParseWithOptions(\n    parser.WithBytes(yamlContent),\n)\n\n// From io.Reader\nfile, _ := os.Open(\"openapi.yaml\")\nresult, err := parser.ParseWithOptions(\n    parser.WithReader(file),\n)\n</code></pre> <p>Working with External References:</p> <pre><code>// Enable reference resolution\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithResolveRefs(true),\n)\n\n// Security: References are restricted to base directory and subdirectories\n// HTTP(S) references are NOT supported for security reasons\n</code></pre> <p>Order-Preserving Marshaling:</p> <pre><code>// Enable order preservation for deterministic output\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithPreserveOrder(true),\n)\n\n// Marshal with original field order preserved\njsonBytes, _ := result.MarshalOrderedJSON()\nyamlBytes, _ := result.MarshalOrderedYAML()\n</code></pre> <p>This is useful for hash-based caching, minimizing diffs, and CI pipelines that compare serialized output.</p> <p>OAS 3.2.0 and JSON Schema 2020-12 Features:</p> <pre><code>// Access OAS 3.2.0 specific fields\nif doc, ok := result.OAS3Document(); ok {\n    // Document identity ($self)\n    if doc.Self != \"\" {\n        fmt.Printf(\"Document identity: %s\\n\", doc.Self)\n    }\n\n    // QUERY method and custom HTTP methods\n    for path, pathItem := range doc.Paths {\n        if pathItem.Query != nil {\n            fmt.Printf(\"QUERY at %s\\n\", path)\n        }\n        for method := range pathItem.AdditionalOperations {\n            fmt.Printf(\"Custom %s at %s\\n\", method, path)\n        }\n    }\n\n    // JSON Schema 2020-12 keywords (polymorphic types)\n    if doc.Components != nil &amp;&amp; doc.Components.Schemas != nil {\n        if schema, ok := doc.Components.Schemas[\"Example\"]; ok {\n            switch v := schema.UnevaluatedProperties.(type) {\n            case *parser.Schema:\n                fmt.Println(\"Unevaluated props must match schema\")\n            case bool:\n                fmt.Printf(\"Unevaluated props allowed: %v\\n\", v)\n            }\n        }\n    }\n}\n</code></pre> <p>For comprehensive coverage of these features, see Parser Deep Dive.</p>"},{"location":"developer-guide/#validator-package","title":"Validator Package","text":"<p>The validator package provides validation for OpenAPI Specification documents.</p> <p>Basic Validation:</p> <pre><code>import \"github.com/erraggy/oastools/validator\"\n\n// Validate with functional options\nresult, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"openapi.yaml\"),\n    validator.WithIncludeWarnings(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nif !result.Valid {\n    fmt.Printf(\"Validation failed with %d errors\\n\", result.ErrorCount)\n    for _, err := range result.Errors {\n        fmt.Printf(\"  %s: %s\\n\", err.Path, err.Message)\n    }\n}\n</code></pre> <p>Strict Mode:</p> <pre><code>// Strict mode treats warnings as errors\nresult, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"openapi.yaml\"),\n    validator.WithIncludeWarnings(true),\n    validator.WithStrictMode(true),\n)\n\n// In strict mode, result.Valid will be false if there are warnings\n</code></pre> <p>Validating Pre-Parsed Documents:</p> <pre><code>// Parse once, validate multiple times (30x faster)\nparseResult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithValidateStructure(true),\n)\n\nresult, err := validator.ValidateWithOptions(\n    validator.WithParsed(*parseResult),\n    validator.WithIncludeWarnings(true),\n)\n</code></pre> <p>Processing Validation Errors:</p> <pre><code>for _, err := range result.Errors {\n    fmt.Printf(\"Path: %s\\n\", err.Path)\n    fmt.Printf(\"Message: %s\\n\", err.Message)\n    fmt.Printf(\"Severity: %s\\n\", err.Severity)\n    if err.SpecRef != \"\" {\n        fmt.Printf(\"Spec Reference: %s\\n\", err.SpecRef)\n    }\n}\n</code></pre> <p>Accessing Operation Context:</p> <pre><code>// Each validation error includes operation context when applicable\nfor _, err := range result.Errors {\n    if err.OperationContext != nil {\n        fmt.Printf(\"Operation: %s %s\\n\", err.OperationContext.Method, err.OperationContext.Path)\n        if err.OperationContext.OperationID != \"\" {\n            fmt.Printf(\"OperationId: %s\\n\", err.OperationContext.OperationID)\n        }\n    }\n    fmt.Printf(\"Error: %s\\n\", err.Message)\n}\n\n// The String() method automatically includes operation context\nfmt.Println(err.String()) // \"GET /users/{id} (getUser): parameter 'id' is required\"\n</code></pre> <p>\ud83d\udcda Deep Dive: For comprehensive examples and advanced patterns, see the Validator Deep Dive.</p>"},{"location":"developer-guide/#fixer-package","title":"Fixer Package","text":"<p>The fixer package automatically corrects common validation errors in OpenAPI Specification documents.</p> <p>Basic Fixing:</p> <pre><code>import \"github.com/erraggy/oastools/fixer\"\n\n// Fix with functional options\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithInferTypes(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nif result.HasFixes() {\n    fmt.Printf(\"Applied %d fixes\\n\", result.FixCount)\n    for _, fix := range result.Fixes {\n        fmt.Printf(\"  %s: %s\\n\", fix.Type, fix.Description)\n    }\n}\n</code></pre> <p>Reusable Fixer Instance:</p> <pre><code>// Create a reusable fixer for processing multiple files\nf := fixer.New()\nf.InferTypes = true\n\n// Process multiple files with same configuration\nresult1, _ := f.Fix(\"api1.yaml\")\nresult2, _ := f.Fix(\"api2.yaml\")\nresult3, _ := f.Fix(\"api3.yaml\")\n</code></pre> <p>Fixing Pre-Parsed Documents:</p> <pre><code>// Parse once, fix multiple times\nparseResult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithValidateStructure(true),\n)\n\nresult, err := fixer.FixWithOptions(\n    fixer.WithParsed(*parseResult),\n    fixer.WithInferTypes(true),\n)\n</code></pre> <p>Processing Fix Results:</p> <pre><code>result, _ := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n)\n\nfor _, fix := range result.Fixes {\n    fmt.Printf(\"Type: %s\\n\", fix.Type)\n    fmt.Printf(\"Path: %s\\n\", fix.Path)\n    fmt.Printf(\"Description: %s\\n\", fix.Description)\n}\n\n// Access the fixed document\nswitch doc := result.Document.(type) {\ncase *parser.OAS2Document:\n    // Work with fixed OAS 2.0 document\ncase *parser.OAS3Document:\n    // Work with fixed OAS 3.x document\n}\n</code></pre> <p>Fixing Invalid Schema Names:</p> <p>Note: Schema renaming is not enabled by default. You must use <code>WithEnabledFixes()</code> to opt-in.</p> <pre><code>// Fix schemas with invalid names (e.g., Response[User])\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeRenamedGenericSchema), // Enable schema renaming\n    fixer.WithGenericNaming(fixer.GenericNamingOf),            // Response[User] \u2192 ResponseOfUser\n)\n\n// Available naming strategies:\n// - fixer.GenericNamingUnderscore: Response[User] \u2192 Response_User_\n// - fixer.GenericNamingOf:         Response[User] \u2192 ResponseOfUser\n// - fixer.GenericNamingFor:        Response[User] \u2192 ResponseForUser\n// - fixer.GenericNamingFlattened:  Response[User] \u2192 ResponseUser\n// - fixer.GenericNamingDot:        Response[User] \u2192 Response.User\n</code></pre> <p>Pruning Unused Schemas:</p> <pre><code>// Remove unreferenced schemas\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypePrunedUnusedSchema),\n)\n\nfor _, fix := range result.Fixes {\n    fmt.Printf(\"Removed unused schema: %s\\n\", fix.Before)\n}\n</code></pre> <p>Fixing Duplicate OperationIds:</p> <pre><code>// Fix duplicate operationId values with default template\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeDuplicateOperationId),\n)\n\n// With custom naming template\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeDuplicateOperationId),\n    fixer.WithOperationIdNamingConfig(fixer.OperationIdNamingConfig{\n        Template: \"{method:pascal}{path:pascal}\",\n    }),\n)\n\n// Template placeholders: {operationId}, {method}, {path}, {tag}, {tags}, {n}\n// Modifiers: :pascal, :camel, :snake, :kebab, :upper, :lower\n// Default template: {operationId}{n} produces getUser, getUser2, getUser3, etc.\n</code></pre> <p>Stubbing Missing References:</p> <pre><code>// Create stubs for unresolved local $ref pointers\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeStubMissingRef),\n)\n\n// With custom response description\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeStubMissingRef),\n    fixer.WithStubResponseDescription(\"TODO: implement\"),\n)\n\n// Missing schema references get empty {} stubs\n// Missing response references get stub responses with configurable descriptions\n</code></pre> <p>Dry-Run Mode:</p> <pre><code>// Preview changes without applying\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithDryRun(true),\n)\n\nfmt.Printf(\"Would apply %d fix(es)\\n\", result.FixCount)\nfor _, fix := range result.Fixes {\n    fmt.Printf(\"  %s: %s\\n\", fix.Type, fix.Description)\n}\n</code></pre> <p>Mutable Input (Skip Defensive Copy):</p> <p>By default, <code>FixWithOptions</code> deep-copies the parsed document to avoid mutating the caller's data. When you own the input and don't need it afterward, use <code>WithMutableInput(true)</code> to skip the copy and fix in place:</p> <pre><code>// Caller owns the document and doesn't need the original\nresult, err := fixer.FixWithOptions(\n    fixer.WithParsed(*parseResult),\n    fixer.WithMutableInput(true), // Skip defensive copy\n)\n</code></pre> <p>This is especially useful when chaining fixer passes, since each intermediate result is a fresh document you already own:</p> <pre><code>// First pass produces a new document\npass1, _ := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeMissingPathParameter),\n)\n\n// Second pass can mutate pass1's document directly\npass2, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*pass1.ToParseResult()),\n    fixer.WithMutableInput(true), // Safe - we own pass1's document\n    fixer.WithEnabledFixes(fixer.FixTypeRenamedGenericSchema),\n)\n</code></pre>"},{"location":"developer-guide/#http-validator-package","title":"HTTP Validator Package","text":"<p>The httpvalidator package validates HTTP requests and responses against OpenAPI specifications at runtime, enabling API gateways, middleware, and testing frameworks to enforce API contracts.</p> <p>Basic Request Validation:</p> <pre><code>import (\n    \"net/http\"\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// Parse specification once at startup\nparsed, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n)\n\n// Create validator instance\nv, _ := httpvalidator.New(parsed)\n\n// Validate incoming request\nreq, _ := http.NewRequest(\"GET\", \"/users/123?page=1\", nil)\nresult, err := v.ValidateRequest(req)\n\nif result.Valid {\n    // Access deserialized parameters\n    userID := result.PathParams[\"userId\"]   // \"123\"\n    page := result.QueryParams[\"page\"]      // 1 (int)\n}\n</code></pre> <p>Response Validation (for middleware):</p> <pre><code>// Validate response using captured response data\nresult, _ := v.ValidateResponseData(\n    req,\n    statusCode,\n    responseHeaders,\n    responseBody,\n)\n\nif !result.Valid {\n    log.Printf(\"Response validation failed: %v\", result.Errors)\n}\n</code></pre> <p>Strict Mode:</p> <pre><code>// Enable strict validation\nv.StrictMode = true  // Reject unknown parameters and undocumented responses\n\nresult, _ := v.ValidateRequest(req)\n// Unknown query parameters will cause validation errors\n</code></pre> <p>Functional Options API:</p> <pre><code>// One-off validation without creating a validator instance\nresult, err := httpvalidator.ValidateRequestWithOptions(\n    req,\n    httpvalidator.WithFilePath(\"openapi.yaml\"),\n    httpvalidator.WithStrictMode(true),\n)\n</code></pre> <p>For comprehensive httpvalidator usage patterns, see the HTTP Validator Deep Dive.</p>"},{"location":"developer-guide/#converter-package","title":"Converter Package","text":"<p>The converter package provides version conversion for OpenAPI Specification documents.</p> <p>Basic Conversion:</p> <pre><code>import \"github.com/erraggy/oastools/converter\"\n\n// Convert OAS 2.0 to 3.0.3\nresult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Check for critical issues\nif result.HasCriticalIssues() {\n    fmt.Printf(\"Conversion had %d critical issues\\n\", result.CriticalCount)\n    for _, issue := range result.Issues {\n        if issue.Severity == converter.SeverityCritical {\n            fmt.Printf(\"  [CRITICAL] %s: %s\\n\", issue.Path, issue.Message)\n        }\n    }\n}\n</code></pre> <p>Handling Conversion Issues:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n    converter.WithIncludeInfo(true), // Include informational messages\n)\n\n// Process issues by severity\nfor _, issue := range result.Issues {\n    switch issue.Severity {\n    case converter.SeverityCritical:\n        fmt.Printf(\"CRITICAL: %s - %s\\n\", issue.Path, issue.Message)\n        if issue.Context != \"\" {\n            fmt.Printf(\"  Context: %s\\n\", issue.Context)\n        }\n    case converter.SeverityWarning:\n        fmt.Printf(\"WARNING: %s - %s\\n\", issue.Path, issue.Message)\n    case converter.SeverityInfo:\n        fmt.Printf(\"INFO: %s - %s\\n\", issue.Path, issue.Message)\n    }\n}\n</code></pre> <p>Writing Converted Output:</p> <pre><code>import (\n    \"os\"\n    \"encoding/json\"\n    \"go.yaml.in/yaml/v4\"\n)\n\nresult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n\n// Write as YAML (preserves input format by default)\nvar output []byte\nif result.SourceFormat == parser.SourceFormatJSON {\n    output, _ = json.MarshalIndent(result.Document, \"\", \"  \")\n} else {\n    output, _ = yaml.Marshal(result.Document)\n}\n\nos.WriteFile(\"openapi.yaml\", output, 0600)\n</code></pre>"},{"location":"developer-guide/#joiner-package","title":"Joiner Package","text":"<p>The joiner package provides joining for multiple OpenAPI Specification documents.</p> <p>Basic Joining:</p> <pre><code>import \"github.com/erraggy/oastools/joiner\"\n\n// Join with default configuration\nresult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"extension.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Write result to file\nj := joiner.New(joiner.DefaultConfig())\nj.WriteResult(result, \"merged.yaml\")\n</code></pre> <p>Custom Collision Strategies:</p> <pre><code>// Different strategies for different component types\nconfig := joiner.JoinerConfig{\n    DefaultStrategy:   joiner.StrategyFailOnCollision,\n    PathStrategy:      joiner.StrategyFailOnPaths,      // Fail on path collisions\n    SchemaStrategy:    joiner.StrategyAcceptLeft,       // Keep first schema\n    ComponentStrategy: joiner.StrategyAcceptRight,      // Keep last component\n    DeduplicateTags:   true,\n    MergeArrays:       true,\n}\n\nresult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"ext.yaml\"),\n    joiner.WithConfig(config),\n)\n</code></pre> <p>Joining Pre-Parsed Documents (154x faster):</p> <pre><code>// Parse documents once\ndocs := make([]parser.ParseResult, 0)\nfor _, path := range []string{\"api1.yaml\", \"api2.yaml\", \"api3.yaml\"} {\n    result, err := parser.ParseWithOptions(\n        parser.WithFilePath(path),\n        parser.WithValidateStructure(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    docs = append(docs, *result)\n}\n\n// Join parsed documents\nconfig := joiner.DefaultConfig()\nj := joiner.New(config)\nresult, err := j.JoinParsed(docs)\n</code></pre> <p>Processing Join Warnings:</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"ext.yaml\"),\n    joiner.WithConfig(joiner.DefaultConfig()),\n)\n\nif len(result.Warnings) &gt; 0 {\n    fmt.Printf(\"Join completed with %d warnings:\\n\", len(result.Warnings))\n    for _, warning := range result.Warnings {\n        fmt.Printf(\"  - %s\\n\", warning)\n    }\n}\n\nif result.CollisionCount &gt; 0 {\n    fmt.Printf(\"Resolved %d collisions\\n\", result.CollisionCount)\n}\n</code></pre> <p>Semantic Deduplication:</p> <p>Semantic deduplication identifies structurally identical schemas across documents and consolidates them to reduce duplication:</p> <pre><code>// Enable semantic deduplication to consolidate identical schemas\nconfig := joiner.JoinerConfig{\n    DefaultStrategy:       joiner.StrategyAcceptLeft,\n    SemanticDeduplication: true,   // Enable schema deduplication\n    EquivalenceMode:       \"deep\", // Use deep structural comparison\n    DeduplicateTags:       true,\n    MergeArrays:           true,\n}\n\nj := joiner.New(config)\nresult, err := j.Join([]string{\"api1.yaml\", \"api2.yaml\", \"api3.yaml\"})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Semantic deduplication consolidates identical schemas:\n// - Schemas with identical structure are detected via FNV-1a hashing\n// - The alphabetically-first name becomes the canonical schema\n// - All $ref references are automatically rewritten\n// - Warnings indicate how many duplicates were consolidated\n</code></pre> <p>Operation-Aware Schema Renaming:</p> <p>When joining programmatically generated specs (e.g., from frameworks like Huma), schemas often have generic names like \"Response\" or \"Request\". Operation-aware renaming uses API structure context to generate meaningful names:</p> <pre><code>// Enable operation context for rich rename templates\nconfig := joiner.DefaultConfig()\nconfig.SchemaStrategy = joiner.StrategyRenameRight\nconfig.OperationContext = true  // Build reference graph\nconfig.RenameTemplate = \"{{.OperationID | pascalCase}}{{.Name}}\"\n\nj := joiner.New(config)\nresult, err := j.Join([]string{\"users-api.yaml\", \"orders-api.yaml\"})\n\n// Colliding \"Response\" schemas become:\n// - Response (from users-api, kept)\n// - CreateOrderResponse (from orders-api, renamed using operationId)\n</code></pre> <p>Template functions available:</p> <ul> <li>Path extraction: <code>pathResource</code> (last non-parameter segment), <code>pathLast</code> (final segment)</li> <li>Case conversion: <code>pascalCase</code>, <code>camelCase</code>, <code>snakeCase</code>, <code>kebabCase</code></li> <li>Conditionals: <code>default</code> (fallback value), <code>coalesce</code> (first non-empty)</li> </ul> <p>Example template using path context:</p> <pre><code>config.RenameTemplate = \"{{.Path | pathResource | pascalCase}}{{.Name}}\"\n// /orders/{id} + \"Response\" \u2192 OrdersResponse\n</code></pre> <p>Collision Handler Callbacks:</p> <p>For fine-grained control over collision resolution, register a collision handler callback. The handler is invoked for each collision with full context, allowing custom decisions or observation:</p> <pre><code>// Observe-only handler: log collisions but use configured strategy\nresult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users-api.yaml\", \"billing-api.yaml\"),\n    joiner.WithCollisionHandler(func(c joiner.CollisionContext) (joiner.CollisionResolution, error) {\n        log.Printf(\"Collision detected: %s %q (%s vs %s)\\n\",\n            c.Type, c.Name, c.LeftSource, c.RightSource)\n        return joiner.ContinueWithStrategy(), nil  // Defer to configured strategy\n    }),\n)\n</code></pre> <p>Handle only specific collision types:</p> <pre><code>// Only handle schema collisions, let others use configured strategy\nresult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users-api.yaml\", \"billing-api.yaml\"),\n    joiner.WithCollisionHandlerFor(func(c joiner.CollisionContext) (joiner.CollisionResolution, error) {\n        if c.Name == \"Error\" {\n            return joiner.AcceptLeft(), nil  // Always keep left Error schema\n        }\n        return joiner.ContinueWithStrategy(), nil\n    }, joiner.CollisionTypeSchema),\n)\n</code></pre> <p>Resolution actions available:</p> <ul> <li><code>ContinueWithStrategy()</code> - Defer to the configured collision strategy</li> <li><code>AcceptLeft()</code> - Keep the value from the left (earlier) document</li> <li><code>AcceptRight()</code> - Keep the value from the right (later) document</li> <li><code>Rename()</code> - Rename the right value using the configured template</li> <li><code>Deduplicate()</code> - Merge if structurally equivalent, fail otherwise</li> <li><code>Fail()</code> - Fail the join operation with an error</li> <li><code>UseCustomValue(value)</code> - Use a custom-provided value</li> </ul> <p>The <code>CollisionContext</code> provides: Type, Name, JSONPath, LeftSource/RightSource, LeftValue/RightValue, semantic hashes, and <code>AreEquivalent</code> for quick equivalence checks.</p> <p>\ud83d\udcda Deep Dive: For comprehensive examples and advanced patterns, see the Joiner Deep Dive.</p>"},{"location":"developer-guide/#differ-package","title":"Differ Package","text":"<p>The differ package provides OpenAPI specification comparison and breaking change detection.</p> <p>Basic Diff:</p> <pre><code>import \"github.com/erraggy/oastools/differ\"\n\n// Simple diff\nresult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Found %d changes\\n\", len(result.Changes))\nfor _, change := range result.Changes {\n    fmt.Println(change.String())\n}\n</code></pre> <p>Breaking Change Detection:</p> <pre><code>// Enable breaking change detection\nresult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n    differ.WithIncludeInfo(true),\n)\n\nif result.HasBreakingChanges {\n    fmt.Printf(\"\u26a0\ufe0f  Found %d breaking changes!\\n\", result.BreakingCount)\n}\n\nfmt.Printf(\"Summary: %d breaking, %d warnings, %d info\\n\",\n    result.BreakingCount, result.WarningCount, result.InfoCount)\n</code></pre> <p>Diffing Pre-Parsed Documents (81x faster):</p> <pre><code>// Parse documents once\nsource, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"api-v1.yaml\"),\n    parser.WithValidateStructure(true),\n)\ntarget, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"api-v2.yaml\"),\n    parser.WithValidateStructure(true),\n)\n\n// Compare parsed documents\nresult, err := differ.DiffWithOptions(\n    differ.WithSourceParsed(*source),\n    differ.WithTargetParsed(*target),\n    differ.WithMode(differ.ModeBreaking),\n)\n</code></pre> <p>Grouping Changes by Category:</p> <pre><code>result, _ := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n)\n\n// Group changes by category\ncategories := make(map[differ.ChangeCategory][]differ.Change)\nfor _, change := range result.Changes {\n    categories[change.Category] = append(categories[change.Category], change)\n}\n\n// Process each category\ncategoryOrder := []differ.ChangeCategory{\n    differ.CategoryEndpoint,\n    differ.CategoryOperation,\n    differ.CategoryParameter,\n    differ.CategoryRequestBody,\n    differ.CategoryResponse,\n    differ.CategorySchema,\n    differ.CategorySecurity,\n    differ.CategoryServer,\n    differ.CategoryInfo,\n}\n\nfor _, category := range categoryOrder {\n    changes := categories[category]\n    if len(changes) &gt; 0 {\n        fmt.Printf(\"\\n%s Changes (%d):\\n\", category, len(changes))\n        for _, change := range changes {\n            fmt.Printf(\"  %s\\n\", change.String())\n        }\n    }\n}\n</code></pre> <p>Configurable Breaking Change Rules:</p> <pre><code>// Customize which changes are considered breaking\nrules := &amp;differ.BreakingRulesConfig{\n    Operation: &amp;differ.OperationRules{\n        // Downgrade operationId changes from error to info\n        OperationIDModified: &amp;differ.BreakingChangeRule{\n            Severity: differ.SeverityPtr(differ.SeverityInfo),\n        },\n    },\n    Schema: &amp;differ.SchemaRules{\n        // Ignore type changes entirely\n        TypeChanged: &amp;differ.BreakingChangeRule{\n            Ignore: true,\n        },\n    },\n}\n\nresult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"v1.yaml\"),\n    differ.WithTargetFilePath(\"v2.yaml\"),\n    differ.WithBreakingRules(rules),\n)\n\n// Or use preset configurations:\n// - differ.DefaultRules() - built-in defaults\n// - differ.StrictRules() - elevates warnings to errors\n// - differ.LenientRules() - downgrades some errors to warnings\n</code></pre> <p>\ud83d\udcda Deep Dive: For comprehensive examples and advanced patterns, see the Differ Deep Dive.</p>"},{"location":"developer-guide/#generator-package","title":"Generator Package","text":"<p>The generator package creates idiomatic Go code for API clients and server stubs from OpenAPI specifications.</p> <p>Basic Code Generation:</p> <pre><code>import \"github.com/erraggy/oastools/generator\"\n\n// Generate client and server code\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"petstore\"),\n    generator.WithClient(true),\n    generator.WithServer(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Write generated files to output directory\nif err := result.WriteFiles(\"./generated\"); err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Generated %d files\\n\", len(result.Files))\nfmt.Printf(\"Types: %d, Operations: %d\\n\", result.GeneratedTypes, result.GeneratedOperations)\n</code></pre> <p>Types-Only Generation:</p> <pre><code>// Generate only type definitions from schemas\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"models\"),\n    generator.WithTypes(true),\n    generator.WithClient(false),\n    generator.WithServer(false),\n)\n</code></pre> <p>Configuration Options:</p> <pre><code>g := generator.New()\ng.PackageName = \"api\"\ng.GenerateClient = true\ng.GenerateServer = true\ng.GenerateTypes = true      // Always true when client or server enabled\ng.UsePointers = true        // Use pointers for optional fields\ng.IncludeValidation = true  // Add validation tags\ng.StrictMode = false        // Fail on generation issues\ng.IncludeInfo = true        // Include info messages\n\nresult, err := g.Generate(\"openapi.yaml\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Access generated files\nfor _, file := range result.Files {\n    fmt.Printf(\"%s: %d bytes\\n\", file.Name, len(file.Content))\n}\n\n// Check for critical issues\nif result.HasCriticalIssues() {\n    fmt.Printf(\"Warning: %d critical issue(s)\\n\", result.CriticalCount)\n}\n</code></pre> <p>Handling Generation Issues:</p> <pre><code>result, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n)\n\nif err != nil {\n    log.Fatal(err)\n}\n\n// Process issues by severity\nfor _, issue := range result.Issues {\n    switch issue.Severity {\n    case generator.SeverityCritical:\n        fmt.Printf(\"CRITICAL [%s]: %s\\n\", issue.Path, issue.Message)\n    case generator.SeverityWarning:\n        fmt.Printf(\"WARNING [%s]: %s\\n\", issue.Path, issue.Message)\n    case generator.SeverityInfo:\n        fmt.Printf(\"INFO [%s]: %s\\n\", issue.Path, issue.Message)\n    }\n}\n</code></pre> <p>Security Code Generation:</p> <pre><code>// Generate client with security helpers\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithSecurity(true),  // Generate security helpers\n)\n\n// The generated security_helpers.go contains ClientOption functions:\n// - WithApiKeyAPIKey(key string) for apiKey (header) schemes\n// - WithApiKeyAPIKeyQuery(key string) for apiKey (query) schemes\n// - WithApiKeyAPIKeyCookie(key string) for apiKey (cookie) schemes\n// - WithBasicAuthBasicAuth(username, password string) for HTTP basic auth\n// - WithBearerTokenBearerToken(token string) for HTTP bearer auth\n// - WithOAuth2OAuth2Token(token string) for OAuth2\n// - WithOidcToken(token string) for OpenID Connect\n</code></pre> <p>OAuth2 Flow Generation:</p> <pre><code>// Generate full OAuth2 client implementations\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithOAuth2Flows(true),\n)\n\n// Generated OAuth2 code includes:\n// - {SchemeName}OAuth2Config struct\n// - {SchemeName}OAuth2Client with flow methods\n// - GetAuthorizationURL() for authorization code flow\n// - ExchangeCode() to exchange codes for tokens\n// - GeneratePKCEChallenge() for PKCE challenge generation\n// - GetAuthorizationURLWithPKCE() for secure authorization with PKCE\n// - ExchangeCodeWithPKCE() for token exchange with PKCE\n// - GetClientCredentialsToken() for client credentials\n// - RefreshToken() for token refresh\n// - WithOAuth2AutoRefresh() ClientOption\n</code></pre> <p>Credential Management:</p> <pre><code>// Generate credential provider interfaces\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithCredentialMgmt(true),\n)\n\n// Generated credential code includes:\n// - CredentialProvider interface\n// - MemoryCredentialProvider for testing\n// - EnvCredentialProvider for environment variables\n// - CredentialChain for fallback providers\n// - WithCredentialProvider() ClientOption\n</code></pre> <p>Security Enforcement (Server-Side):</p> <pre><code>// Generate security validation middleware\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithServer(true),\n    generator.WithSecurityEnforce(true),\n)\n\n// Generated enforcement code includes:\n// - SecurityRequirement struct\n// - OperationSecurityRequirements map\n// - SecurityValidator for validating requests\n// - RequireSecurityMiddleware for enforcement\n</code></pre> <p>OpenID Connect Discovery:</p> <pre><code>// Generate OIDC discovery client\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithOIDCDiscovery(true),\n)\n\n// Generated OIDC code includes:\n// - OIDCConfiguration struct\n// - OIDCDiscoveryClient for .well-known discovery\n// - NewOAuth2ClientFromOIDC() helper\n</code></pre> <p>File Splitting for Large APIs:</p> <pre><code>// Configure file splitting for large APIs\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"large-api.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithMaxLinesPerFile(2000),\n    generator.WithMaxTypesPerFile(200),\n    generator.WithMaxOperationsPerFile(100),\n    generator.WithSplitByTag(true),\n    generator.WithSplitByPathPrefix(true),\n)\n\n// Files will be split based on:\n// 1. Operation tags (e.g., users_client.go, orders_client.go)\n// 2. Path prefixes (e.g., api_v1_client.go, api_v2_client.go)\n// 3. Shared types in types.go\n</code></pre> <p>README Generation:</p> <pre><code>// Generate documentation with the code\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n    generator.WithReadme(true),\n)\n\n// README.md includes:\n// - API overview and version\n// - Generated file descriptions\n// - Security configuration examples\n// - Regeneration command\n</code></pre> <p>\ud83d\udcda Deep Dive: For comprehensive examples and advanced patterns, see the Generator Deep Dive.</p> <p>Server Extensions:</p> <p>Generate a complete server framework with validation, routing, and testing support:</p> <pre><code>// Generate server with all extensions\nresult, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithServer(true),\n    generator.WithServerAll(), // Enable all server extensions\n)\n</code></pre> <p>Server extension options:</p> <ul> <li><code>WithServerResponses(true)</code>: Typed response writers with <code>Status*()</code> methods</li> <li><code>WithServerBinder(true)</code>: Request parameter binding using httpvalidator</li> <li><code>WithServerMiddleware(true)</code>: Validation middleware for request/response validation</li> <li><code>WithServerRouter(\"stdlib\")</code> or <code>WithServerRouter(\"chi\")</code>: HTTP router generation with path matching</li> <li><code>WithServerStubs(true)</code>: Configurable stub implementations for testing</li> <li><code>WithServerEmbedSpec(true)</code>: Embed OpenAPI spec for runtime validation</li> </ul> <p>Generated server extension files:</p> <ul> <li><code>server_responses.go</code>: Per-operation response types with <code>WriteTo()</code> methods</li> <li><code>server_binder.go</code>: <code>RequestBinder</code> with <code>Bind{Operation}Request()</code> methods</li> <li><code>server_middleware.go</code>: <code>ValidationMiddleware</code> with configurable error handling</li> <li><code>server_router.go</code>: <code>ServerRouter</code> implementing <code>http.Handler</code></li> <li><code>server_stubs.go</code>: <code>StubServer</code> with configurable function fields for testing</li> </ul> <p>Example router setup with error logging:</p> <pre><code>// Create router with validation middleware and error logging\nmiddleware, _ := ValidationMiddleware(parsed)\nrouter, _ := NewServerRouter(server, parsed,\n    WithMiddleware(middleware),\n    WithErrorHandler(func(r *http.Request, err error) {\n        log.Printf(\"Handler error: %s %s: %v\", r.Method, r.URL.Path, err)\n    }),\n)\nhttp.ListenAndServe(\":8080\", router)\n</code></pre> <p>Chi router alternative: For projects using chi, use <code>WithServerRouter(\"chi\")</code>:</p> <pre><code>result, _ := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"api\"),\n    generator.WithServer(true),\n    generator.WithServerRouter(\"chi\"), // Generate chi-based router\n)\n</code></pre> <p>The chi router provides native path parameter extraction via <code>chi.URLParam()</code> and integrates with chi's middleware ecosystem.</p>"},{"location":"developer-guide/#builder-package","title":"Builder Package","text":"<p>The builder package enables programmatic construction of OpenAPI specifications with reflection-based schema generation from Go types.</p> <p>Basic Construction:</p> <pre><code>import (\n    \"net/http\"\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// Define Go types for your API\ntype User struct {\n    ID   int64  `json:\"id\" oas:\"description=Unique user identifier\"`\n    Name string `json:\"name\" oas:\"minLength=1,maxLength=100\"`\n    Email string `json:\"email\" oas:\"format=email\"`\n}\n\ntype Error struct {\n    Code    int    `json:\"code\" oas:\"description=HTTP status code\"`\n    Message string `json:\"message\" oas:\"description=Error message\"`\n}\n\n// Build OAS 3.0 specification\nspec := builder.New(parser.OASVersion300).\n    SetTitle(\"User API\").\n    SetVersion(\"1.0.0\").\n    SetDescription(\"Simple user management API\").\n    AddOperation(http.MethodGet, \"/users/{id}\",\n        builder.WithOperationID(\"getUserByID\"),\n        builder.WithDescription(\"Get a user by ID\"),\n        builder.WithPathParam(\"id\", \"string\", builder.WithParamDescription(\"User ID\")),\n        builder.WithResponse(http.StatusOK, User{}),\n        builder.WithResponse(http.StatusNotFound, Error{}),\n    ).\n    AddOperation(http.MethodPost, \"/users\",\n        builder.WithOperationID(\"createUser\"),\n        builder.WithRequestBody(\"application/json\", User{}, builder.WithRequestDescription(\"Create user request\")),\n        builder.WithResponse(http.StatusCreated, User{}),\n        builder.WithResponse(http.StatusBadRequest, Error{}),\n    )\n\n// Build the document\ndoc, err := spec.BuildOAS3()\nif err != nil {\n    log.Fatal(err)\n}\n\n// Convert to YAML/JSON\ndata, _ := yaml.Marshal(doc)\nfmt.Println(string(data))\n</code></pre> <p>OAS Version Selection:</p> <pre><code>// Build for OAS 3.2.0 (latest)\nspec := builder.New(parser.OASVersion320)\n\n// Build for OAS 3.1.x\nspec := builder.New(parser.OASVersion310)\n\n// Build for OAS 3.0.x\nspec := builder.New(parser.OASVersion300)\n\n// Build for OAS 2.0 (Swagger)\nspec := builder.New(parser.OASVersion20)\n</code></pre> <p>Schema Generation from Go Types:</p> <pre><code>// Builder automatically generates JSON Schema from Go types\n// Struct tags control schema properties:\n\ntype Product struct {\n    ID          int64     `json:\"id\" oas:\"description=Product ID\"`\n    Name        string    `json:\"name\" oas:\"minLength=1,maxLength=255\"`\n    Price       float64   `json:\"price\" oas:\"minimum=0,exclusiveMinimum=true\"`\n    Description string    `json:\"description\" oas:\"maxLength=1000\"`\n    Tags        []string  `json:\"tags\" oas:\"maxItems=10\"`\n    Active      bool      `json:\"active\" oas:\"description=Is product active\"`\n    CreatedAt   time.Time `json:\"created_at\" oas:\"format=date-time\"`\n}\n\n// Builder generates appropriate OpenAPI 3.0 schema:\n// - Infers types from struct field types\n// - Applies constraints from oas tags\n// - Handles nested structs, arrays, and time.Time\n// - Generates descriptions and format hints\n</code></pre> <p>Semantic Deduplication:</p> <p>Enable semantic deduplication to automatically consolidate structurally identical schemas:</p> <pre><code>import (\n    \"net/http\"\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// Types that are structurally identical\ntype UserID struct {\n    Value int64 `json:\"value\"`\n}\ntype CustomerID struct {\n    Value int64 `json:\"value\"`\n}\n\n// Enable semantic deduplication\nspec := builder.New(parser.OASVersion320,\n    builder.WithSemanticDeduplication(true),\n).\n    SetTitle(\"API\").\n    SetVersion(\"1.0.0\").\n    AddOperation(http.MethodGet, \"/users/{id}\",\n        builder.WithResponse(http.StatusOK, UserID{}),\n    ).\n    AddOperation(http.MethodGet, \"/customers/{id}\",\n        builder.WithResponse(http.StatusOK, CustomerID{}),\n    )\n\ndoc, err := spec.BuildOAS3()\n// Result: Only 1 schema instead of 2, with $refs automatically rewritten\n</code></pre> <p>Custom Field Processors:</p> <p>For libraries that need to support custom struct tag conventions (e.g., migrating from other OpenAPI libraries), use <code>WithSchemaFieldProcessor</code>:</p> <pre><code>// Support legacy standalone tags like `description:\"...\"`\nprocessor := func(schema *parser.Schema, field reflect.StructField) *parser.Schema {\n    if desc := field.Tag.Get(\"description\"); desc != \"\" {\n        schema.Description = desc\n    }\n    return schema\n}\n\nspec := builder.New(parser.OASVersion320,\n    builder.WithSchemaFieldProcessor(processor),\n)\n</code></pre> <p>Multiple processors can be composed:</p> <pre><code>composed := builder.ComposeSchemaFieldProcessors(descProcessor, enumProcessor)\nspec := builder.New(parser.OASVersion320, builder.WithSchemaFieldProcessor(composed))\n</code></pre> <p>Vendor Extensions:</p> <pre><code>// Add vendor extensions (x-* fields) to operations, parameters, responses, and request bodies\nspec.AddOperation(http.MethodGet, \"/users\",\n    builder.WithOperationExtension(\"x-rate-limit\", 100),\n    builder.WithQueryParam(\"limit\", int32(0),\n        builder.WithParamExtension(\"x-ui-widget\", \"slider\"),\n    ),\n    builder.WithResponse(http.StatusOK, []User{},\n        builder.WithResponseExtension(\"x-cache-ttl\", 3600),\n    ),\n)\n\nspec.AddOperation(http.MethodPost, \"/users\",\n    builder.WithRequestBody(\"application/json\", User{},\n        builder.WithRequestBodyExtension(\"x-codegen-request-body-name\", \"user\"),\n    ),\n)\n</code></pre> <p>OAS 2.0 Specific Options:</p> <pre><code>// OAS 2.0 supports operation-level consumes/produces and special parameter options\nspec := builder.New(parser.OASVersion20).\n    SetTitle(\"API\").\n    SetVersion(\"1.0.0\").\n    AddOperation(http.MethodPost, \"/users\",\n        builder.WithConsumes(\"application/json\", \"application/xml\"),\n        builder.WithProduces(\"application/json\"),\n        builder.WithQueryParam(\"tags\", []string{},\n            builder.WithParamCollectionFormat(\"csv\"),  // csv, ssv, tsv, pipes, multi\n            builder.WithParamAllowEmptyValue(true),\n        ),\n        builder.WithRequestBody(\"application/json\", User{}),\n        builder.WithResponse(http.StatusOK, User{}),\n    )\n</code></pre> <p>Explicit Type and Format Overrides:</p> <pre><code>// Override inferred type/format when Go types don't map directly to desired OpenAPI schema\nspec.AddOperation(http.MethodGet, \"/users/{user_id}\",\n    builder.WithPathParam(\"user_id\", \"\",\n        builder.WithParamFormat(\"uuid\"),  // String with UUID format\n    ),\n    builder.WithQueryParam(\"version\", 0,\n        builder.WithParamType(\"integer\"),\n        builder.WithParamFormat(\"int64\"),\n    ),\n)\n\n// Full schema override for complex types\nspec.AddOperation(http.MethodGet, \"/items\",\n    builder.WithQueryParam(\"ids\", nil,\n        builder.WithParamSchema(&amp;parser.Schema{\n            Type:  \"array\",\n            Items: &amp;parser.Schema{Type: \"string\", Format: \"uuid\"},\n        }),\n    ),\n)\n</code></pre> <p>Multiple Content Types:</p> <pre><code>// OAS 3.x: Multiple content types for request body and responses\nspec.AddOperation(http.MethodPost, \"/users\",\n    builder.WithRequestBodyContentTypes(\n        []string{\"application/json\", \"application/xml\"},\n        User{},\n    ),\n    builder.WithResponseContentTypes(http.StatusOK,\n        []string{\"application/json\", \"application/xml\"},\n        User{},\n    ),\n)\n</code></pre> <p>\ud83d\udcda Deep Dive: For comprehensive examples and advanced patterns, see the Builder Deep Dive.</p>"},{"location":"developer-guide/#overlay-package","title":"Overlay Package","text":"<p>The overlay package applies OpenAPI Overlay Specification v1.0.0 transformations to OpenAPI documents using JSONPath targeting.</p> <p>Basic Usage:</p> <pre><code>import \"github.com/erraggy/oastools/overlay\"\n\n// Apply overlay with functional options\nresult, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Applied %d actions\\n\", result.ActionsApplied)\n</code></pre> <p>Creating Overlays Programmatically:</p> <pre><code>// Create an overlay to update API metadata\no := &amp;overlay.Overlay{\n    Version: \"1.0.0\",\n    Info: overlay.Info{\n        Title:   \"Update API Title\",\n        Version: \"1.0.0\",\n    },\n    Actions: []overlay.Action{\n        {\n            Target: \"$.info\",\n            Update: map[string]any{\n                \"title\":         \"Production API\",\n                \"x-environment\": \"production\",\n            },\n        },\n        {\n            Target: \"$.paths[?@.x-internal==true]\",\n            Remove: true,\n        },\n    },\n}\n\nresult, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayParsed(o),\n)\n</code></pre> <p>Dry-Run Mode (Preview Changes):</p> <pre><code>// Preview changes without applying\ndryResult, err := overlay.DryRunWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Would apply: %d actions\\n\", dryResult.WouldApply)\nfmt.Printf(\"Would skip: %d actions\\n\", dryResult.WouldSkip)\nfor _, change := range dryResult.Changes {\n    fmt.Printf(\"  - %s %d nodes at %s\\n\", change.Operation, change.MatchCount, change.Target)\n}\n</code></pre> <p>Validating Overlay Documents:</p> <pre><code>o, err := overlay.ParseOverlayFile(\"overlay.yaml\")\nif err != nil {\n    log.Fatal(err)\n}\n\nerrs := overlay.Validate(o)\nif len(errs) &gt; 0 {\n    for _, err := range errs {\n        fmt.Printf(\"Validation error: %s\\n\", err.Message)\n    }\n}\n</code></pre> <p>Advanced JSONPath Targeting:</p> <pre><code>// The overlay package supports various JSONPath expressions:\n\n// Recursive descent - find all descriptions at any depth\n{Target: \"$..description\", Update: \"Updated description\"}\n\n// Compound filters with AND\n{Target: \"$.paths[?@.deprecated==true &amp;&amp; @.x-internal==true]\", Remove: true}\n\n// Compound filters with OR\n{Target: \"$.paths[?@.deprecated==true || @.x-obsolete==true]\", Remove: true}\n\n// Wildcard selectors\n{Target: \"$.paths.*.get\", Update: map[string]any{\"x-cached\": true}}\n</code></pre>"},{"location":"developer-guide/#walker-package","title":"Walker Package","text":"<p>The walker package provides document traversal with typed handlers for OpenAPI specifications.</p> <p>Basic Traversal:</p> <pre><code>import (\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/walker\"\n)\n\n// Parse document once\nresult, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\n\n// Walk with handlers - WalkContext provides method, path template, etc.\nvar operationCount int\nerr := walker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        // wc.Method contains HTTP method (get, post, etc.)\n        // wc.PathTemplate contains the URL path template\n        operationCount++\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Flow Control:</p> <pre><code>// Skip internal paths - WalkContext.PathTemplate available in path handlers\nwalker.Walk(result,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pi *parser.PathItem) walker.Action {\n        if strings.HasPrefix(wc.PathTemplate, \"/internal\") {\n            return walker.SkipChildren\n        }\n        return walker.Continue\n    }),\n)\n\n// Stop on first match - WalkContext.JSONPath shows location in document\nvar found *parser.Schema\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if schema.Title == \"Target\" {\n            found = schema\n            return walker.Stop\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Mutation Support:</p> <pre><code>// Handlers receive pointers for in-place modification\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if schema.Extra == nil {\n            schema.Extra = make(map[string]any)\n        }\n        schema.Extra[\"x-processed\"] = true\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Deep Dive: For comprehensive examples including cycle detection, depth limiting, and all handler types, see the Walker Deep Dive.</p> <p>Advanced Features:</p> <p>The walker package also supports:</p> <ul> <li>Parent Tracking: Access ancestor nodes with <code>WithParentTracking()</code> and helper methods like <code>ParentSchema()</code>, <code>ParentOperation()</code></li> <li>Post-Visit Handlers: Process nodes after their children with <code>WithSchemaPostHandler()</code>, <code>WithOperationPostHandler()</code>, etc.</li> <li>Reference Tracking: Track <code>$ref</code> values with <code>WithRefHandler()</code> for reference analysis. Use <code>WithMapRefTracking()</code> to also detect refs in <code>map[string]any</code> structures within polymorphic schema fields</li> </ul>"},{"location":"developer-guide/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"developer-guide/#parse-once-pattern","title":"Parse-Once Pattern","text":"<p>For workflows that process the same document multiple times, parse once and reuse the result:</p> <pre><code>// Parse once\nparseResult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithValidateStructure(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Validate (31x faster than validator.Validate)\nvalResult, _ := validator.ValidateWithOptions(\n    validator.WithParsed(*parseResult),\n    validator.WithIncludeWarnings(true),\n)\n\n// Convert (47x faster than converter.Convert)\nconvResult, _ := converter.ConvertWithOptions(\n    converter.WithParsed(*parseResult),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n\n// Diff against another parsed document (81x faster than differ.Diff)\ntargetResult, _ := parser.ParseWithOptions(parser.WithFilePath(\"api-v2.yaml\"))\ndiffResult, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(*parseResult),\n    differ.WithTargetParsed(*targetResult),\n)\n</code></pre>"},{"location":"developer-guide/#package-chaining","title":"Package Chaining","text":"<p>After converting or joining documents, use <code>ToParseResult()</code> to chain the output with other packages:</p> <p>Converter to Validator/Joiner/Differ:</p> <pre><code>// Convert OAS 2.0 to OAS 3.1\nconvResult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*convResult.ToParseResult())\n\n// Or chain to joiner\nj := joiner.New(joiner.DefaultConfig())\njoinResult, _ := j.JoinParsed([]parser.ParseResult{\n    *convResult.ToParseResult(),\n    otherSpec,\n})\n\n// Or chain to differ\ndiffResult, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(baseSpec),\n    differ.WithTargetParsed(*convResult.ToParseResult()),\n)\n</code></pre> <p>Joiner to Validator/Converter/Differ:</p> <pre><code>// Join multiple documents\njoinResult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users-api.yaml\", \"orders-api.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*joinResult.ToParseResult())\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*joinResult.ToParseResult(), \"3.1.0\")\n\n// Or chain to fixer\nfixResult, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*joinResult.ToParseResult()),\n)\n</code></pre> <p>Fixer to Validator/Converter/Joiner:</p> <pre><code>// Fix document\nfixResult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithInferTypes(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*fixResult.ToParseResult())\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*fixResult.ToParseResult(), \"3.1.0\")\n\n// Or chain to joiner with other specs\nj := joiner.New(joiner.DefaultConfig())\njoinResult, _ := j.JoinParsed([]parser.ParseResult{\n    *fixResult.ToParseResult(),\n    otherSpec,\n})\n</code></pre> <p>Tip: When chaining multiple fixer passes, use <code>WithMutableInput(true)</code> on subsequent passes to skip the defensive copy. Each <code>ToParseResult()</code> output is a fresh document you already own, so in-place mutation is safe and avoids unnecessary allocations.</p> <p>Overlay to Validator/Converter:</p> <pre><code>// Apply overlay transformations\napplyResult, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"production.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*applyResult.ToParseResult())\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*applyResult.ToParseResult(), \"3.1.0\")\n</code></pre> <p>Validator to Converter/Differ (pass-through document):</p> <pre><code>// Validate document\nvalResult, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"openapi.yaml\"),\n    validator.WithIncludeWarnings(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nif valResult.Valid {\n    // Chain validated document to converter\n    c := converter.New()\n    convResult, _ := c.ConvertParsed(*valResult.ToParseResult(), \"3.1.0\")\n}\n</code></pre> <p>Differ to Validator/Converter (target document):</p> <pre><code>// Compare API versions\ndiffResult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Report breaking changes, then continue with target (new version)\nif diffResult.HasBreakingChanges {\n    fmt.Printf(\"\u26a0\ufe0f  %d breaking changes\\n\", diffResult.BreakingCount)\n}\n\n// Chain the target (v2) to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*diffResult.ToParseResult())\n\n// ToParseResult() returns the TARGET document, enabling pipelines like:\n// diff(v1, v2) \u2192 validate(v2) \u2192 convert(v2) \u2192 publish\n</code></pre> <p>Source Naming for Pre-Parsed Documents:</p> <p>When joining pre-parsed documents, set meaningful <code>SourcePath</code> values for better collision reports:</p> <pre><code>// Set meaningful names when parsing from bytes/readers\nresult, _ := parser.ParseWithOptions(\n    parser.WithBytes(specData),\n    parser.WithSourceName(\"users-api\"),\n)\n\n// Or set SourcePath after parsing\nresult.SourcePath = \"users-api\"\n\n// The joiner emits info-level warnings for documents with generic source names\n// to help identify when source naming is needed for clear collision reports\n</code></pre>"},{"location":"developer-guide/#error-handling","title":"Error Handling","text":"<p>Handling Parse Errors:</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n)\n\nif err != nil {\n    // File not found, network error, or YAML/JSON syntax error\n    log.Fatalf(\"Failed to parse: %v\", err)\n}\n\nif len(result.Errors) &gt; 0 {\n    // Document parsed but has structural errors\n    fmt.Printf(\"Document has %d validation errors:\\n\", len(result.Errors))\n    for _, e := range result.Errors {\n        fmt.Printf(\"  - %s\\n\", e)\n    }\n}\n</code></pre> <p>Handling Conversion Errors:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"openapi.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n)\n\nif err != nil {\n    // Parse error or unsupported conversion\n    log.Fatalf(\"Conversion failed: %v\", err)\n}\n\n// Check for critical issues (features that couldn't be converted)\nfor _, issue := range result.Issues {\n    if issue.Severity == converter.SeverityCritical {\n        fmt.Printf(\"CRITICAL: %s\\n\", issue.Message)\n        // Decide whether to proceed or abort based on your requirements\n    }\n}\n</code></pre> <p>Handling Join Errors:</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"ext.yaml\"),\n    joiner.WithConfig(joiner.DefaultConfig()),\n)\n\nif err != nil {\n    switch {\n    case strings.Contains(err.Error(), \"collision\"):\n        fmt.Println(\"Path or schema collision detected\")\n        fmt.Println(\"Use a different collision strategy or resolve conflicts manually\")\n    case strings.Contains(err.Error(), \"version mismatch\"):\n        fmt.Println(\"Cannot join OAS 2.0 with OAS 3.x documents\")\n    default:\n        log.Fatalf(\"Join failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"developer-guide/#working-with-different-oas-versions","title":"Working with Different OAS Versions","text":"<p>Detecting OAS Version:</p> <pre><code>result, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"spec.yaml\"),\n)\n\nfmt.Printf(\"Version: %s\\n\", result.Version)      // e.g., \"3.0.3\"\nfmt.Printf(\"OAS Version: %d\\n\", result.OASVersion) // 2 or 3\n\nswitch doc := result.Document.(type) {\ncase *parser.OAS2Document:\n    // Swagger 2.0 specific handling\n    fmt.Printf(\"Host: %s\\n\", doc.Host)\n    fmt.Printf(\"BasePath: %s\\n\", doc.BasePath)\ncase *parser.OAS3Document:\n    // OpenAPI 3.x specific handling\n    for _, server := range doc.Servers {\n        fmt.Printf(\"Server: %s\\n\", server.URL)\n    }\n}\n</code></pre> <p>Version-Specific Validation:</p> <pre><code>result, _ := validator.ValidateWithOptions(\n    validator.WithFilePath(\"spec.yaml\"),\n    validator.WithIncludeWarnings(true),\n)\n\n// Validation automatically applies version-specific rules\n// OAS 2.0: validates against Swagger 2.0 specification\n// OAS 3.x: validates against OpenAPI 3.x specification\n</code></pre>"},{"location":"developer-guide/#http-client-configuration","title":"HTTP Client Configuration","text":"<p>The parser supports custom HTTP clients for advanced use cases:</p> <p>Custom Timeout:</p> <pre><code>client := &amp;http.Client{Timeout: 120 * time.Second}\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://api.example.com/openapi.yaml\"),\n    parser.WithHTTPClient(client),\n)\n</code></pre> <p>Corporate Proxy:</p> <pre><code>proxyURL, _ := url.Parse(\"http://proxy.corp.internal:8080\")\nclient := &amp;http.Client{\n    Transport: &amp;http.Transport{Proxy: http.ProxyURL(proxyURL)},\n}\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://internal-api.corp/spec.yaml\"),\n    parser.WithHTTPClient(client),\n)\n</code></pre> <p>Authentication via Custom Transport:</p> <pre><code>type authTransport struct {\n    token string\n    base  http.RoundTripper\n}\n\nfunc (t *authTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n    req.Header.Set(\"Authorization\", \"Bearer \"+t.token)\n    return t.base.RoundTrip(req)\n}\n\nclient := &amp;http.Client{\n    Transport: &amp;authTransport{token: \"secret\", base: http.DefaultTransport},\n}\nresult, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://api.example.com/openapi.yaml\"),\n    parser.WithHTTPClient(client),\n)\n</code></pre> <p>Connection Pooling:</p> <p>Reusing an HTTP client across multiple parse operations improves performance through connection pooling:</p> <pre><code>// Create once, reuse many times\nclient := &amp;http.Client{\n    Timeout: 30 * time.Second,\n    Transport: &amp;http.Transport{\n        MaxIdleConns:        100,\n        MaxIdleConnsPerHost: 10,\n        IdleConnTimeout:     90 * time.Second,\n    },\n}\n\n// Use for multiple parses\nresult1, _ := parser.ParseWithOptions(parser.WithFilePath(url1), parser.WithHTTPClient(client))\nresult2, _ := parser.ParseWithOptions(parser.WithFilePath(url2), parser.WithHTTPClient(client))\n</code></pre> <p>InsecureSkipVerify Interaction:</p> <p>When a custom client is provided, the <code>InsecureSkipVerify</code> option is ignored. Configure TLS on your client's transport instead:</p> <pre><code>import (\n    \"crypto/tls\"\n    \"net/http\"\n)\n\n// Instead of WithInsecureSkipVerify(true), do:\nclient := &amp;http.Client{\n    Transport: &amp;http.Transport{\n        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},\n    },\n}\n</code></pre>"},{"location":"developer-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"developer-guide/#common-issues","title":"Common Issues","text":"<p>\"missing required field 'openapi' or 'swagger'\"</p> <p>The document doesn't specify a version. Add either:</p> <ul> <li><code>openapi: \"3.0.0\"</code> (or another 3.x version) for OpenAPI 3.x</li> <li><code>swagger: \"2.0\"</code> for Swagger 2.0</li> </ul> <p>\"$ref resolution failed: access denied\"</p> <p>External references are restricted to the base directory and subdirectories. Ensure referenced files are within the allowed path.</p> <p>\"cannot join OAS 2.0 with OAS 3.x documents\"</p> <p>All documents in a join operation must be the same major version. Convert documents to a common version first.</p> <p>\"collision at path '/users'\"</p> <p>Two documents define the same path. Choose a collision strategy:</p> <ul> <li><code>accept-left</code>: Keep the first definition</li> <li><code>accept-right</code>: Keep the last definition</li> <li><code>fail</code>: Abort the operation</li> <li><code>fail-on-paths</code>: Allow schema collisions but fail on path collisions</li> </ul>"},{"location":"developer-guide/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use the Parse-Once pattern for workflows that process the same document multiple times</li> <li>Disable reference resolution when not needed: <code>parser.WithResolveRefs(false)</code></li> <li>Disable validation during parsing if you'll validate separately: <code>parser.WithValidateStructure(false)</code></li> <li>Reuse instances (Parser, Validator, Converter, Joiner, Differ) for processing multiple files</li> </ol>"},{"location":"developer-guide/#getting-help","title":"Getting Help","text":"<ul> <li>API Documentation: pkg.go.dev/github.com/erraggy/oastools</li> <li>GitHub Issues: https://github.com/erraggy/oastools/issues</li> <li>Breaking Change Semantics: See breaking-changes.md</li> <li>Performance Details: See the whitepaper performance section</li> </ul>"},{"location":"generator_beyond_boilerplate/","title":"Beyond Boilerplate: 5 Surprising Features of the <code>oastools</code> Go Code Generator","text":""},{"location":"generator_beyond_boilerplate/#introduction","title":"Introduction","text":"<p>Most of us have used an OpenAPI code generator. They're great for saving time on tedious tasks, creating basic data models and boilerplate clients from a specification. But typically, that's where their utility ends. The genuinely hard parts of API development\u2014implementing robust authentication, structuring server-side logic, or managing credentials across environments\u2014are left entirely up to the developer.</p> <p>However, some tools go much further. The Go-based <code>oastools</code> suite includes a code generator with some surprisingly powerful and thoughtful features designed to solve these exact real-world challenges. This article explores the top five most impactful features of the <code>oastools</code> generator that set it apart from the crowd.</p>"},{"location":"generator_beyond_boilerplate/#1-beyond-the-client-generating-a-full-server-skeleton","title":"1. Beyond the Client: Generating a Full Server Skeleton","text":"<p>Many generators stop at producing client code and data types. <code>oastools</code>, however, can create a comprehensive server skeleton that gives you a massive head start on building a production-ready service.</p> <p>The Feature in Action</p> <p>Using a command-line flag like <code>--server-all</code>, the generator produces not just an interface for your business logic but also the core HTTP machinery.</p> <p>Key Generated Components:</p> <ul> <li>Server Router (<code>server_router.go</code>): A complete <code>http.Handler</code> implementation that wires up your API endpoints. It performs automatic path parameter extraction, connecting URL segments directly to your handler logic.</li> <li>Validation Middleware (<code>server_middleware.go</code>): A ready-to-use middleware that validates both incoming requests and outgoing responses against your OpenAPI specification at runtime.</li> </ul> <p>Why It Matters</p> <p>This feature elevates your OpenAPI specification from mere documentation into an executable contract. Instead of generating disconnected data types that can drift from the implementation, it forges a direct link between the spec and the server's core runtime behavior. The routing and validation logic are derived directly from the design artifact, eliminating the common pain point where documentation and implementation slowly fall out of sync.</p>"},{"location":"generator_beyond_boilerplate/#2-sophisticated-credential-management-out-of-the-box","title":"2. Sophisticated Credential Management Out of the Box","text":"<p>Managing API keys, tokens, and other secrets in a real application is rarely as simple as passing a static string. You need to handle different credentials for local development, staging, and production, often sourcing them from environment variables or other configuration systems. <code>oastools</code> anticipates this need and generates a flexible credential management system.</p> <p>The Generated Solution</p> <p>When the <code>GenerateCredentialMgmt</code> option is enabled, the generator creates a set of interfaces and implementations for handling credentials in a decoupled, testable way.</p> <p>Core Components:</p> <ul> <li><code>CredentialProvider</code> Interface: A standard interface for resolving security credentials.</li> <li><code>EnvCredentialProvider</code>: A concrete implementation that sources credentials from environment variables, mapping security scheme names (e.g., <code>\"apiKey\"</code>) to environment variable names (e.g., <code>\"API_KEY\"</code>).</li> <li><code>CredentialChain</code>: A composite provider that allows you to create a fallback mechanism. You can configure it to try resolving credentials from the environment first, and if that fails, fall back to an in-memory key or another provider.</li> </ul> <p>Why It Matters</p> <p>This pattern solves a common architectural problem without requiring any custom code. It promotes a clean separation of concerns, decoupling your API client from the specifics of how credentials are stored and retrieved. This means you can have a developer's in-memory key for local testing, a <code>STAGING_API_KEY</code> environment variable for your staging environment, and a production key sourced from a secrets manager (via a custom provider), all without changing a single line of client code.</p>"},{"location":"generator_beyond_boilerplate/#3-full-lifecycle-oauth2-oidc-support","title":"3. Full Lifecycle OAuth2 &amp; OIDC Support","text":"<p>Most code generators might offer a helper to attach a pre-existing OAuth2 token to a request. <code>oastools</code> goes orders of magnitude further by generating code to manage the entire token lifecycle.</p> <p>The Feature in Action</p> <p>With options like <code>GenerateOAuth2Flows</code> and <code>GenerateOIDCDiscovery</code>, the generator automates the most complex parts of OAuth2 and OpenID Connect integration.</p> <p>Key Capabilities:</p> <ul> <li>Token Acquisition and Refresh: The generated code includes logic to handle the initial token acquisition and subsequent token refreshes, a notoriously tricky part of the OAuth2 flow.</li> <li>Authorization Code Exchange: It automates the process of exchanging an authorization code for an access token.</li> <li>OIDC Discovery: It can automatically discover OpenID Connect endpoints by querying the standard <code>.well-known</code> configuration URL provided by the identity provider.</li> </ul> <p>Why It Matters</p> <p>This capability is exceptionally rare in a code generator. Implementing OAuth2 token refresh logic is not just complex; it's a common source of security vulnerabilities. By automating this complex, security-critical logic, <code>oastools</code> saves an enormous amount of development time and significantly reduces a project's attack surface by mitigating risks associated with incorrect security implementations.</p>"},{"location":"generator_beyond_boilerplate/#4-automatic-server-side-security-enforcement","title":"4. Automatic Server-Side Security Enforcement","text":"<p>Ensuring that every endpoint in your API is correctly secured is paramount. It's also an area prone to human error, where a developer might forget to apply the necessary security checks to a new handler. <code>oastools</code> provides an automated solution to this problem.</p> <p>The Feature in Action</p> <p>When enabled with <code>GenerateSecurityEnforce</code>, the generator creates server-side middleware that automatically validates incoming requests against the <code>security</code> requirements defined for each operation in your OpenAPI specification.</p> <p>Key Generated Artifacts:</p> <ul> <li><code>SecurityRequirement</code> Structs: Type-safe representations of the security schemes defined in your spec.</li> <li><code>OperationSecurityRequirements</code> Map: A map that links each operation ID to its specific security requirements.</li> <li><code>SecurityValidator</code>: Logic to validate a request against a set of security requirements.</li> <li><code>RequireSecurityMiddleware</code>: A plug-and-play middleware that enforces these requirements at runtime.</li> </ul> <p>Why It Matters</p> <p>This feature turns your OpenAPI specification into an executable security policy. It creates an unbreakable link between the security policy defined in your spec and the runtime behavior of your server, preventing entire classes of bugs where an endpoint is left unintentionally unsecured. By automating enforcement, it positions the spec as a strategic asset for security and compliance, aligning with modern \"Policy as Code\" principles.</p>"},{"location":"generator_beyond_boilerplate/#5-taming-monolithic-apis-with-intelligent-code-splitting","title":"5. Taming Monolithic APIs with Intelligent Code Splitting","text":"<p>Working with a massive, monolithic OpenAPI specification\u2014like those for large enterprise services such as Microsoft Graph\u2014can be a challenge. A standard code generator might dump thousands or even tens of thousands of lines of code into a single, unmanageable Go file. <code>oastools</code> includes a thoughtful solution to this practical problem.</p> <p>The Feature in Action</p> <p>The generator provides configuration options to intelligently split the generated code into multiple, more manageable files.</p> <p>Available Splitting Strategies:</p> <ul> <li><code>WithSplitByTag(true)</code>: Splits the generated operations into separate files based on their operation tags (e.g., <code>users.go</code>, <code>products.go</code>).</li> <li><code>WithMaxLinesPerFile(2000)</code>: Automatically splits a file once it exceeds a specified line count, providing a fallback for untagged operations.</li> </ul> <p>Why It Matters</p> <p>This is more than a quality-of-life feature; it's critical for team scalability. A single, massive generated file is a notorious source of merge conflicts and a bottleneck for parallel development. By splitting files based on tags, <code>oastools</code> aligns the generated codebase with the API's feature domains. This allows different teams or developers to work on separate parts of the client (e.g., the \"users\" team in <code>users.go</code>, the \"products\" team in <code>products.go</code>) without collision, a profound benefit for large projects.</p>"},{"location":"generator_beyond_boilerplate/#conclusion","title":"Conclusion","text":"<p>The <code>oastools</code> code generator is a powerful example of how spec-driven development can automate far more than just simple boilerplate. It elevates the role of the OpenAPI specification from mere documentation to a central blueprint that drives the implementation of complex and critical application components.</p> <p>By embedding solutions for security, credential management, and code organization directly into the generation process, tools like this aren't just writing code for us\u2014they're enforcing architectural best practices directly from the specification.</p>"},{"location":"generator_beyond_boilerplate/#learn-more","title":"Learn More","text":"<p>For complete documentation, code examples, and configuration options:</p> <ul> <li>\ud83d\udcd6 Generator Package Deep Dive - Full documentation with practical examples</li> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation</li> <li>\ud83d\udcbb CLI Reference - Command-line usage for <code>oastools generate</code></li> </ul>"},{"location":"mcp-server/","title":"MCP Server","text":"<p>oastools includes a built-in Model Context Protocol (MCP) server that exposes all capabilities as tools over stdio transport. This allows LLM agents and AI-powered editors to validate, fix, convert, diff, join, parse, overlay, generate, and walk OpenAPI specs programmatically.</p>"},{"location":"mcp-server/#prerequisites","title":"Prerequisites","text":"<p>The MCP server is built into the <code>oastools</code> binary. Install it first:</p> <pre><code>brew install erraggy/oastools/oastools                   # Homebrew (macOS/Linux)\ngo install github.com/erraggy/oastools/cmd/oastools@latest  # Go install (requires Go 1.24+)\n</code></pre> <p>Or download a pre-built binary from the Releases page.</p>"},{"location":"mcp-server/#quick-start","title":"Quick Start","text":"<pre><code>oastools mcp\n</code></pre> <p>The server communicates over stdin/stdout using JSON-RPC, following the MCP specification. It is designed to be launched by an MCP client (such as Claude Code, Cursor, or any MCP-compatible host) rather than used interactively.</p>"},{"location":"mcp-server/#claude-code","title":"Claude Code","text":"<p>The easiest way to use the MCP server with Claude Code is to install the oastools plugin, which configures the server and registers guided skills automatically. Run inside Claude Code:</p> <pre><code>/plugin marketplace add erraggy/oastools\n/plugin install oastools\n</code></pre> <p>Alternatively, add it manually to your project's <code>.mcp.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"oastools\": {\n      \"type\": \"stdio\",\n      \"command\": \"oastools\",\n      \"args\": [\"mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"mcp-server/#other-mcp-clients","title":"Other MCP Clients","text":"<p>Any MCP-compatible client can launch the server. The transport is stdio \u2014 the client spawns <code>oastools mcp</code> as a subprocess and communicates via stdin/stdout.</p>"},{"location":"mcp-server/#configuration","title":"Configuration","text":"<p>All server defaults are configurable via <code>OASTOOLS_*</code> environment variables. The Go MCP SDK does not support <code>initializationOptions</code>, so environment variables are the configuration mechanism. Set them in your MCP client's server configuration.</p>"},{"location":"mcp-server/#environment-variables","title":"Environment Variables","text":"Variable Type Default Description <code>OASTOOLS_CACHE_ENABLED</code> bool <code>true</code> Enable/disable spec caching entirely <code>OASTOOLS_CACHE_MAX_SIZE</code> int <code>10</code> Maximum number of cached specs <code>OASTOOLS_CACHE_FILE_TTL</code> duration <code>15m</code> Cache TTL for local file specs <code>OASTOOLS_CACHE_URL_TTL</code> duration <code>5m</code> Cache TTL for URL-fetched specs <code>OASTOOLS_CACHE_CONTENT_TTL</code> duration <code>15m</code> Cache TTL for inline content specs <code>OASTOOLS_CACHE_SWEEP_INTERVAL</code> duration <code>60s</code> How often the background sweeper runs <code>OASTOOLS_WALK_LIMIT</code> int <code>100</code> Default result limit for walk tools <code>OASTOOLS_WALK_DETAIL_LIMIT</code> int <code>25</code> Default limit in detail mode <code>OASTOOLS_VALIDATE_STRICT</code> bool <code>false</code> Enable strict validation by default <code>OASTOOLS_VALIDATE_NO_WARNINGS</code> bool <code>false</code> Suppress warnings by default <code>OASTOOLS_JOIN_PATH_STRATEGY</code> string (none) Default path collision strategy for join <code>OASTOOLS_JOIN_SCHEMA_STRATEGY</code> string (none) Default schema collision strategy for join <code>OASTOOLS_ALLOW_PRIVATE_IPS</code> bool <code>false</code> Allow resolution of private/loopback IPs <code>OASTOOLS_MAX_INLINE_SIZE</code> int <code>10485760</code> Maximum size of inline content (10 MiB) <code>OASTOOLS_MAX_LIMIT</code> int <code>1000</code> Maximum result limit for walk tools <code>OASTOOLS_MAX_JOIN_SPECS</code> int <code>20</code> Maximum number of specs in a join operation <p>Duration values use Go syntax: <code>30s</code>, <code>5m</code>, <code>1h</code>. Invalid values log a warning and fall back to the default.</p>"},{"location":"mcp-server/#client-configuration-examples","title":"Client Configuration Examples","text":"<p>Claude Code (<code>.mcp.json</code>):</p> <pre><code>{\n  \"mcpServers\": {\n    \"oastools\": {\n      \"type\": \"stdio\",\n      \"command\": \"oastools\",\n      \"args\": [\"mcp\"],\n      \"env\": {\n        \"OASTOOLS_CACHE_FILE_TTL\": \"30m\",\n        \"OASTOOLS_VALIDATE_STRICT\": \"true\",\n        \"OASTOOLS_WALK_LIMIT\": \"50\"\n      }\n    }\n  }\n}\n</code></pre> <p>Claude Desktop (<code>claude_desktop_config.json</code>):</p> <pre><code>{\n  \"mcpServers\": {\n    \"oastools\": {\n      \"command\": \"oastools\",\n      \"args\": [\"mcp\"],\n      \"env\": {\n        \"OASTOOLS_CACHE_URL_TTL\": \"10m\",\n        \"OASTOOLS_JOIN_PATH_STRATEGY\": \"accept-left\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"mcp-server/#tools-17","title":"Tools (17)","text":"<p>The server registers 17 tools organized into two categories: 9 core tools and 8 walk tools.</p>"},{"location":"mcp-server/#core-tools","title":"Core Tools","text":"Tool Description <code>validate</code> Validate an OAS document against its version schema <code>parse</code> Parse an OAS document and return a structural summary <code>fix</code> Auto-fix common OAS issues (duplicate IDs, missing parameters, etc.) <code>convert</code> Convert between OAS versions (2.0, 3.0, 3.1) <code>diff</code> Compare two specs and detect breaking changes <code>join</code> Merge multiple specs with collision strategies <code>overlay_apply</code> Apply an Overlay document to a spec <code>overlay_validate</code> Validate an Overlay document structure <code>generate</code> Generate Go client/server/types from a spec"},{"location":"mcp-server/#walk-tools","title":"Walk Tools","text":"Tool Description <code>walk_operations</code> Query operations by method, path, tag, operationId, or deprecated status <code>walk_schemas</code> Query schemas by name, type, or component/inline location <code>walk_parameters</code> Query parameters by location, name, path, or method <code>walk_responses</code> Query responses by status code, path, or method <code>walk_headers</code> Query headers by name, path, method, status code, or component location <code>walk_security</code> Query security schemes by name or type <code>walk_paths</code> Query path items by path pattern (supports <code>*</code> glob) <code>walk_refs</code> Query <code>$ref</code> references by target pattern or node type"},{"location":"mcp-server/#input-model","title":"Input Model","text":"<p>Every tool accepts an OpenAPI spec through a <code>spec</code> object with three mutually exclusive input modes:</p> Field Description <code>file</code> Path to an OAS file on disk <code>url</code> URL to fetch an OAS document from <code>content</code> Inline OAS document content (JSON or YAML string) <p>Exactly one must be provided.</p> <pre><code>{\"spec\": {\"file\": \"openapi.yaml\"}}\n</code></pre> <pre><code>{\"spec\": {\"url\": \"https://example.com/api/openapi.yaml\"}}\n</code></pre> <pre><code>{\"spec\": {\"content\": \"{\\\"openapi\\\": \\\"3.1.0\\\", ...}\"}}\n</code></pre>"},{"location":"mcp-server/#special-input-patterns","title":"Special Input Patterns","text":"<p>Some tools use different input structures:</p> Tool Input Pattern <code>diff</code> <code>base</code> + <code>revision</code> (two separate spec objects) <code>join</code> <code>specs</code> array (minimum 2) <code>overlay_apply</code> <code>spec</code> + <code>overlay</code> (spec object + overlay object) All others Single <code>spec</code> object"},{"location":"mcp-server/#tool-reference","title":"Tool Reference","text":""},{"location":"mcp-server/#validate","title":"validate","text":"<p>Validate an OpenAPI spec against its declared version schema.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document (file/url/content) <code>strict</code> boolean Enable stricter validation beyond spec requirements <code>no_warnings</code> boolean Suppress warning messages <p>Output:</p> Field Type Description <code>valid</code> boolean Whether the spec is valid <code>version</code> string Detected OAS version <code>error_count</code> number Number of validation errors <code>warning_count</code> number Number of warnings <code>errors</code> array Error details (path, message, field) <code>warnings</code> array Warning details <p>Example:</p> <pre><code>{\n  \"spec\": {\"file\": \"openapi.yaml\"},\n  \"strict\": true\n}\n</code></pre>"},{"location":"mcp-server/#parse","title":"parse","text":"<p>Parse an OAS document and return a structural summary.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document <code>full</code> boolean Return the full parsed document instead of a summary <code>resolve_refs</code> boolean Resolve <code>$ref</code> pointers before returning <p>Output (summary mode):</p> Field Type Description <code>version</code> string OAS version <code>title</code> string API title <code>description</code> string API description <code>path_count</code> number Number of paths <code>operation_count</code> number Number of operations <code>schema_count</code> number Number of schemas <code>servers</code> array Server URLs <code>tags</code> array Tag names"},{"location":"mcp-server/#fix","title":"fix","text":"<p>Auto-fix common issues in an OAS document.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document <code>dry_run</code> boolean Preview fixes without applying <code>include_document</code> boolean Include the fixed document in the response <code>output</code> string File path to write the fixed document <code>fix_duplicate_operationids</code> boolean Deduplicate operationId values <code>fix_schema_names</code> boolean Rename generic schema names <code>prune</code> boolean Remove empty paths and unused schemas <code>stub_missing_refs</code> boolean Create stub schemas for missing <code>$ref</code> targets <p>Output:</p> Field Type Description <code>version</code> string OAS version <code>fix_count</code> number Number of fixes applied <code>fixes</code> array Fix details (type, path, description) <code>written_to</code> string File path where the fixed document was written <code>document</code> string Fixed document (when <code>include_document</code> is true)"},{"location":"mcp-server/#convert","title":"convert","text":"<p>Convert an OAS document between versions.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document <code>target</code> string Target version (<code>2.0</code>, <code>3.0</code>, or <code>3.1</code>) \u2014 required <code>output</code> string File path to write the converted document <p>Output:</p> Field Type Description <code>source_version</code> string Original OAS version <code>target_version</code> string Target OAS version <code>success</code> boolean Whether conversion succeeded <code>issue_count</code> number Number of conversion issues <code>issues</code> array Issue details (severity, path, message) <code>document</code> string Converted document (when no output file specified)"},{"location":"mcp-server/#diff","title":"diff","text":"<p>Compare two OAS documents and report differences.</p> <p>Input:</p> Field Type Description <code>base</code> object The base/original OAS document <code>revision</code> object The revised OAS document <code>breaking_only</code> boolean Only show breaking changes <code>no_info</code> boolean Suppress informational changes <p>Output:</p> Field Type Description <code>total_changes</code> number Number of changes displayed <code>breaking_count</code> number Number of breaking changes <code>warning_count</code> number Number of warnings <code>info_count</code> number Number of informational changes <code>changes</code> array Change details (severity, type, path, message) <code>summary</code> string Human-readable summary"},{"location":"mcp-server/#join","title":"join","text":"<p>Merge multiple OAS documents into one.</p> <p>Input:</p> Field Type Description <code>specs</code> array Array of spec objects (minimum 2) <code>path_strategy</code> string Collision strategy for paths <code>schema_strategy</code> string Collision strategy for schemas <code>semantic_dedup</code> boolean Enable semantic deduplication of equivalent schemas <code>output</code> string File path to write the merged document <p>Path collision strategies: <code>accept-left</code>, <code>accept-right</code>, <code>fail</code></p> <p>Schema collision strategies: <code>accept-left</code>, <code>accept-right</code>, <code>fail</code>, <code>rename</code></p>"},{"location":"mcp-server/#overlay_apply","title":"overlay_apply","text":"<p>Apply an Overlay document to an OAS spec.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document <code>overlay</code> object The Overlay document (file/url/content) <code>dry_run</code> boolean Preview changes without applying <code>output</code> string File path to write the result"},{"location":"mcp-server/#overlay_validate","title":"overlay_validate","text":"<p>Validate an Overlay document structure.</p> <p>Input:</p> Field Type Description <code>overlay</code> object The Overlay document (file/url/content) <p>Output:</p> Field Type Description <code>valid</code> boolean Whether the overlay is valid <code>error_count</code> number Number of validation errors <code>errors</code> array Validation errors"},{"location":"mcp-server/#generate","title":"generate","text":"<p>Generate Go code from an OAS document.</p> <p>Input:</p> Field Type Description <code>spec</code> object The OAS document <code>output_dir</code> string Directory for generated files \u2014 required <code>package_name</code> string Go package name (default: <code>api</code>) <code>client</code> boolean Generate HTTP client <code>server</code> boolean Generate server interface <code>types</code> boolean Generate type definitions (default: true)"},{"location":"mcp-server/#walk-tools_1","title":"Walk Tools","text":"<p>All walk tools share common input fields:</p> Field Type Description <code>spec</code> object The OAS document <code>detail</code> boolean Return full objects instead of summaries <code>resolve_refs</code> boolean Resolve <code>$ref</code> pointers before output <code>limit</code> number Max results to return (default: 100; 25 in detail mode) <code>offset</code> number Skip the first N results (for pagination) <code>group_by</code> string Group results and return <code>{key, count}</code> aggregates instead of individual items <code>extension</code> string Filter by extension (e.g., <code>x-internal=true</code>) <p>Tool-specific filters:</p> Tool Filter Fields <code>group_by</code> Values <code>walk_operations</code> <code>method</code>, <code>path</code>, <code>tag</code>, <code>operation_id</code>, <code>deprecated</code> <code>tag</code>, <code>method</code> <code>walk_schemas</code> <code>name</code>, <code>type</code>, <code>component</code>, <code>inline</code> <code>type</code>, <code>location</code> <code>walk_parameters</code> <code>name</code>, <code>in</code>, <code>path</code>, <code>method</code> <code>location</code>, <code>name</code> <code>walk_responses</code> <code>status</code>, <code>path</code>, <code>method</code> <code>status_code</code>, <code>method</code> <code>walk_headers</code> <code>name</code>, <code>path</code>, <code>method</code>, <code>status</code>, <code>component</code> <code>name</code>, <code>status_code</code> <code>walk_security</code> <code>name</code>, <code>type</code> \u2014 <code>walk_paths</code> <code>path</code> (supports <code>*</code> glob) <code>segment</code> <code>walk_refs</code> <code>target</code>, <code>node_type</code> <code>node_type</code>"},{"location":"mcp-server/#spec-caching","title":"Spec Caching","text":"<p>The MCP server maintains a session-scoped cache of parsed specs. Once a spec is parsed, subsequent tool calls referencing the same spec reuse the cached parse result instead of re-parsing. Entries have per-type TTLs and a background sweeper removes expired entries periodically.</p> <p>Cache keys and TTLs:</p> Input Mode Key Strategy Default TTL Invalidation <code>file</code> Absolute path + file modification time 15m New key on mtime change (stale entry expires via TTL or sweeper) <code>content</code> SHA-256 hash of the content string 15m Automatic (different content = different key) or TTL expiry <code>url</code> URL string 5m TTL expiry (shorter TTL since remote content may change) <p>The cache holds a maximum of 10 entries (configurable via <code>OASTOOLS_CACHE_MAX_SIZE</code>) and uses LRU eviction when at capacity. Expired entries are lazily removed on access and proactively removed by a background sweeper (every 60s by default). Caching can be disabled entirely with <code>OASTOOLS_CACHE_ENABLED=false</code>.</p> <p>Which tools use the cache:</p> <ul> <li>Most tools use the cache: <code>parse</code>, <code>validate</code>, all <code>walk_*</code> tools, <code>generate</code>, <code>diff</code>, <code>join</code>, <code>overlay_apply</code></li> <li><code>fix</code> and <code>convert</code> bypass the cache and parse independently (they use their own internal parsing pipelines)</li> </ul>"},{"location":"mcp-server/#behavioral-notes","title":"Behavioral Notes","text":""},{"location":"mcp-server/#parse-truncation","title":"Parse Truncation","text":"<p>In summary mode (the default), <code>parse</code> truncates long description fields to 200 characters. This reduces token usage for LLM consumers. Set <code>full=true</code> to retrieve complete, untruncated descriptions.</p>"},{"location":"mcp-server/#walk_refs-count-semantics","title":"walk_refs Count Semantics","text":"<p>In <code>walk_refs</code> summary mode (the default), the <code>total</code> field represents the number of unique <code>$ref</code> targets in the spec, not the total number of <code>$ref</code> occurrences. A single target referenced from 5 locations counts as 1 toward <code>total</code>.</p> <p>In <code>detail</code> mode and <code>group_by</code> mode, <code>total</code> counts individual <code>$ref</code> occurrences (a target referenced 5 times counts as 5). When using <code>group_by=node_type</code>, each group's <code>count</code> is the number of <code>$ref</code> occurrences pointing to targets of that node type.</p>"},{"location":"mcp-server/#group-key-labels","title":"Group Key Labels","text":"<p>Some walk tools use labeled group keys to represent edge cases when using <code>group_by</code> aggregation:</p> Tool <code>group_by</code> Label Meaning <code>walk_schemas</code> <code>type</code> <code>(untyped)</code> Schemas without an explicit <code>type</code> field -- typically compositions (<code>allOf</code>/<code>anyOf</code>/<code>oneOf</code>) or <code>$ref</code> wrappers <code>walk_parameters</code> <code>location</code> <code>(ref)</code> Parameters defined as a <code>$ref</code> that have not been resolved -- the <code>in</code> field is not available until the reference is followed <code>walk_responses</code> <code>status_code</code> <code>(component)</code> Component-level responses (defined in <code>components/responses</code>) that are not associated with a specific operation or status code <code>walk_responses</code> <code>method</code> <code>(component)</code> Component-level responses that are not associated with any HTTP method <p>These labels appear as the <code>key</code> field in the <code>groups</code> array when the corresponding condition is met.</p>"},{"location":"mcp-server/#detail-mode-defaults","title":"Detail Mode Defaults","text":"<p>Walk tools in <code>detail=true</code> mode use a default limit of 25 (vs 100 for summaries) to keep output manageable. Each detail object can be 2-10KB of JSON, so 100 detail results could produce 200KB-1MB+ of output. Set <code>limit</code> explicitly to override the default.</p>"},{"location":"mcp-server/#filter-behaviors","title":"Filter Behaviors","text":"<ul> <li>Parameter auto-resolution: <code>walk_parameters</code> automatically resolves <code>$ref</code> parameters when the <code>in</code> or <code>name</code> filter is specified. Without this, <code>$ref</code> parameters have empty <code>in</code> and <code>name</code> fields, causing filters to silently return 0 results. The <code>path</code> and <code>method</code> filters don't need this since they operate on location context available even for unresolved refs. Note: Specs with circular <code>$ref</code>s fall back to original data during resolution (#326), so parameter auto-resolution may not take effect for those specs.</li> <li>OAS 3.1 type filter: <code>walk_schemas</code> <code>type=string</code> uses exact match. OAS 3.1 nullable types (<code>type: [string, null]</code>) won't match <code>type=string</code>. Use <code>component=true</code> with <code>detail=true</code> to inspect multi-type schemas.</li> <li>Schema name filter scope: <code>walk_schemas</code> <code>name</code> matches both component schema names and nested property names. Use <code>component=true</code> to restrict to component schemas only.</li> </ul>"},{"location":"mcp-server/#cross-tool-limitations","title":"Cross-Tool Limitations","text":"<ul> <li>Cross-version diff: Comparing specs across OAS versions (e.g., 2.0 vs 3.0) with <code>diff</code> reports structural format changes as breaking. This is technically correct but reflects version differences, not API changes.</li> <li>Fixer coverage: <code>fix</code> handles structural issues (duplicate operationIds, missing path parameters, unused schemas, missing <code>$ref</code> targets). Semantic validation errors (invalid compositions, type mismatches) are not auto-fixable.</li> <li>Validator strictness: Specs using <code>allOf</code>/<code>anyOf</code>/<code>oneOf</code> compositions may produce high error counts in strict mode if required properties are distributed across composed schemas.</li> </ul>"},{"location":"mcp-server/#error-handling","title":"Error Handling","text":"<p>When a tool encounters an error (invalid input, parse failure, etc.), the response uses the MCP error convention:</p> <ul> <li><code>IsError</code> is set to <code>true</code></li> <li>The <code>content</code> array contains a <code>TextContent</code> item with the error message</li> </ul> <p>This is a tool-level error \u2014 the MCP protocol call itself succeeds. This allows agents to detect the error and retry with corrected input.</p>"},{"location":"mcp-server/#architecture","title":"Architecture","text":"<p>The MCP server is implemented in the <code>internal/mcpserver</code> package:</p> <pre><code>internal/mcpserver/\n\u251c\u2500\u2500 server.go              # Entry point and tool registration\n\u251c\u2500\u2500 config.go              # Configuration via OASTOOLS_* env vars\n\u251c\u2500\u2500 input.go               # Shared specInput type and spec cache\n\u251c\u2500\u2500 tools_validate.go      # validate tool\n\u251c\u2500\u2500 tools_parse.go         # parse tool\n\u251c\u2500\u2500 tools_fix.go           # fix tool\n\u251c\u2500\u2500 tools_convert.go       # convert tool\n\u251c\u2500\u2500 tools_diff.go          # diff tool\n\u251c\u2500\u2500 tools_join.go          # join tool\n\u251c\u2500\u2500 tools_overlay.go       # overlay_apply + overlay_validate\n\u251c\u2500\u2500 tools_generate.go      # generate tool\n\u251c\u2500\u2500 tools_walk_*.go        # 8 walk tools\n\u2514\u2500\u2500 integration_test.go    # In-process integration tests\n</code></pre> <p>Each tool handler follows a consistent pattern:</p> <ol> <li>Parse the typed input struct (auto-deserialized by the SDK via JSON Schema)</li> <li>Resolve the spec input (file, URL, or inline content)</li> <li>Call the underlying oastools library package</li> <li>Return a typed output struct (auto-serialized by the SDK)</li> </ol> <p>The server uses the Go MCP SDK with generics for type-safe tool registration.</p>"},{"location":"mcp-ux-findings/","title":"MCP Server UX Findings","text":"<p>Observations from using the oastools MCP server tools as a Claude Code client to analyze the <code>testdata/corpus/</code> specs. Focus is on what a fresh-install user would encounter without codebase knowledge.</p> <p>Generated 2026-02-15 from corpus analysis session.</p>"},{"location":"mcp-ux-findings/#resolution-status","title":"Resolution Status","text":"Finding Status Resolution <code>group_by</code> on <code>walk_refs</code> Addressed Added <code>group_by=node_type</code> <code>group_by</code> on <code>walk_paths</code> Addressed Added <code>group_by=segment</code> (first path segment) <code>group_by</code> on <code>walk_security</code> Deferred Low priority -- most specs have 0-3 schemes Cross-spec aggregation Out of scope Would require multi-spec input; not planned <code>walk_headers</code> <code>component</code> filter Deferred Low usage -- headers rarely exceed component count Header name casing normalization Deferred Spec quality issue; may add as option later Empty location for $ref parameters Addressed Labeled as <code>(ref)</code> in group_by results Schema type \"\" ambiguity Addressed Labeled as <code>(untyped)</code> in group_by results Component response \"\" status Addressed Labeled as <code>(component)</code> in group_by results Parse description truncation Addressed Truncated to 200 chars in summary mode Plugin rebuild after update Addressed SessionStart hook checks binary vs plugin version <code>group_by</code> enum constraints Deferred Works via description; enum would be stricter <code>walk_refs</code> total semantics Addressed Documented in MCP server docs <code>walk_headers</code>/<code>walk_refs</code> missing from docs Addressed Added to MCP server documentation Operation-level security overrides Deferred Would need new walk_security features Spec re-parsing on every call Addressed Session-scoped LRU cache (max 10 entries) Component response \"\" method Addressed Labeled as <code>(component)</code> in <code>group_by=method</code> $ref params invisible to <code>in</code>/<code>name</code> filters Partial Auto-resolve refs when <code>in</code> or <code>name</code> filter specified; specs with circular refs fall back to unresolved data (#326) <code>detail=true</code> output too large Addressed Default limit lowered to 25 in detail mode Filter behaviors undocumented Addressed Documented in MCP server docs Cross-tool limitations undocumented Addressed Documented in MCP server docs <p>Note: The sections below reflect findings as observed during the original corpus analysis session. The Resolution Status table above shows which items have since been addressed. Sections describing addressed items are preserved as historical context for the design decisions.</p>"},{"location":"mcp-ux-findings/#setup-discovery","title":"Setup &amp; Discovery","text":""},{"location":"mcp-ux-findings/#plugin-rebuild-required-after-code-changes","title":"Plugin rebuild required after code changes","text":"<p>After PR #321 merged (adding <code>group_by</code>, <code>walk_headers</code>, <code>walk_refs</code>), the running MCP server plugin didn't expose the new tools or parameters until the plugin binary was rebuilt. The MCP tool schema is generated at runtime from Go struct tags, so a stale binary means stale schemas.</p> <p>Impact: A user who updates oastools via <code>go install</code> or git pull won't get new MCP features until they also rebuild the plugin. There's no version mismatch warning.</p> <p>Suggestion: The plugin could expose its version (from <code>plugin.json</code>) in tool responses or as a resource, so clients can detect staleness. Alternatively, document the rebuild step prominently in plugin setup docs.</p>"},{"location":"mcp-ux-findings/#tool-parameter-discoverability","title":"Tool parameter discoverability","text":"<p>The <code>group_by</code> parameter's allowed values are documented in the JSON Schema <code>description</code> field (e.g., \"Values: tag, method\"). This works well -- Claude Code picks them up automatically from the schema. However, the allowed values are buried in prose rather than using <code>enum</code> constraints.</p> <p>Suggestion: Consider adding <code>enum</code> to <code>group_by</code> fields so clients can validate locally and offer autocompletion. The current approach works but relies on the client reading the description text.</p>"},{"location":"mcp-ux-findings/#group_by-aggregation","title":"<code>group_by</code> Aggregation","text":""},{"location":"mcp-ux-findings/#what-works-well","title":"What works well","text":"<ul> <li>Massive efficiency gain: analyzing method distribution across 10 specs took 10 parallel calls instead of 50+ (5 methods x 10 specs). Each <code>group_by</code> call replaces N filter-and-count calls.</li> <li>Output shape is clean: <code>{\"groups\": [{\"key\": \"GET\", \"count\": 568}]}</code> is immediately usable. The <code>total</code> and <code>matched</code> counts alongside groups provide context.</li> <li>Sorted by count descending: groups come back largest-first, which is the natural reading order for analysis.</li> <li>Composable with filters: <code>group_by=method</code> combined with <code>tag=repos</code> works correctly to show method distribution within a specific tag.</li> </ul>"},{"location":"mcp-ux-findings/#what-could-be-improved","title":"What could be improved","text":"<ul> <li>No <code>group_by</code> on <code>walk_paths</code>: paths are the only walk tool without aggregation. A <code>group_by=depth</code> or <code>group_by=segment</code> (first path segment) would be valuable for understanding API structure. For example, GitHub's paths could be grouped by <code>/repos/**</code>, <code>/orgs/**</code>, <code>/users/**</code>.</li> <li>No <code>group_by</code> on <code>walk_refs</code>: refs already return counts by default (which is great), but there's no way to group by ref type (schema vs response vs parameter vs header). You can filter by <code>node_type</code>, but you can't get a single \"how many schema refs vs response refs vs parameter refs\" summary.</li> <li>No <code>group_by</code> on <code>walk_security</code>: low priority since most specs have 0-3 security schemes, but <code>group_by=type</code> would show the auth type distribution across a spec.</li> </ul>"},{"location":"mcp-ux-findings/#missing-cross-spec-aggregation","title":"Missing: cross-spec aggregation","text":"<p>The most labor-intensive part of the analysis was running the same <code>group_by</code> call across all 10 specs and manually assembling the results into a table. A hypothetical <code>walk_operations</code> that accepts multiple specs and returns per-spec groups would eliminate this entirely. This may be out of scope for the MCP server, but it's the dominant workflow pain point.</p>"},{"location":"mcp-ux-findings/#walk_headers-new","title":"<code>walk_headers</code> (New)","text":""},{"location":"mcp-ux-findings/#what-works-well_1","title":"What works well","text":"<ul> <li>Fills a genuine gap: before this tool, finding response headers required <code>walk_responses</code> with <code>detail=true</code> and manually inspecting each response object. Now it's a single call.</li> <li><code>group_by=name</code> is the killer feature: immediately reveals rate-limit patterns (Discord: 5 headers x 240 operations = 1,200 total) and HATEOAS patterns (GitHub: <code>Link</code> header on 193 responses).</li> <li>Correctly handles both inline and <code>$ref</code>-based headers: Discord's headers are all <code>$ref</code>s to <code>#/components/headers/X-RateLimit-*</code>, and the tool resolves them for counting.</li> </ul>"},{"location":"mcp-ux-findings/#what-could-be-improved_1","title":"What could be improved","text":"<ul> <li>No <code>component</code> filter like <code>walk_schemas</code> has: <code>walk_schemas</code> has <code>component=true</code> to show only <code>components/schemas/</code> entries. An analogous <code>component=true</code> for <code>walk_headers</code> would show only <code>components/headers/</code> definitions, useful for understanding the reusable header vocabulary.</li> <li>Header name casing: GitHub's spec has both <code>Link</code> and <code>link</code>, <code>Location</code> and <code>location</code> as separate header entries. Since HTTP headers are case-insensitive, <code>group_by=name</code> could optionally normalize casing (or at least note duplicates). This is arguably a spec quality issue rather than a tool issue, but the tool is in a position to surface it.</li> </ul>"},{"location":"mcp-ux-findings/#walk_refs-new","title":"<code>walk_refs</code> (New)","text":""},{"location":"mcp-ux-findings/#what-works-well_2","title":"What works well","text":"<ul> <li>Default behavior is perfect: returns unique ref targets ranked by reference count, most-referenced first. This immediately shows the \"gravity centers\" of a spec.</li> <li>Ref counts reveal API structure: Discord's <code>SnowflakeType</code> (554 refs) tells you more about the API's design than any other single data point. GitHub's <code>owner</code>/<code>repo</code> parameters (480/479 refs) reveal the repo-centric architecture.</li> <li>Mixed ref types in one view: seeing schemas, responses, parameters, and headers ranked together shows which component category dominates. For Discord, 5 of the top 8 refs are headers. For GitHub, 3 of the top 10 are parameters.</li> </ul>"},{"location":"mcp-ux-findings/#what-could-be-improved_2","title":"What could be improved","text":"<ul> <li>No <code>group_by=node_type</code>: as noted above, a single call to get \"schema refs: 500, response refs: 300, parameter refs: 200, header refs: 100\" would be a useful overview. Currently you'd need 4 separate calls with <code>node_type</code> filter.</li> <li><code>total</code> count semantics: for <code>walk_refs</code>, <code>total</code> returns the number of unique ref targets (e.g., 1,349 for GitHub), not the total number of <code>$ref</code> occurrences across the document. This is the right default, but the distinction isn't documented. A user might expect <code>total</code> to mean \"total $ref usages\" (which would be the sum of all <code>count</code> values).</li> </ul>"},{"location":"mcp-ux-findings/#walk_parameters","title":"<code>walk_parameters</code>","text":""},{"location":"mcp-ux-findings/#empty-location-for-ref-parameters","title":"Empty location for <code>$ref</code> parameters","text":"<p>Parameters that use <code>$ref</code> (e.g., <code>$ref: '#/components/parameters/owner'</code>) show up with an empty string location <code>\"\"</code> in <code>group_by=location</code> results. This is technically correct (the <code>in</code> field isn't on the <code>$ref</code> object itself), but it's confusing.</p> <p>For GitHub, 2,832 of 3,303 parameters (86%) show empty location. The workaround is <code>resolve_refs=true</code>, but that's expensive on large specs and changes the output format.</p> <p>Suggestion: Consider resolving just the <code>in</code> field for <code>$ref</code> parameters during grouping, or label the empty group as <code>\"$ref (unresolved)\"</code> instead of <code>\"\"</code>.</p>"},{"location":"mcp-ux-findings/#walk_schemas","title":"<code>walk_schemas</code>","text":""},{"location":"mcp-ux-findings/#total-vs-matched-distinction","title":"<code>total</code> vs <code>matched</code> distinction","text":"<p>The <code>total</code> field counts all schemas (inline + component), while <code>matched</code> reflects filters. With <code>component=true</code>:</p> Spec total (all) matched (component only) Inline % Petstore 49 33 33% GitHub 34,847 31,959 8% Stripe 23,286 8,860 62% MS Graph 89,434 29,665 67% <p>This reveals that Stripe and MS Graph have more inline schemas than component schemas -- a surprising finding that <code>group_by=location</code> would surface directly.</p>"},{"location":"mcp-ux-findings/#schema-type-none-ambiguity","title":"Schema type \"(none)\" ambiguity","text":"<p>Schemas without an explicit <code>type</code> field show as <code>\"\"</code> in <code>group_by=type</code>. These are composition schemas (<code>allOf</code>, <code>anyOf</code>, <code>oneOf</code>), pure <code>$ref</code> wrappers, or <code>enum</code>-only schemas. The empty string is accurate but unlabeled.</p> <p>Suggestion: Consider labeling these as <code>\"(composition)\"</code> or <code>\"(untyped)\"</code> to make the output self-documenting. Alternatively, the docs could explain what <code>\"\"</code> means in this context.</p>"},{"location":"mcp-ux-findings/#walk_responses","title":"<code>walk_responses</code>","text":""},{"location":"mcp-ux-findings/#wildcard-status-codes","title":"Wildcard status codes","text":"<p>Discord uses <code>4XX</code> and MS Graph uses <code>2XX</code>/<code>4XX</code>/<code>5XX</code> (OAS 3.0 range wildcards). These appear correctly in <code>group_by=status_code</code> as their literal values (<code>\"4XX\"</code>, <code>\"5XX\"</code>). The <code>status</code> filter also handles them with its own wildcard syntax (<code>status=2xx</code> matches <code>2XX</code> range codes).</p> <p>This works well. The only gap is that there's no way to distinguish between a spec that declares <code>4XX</code> (range wildcard) and one that declares individual <code>400</code>, <code>401</code>, <code>403</code>, <code>404</code> codes. Both are valid OAS patterns but imply different levels of client guidance.</p>"},{"location":"mcp-ux-findings/#walk_security","title":"<code>walk_security</code>","text":""},{"location":"mcp-ux-findings/#works-perfectly-for-its-scope","title":"Works perfectly for its scope","text":"<p>Security schemes are simple enough that the current tool covers the use case completely. No <code>group_by</code> is needed since specs rarely have more than 3 schemes.</p>"},{"location":"mcp-ux-findings/#missing-operation-level-security-overrides","title":"Missing: operation-level security overrides","text":"<p><code>walk_security</code> only shows schemes defined in <code>components/securitySchemes</code>. It doesn't show which operations use which schemes, or which operations override the global security. A <code>walk_operations</code> filter like <code>security_scheme=OAuth2</code> would be useful for understanding auth coverage.</p>"},{"location":"mcp-ux-findings/#parse-tool","title":"<code>parse</code> Tool","text":""},{"location":"mcp-ux-findings/#description-field-can-be-enormous","title":"Description field can be enormous","text":"<p>DigitalOcean's <code>description</code> field in the parse output is ~8,000 characters -- it contains their entire API introduction including rate limiting docs, curl examples, and CORS documentation. This makes the parse response very large for what's meant to be a summary.</p> <p>Suggestion: Truncate the <code>description</code> field in parse output (e.g., first 200 chars with <code>...</code>) or move it behind a <code>full=true</code> flag. The current behavior means parsing DigitalOcean returns ~10x more text than parsing Stripe, even though both are similar in structural complexity.</p>"},{"location":"mcp-ux-findings/#cross-tool-patterns","title":"Cross-Tool Patterns","text":""},{"location":"mcp-ux-findings/#consistent-output-shape","title":"Consistent output shape","text":"<p>All walk tools follow the same pattern: <code>{\"total\": N, \"matched\": N, \"returned\": N, \"summaries|groups|refs\": [...]}</code>. This consistency is excellent for tooling -- once you learn one walk tool, you know the shape of all of them.</p>"},{"location":"mcp-ux-findings/#pagination-works-but-is-rarely-needed","title":"Pagination works but is rarely needed","text":"<p><code>limit</code> and <code>offset</code> are available on all walk tools. In practice, <code>group_by</code> eliminates the need for pagination in analysis workflows since aggregated results are always small. Pagination is most useful for <code>detail=true</code> queries on large specs.</p>"},{"location":"mcp-ux-findings/#resolve_refs-is-a-power-user-feature","title":"<code>resolve_refs</code> is a power-user feature","text":"<p>Most analysis workflows don't need <code>resolve_refs=true</code>. The one exception is <code>walk_parameters</code> where unresolved refs hide the parameter location. For all other tools, the default (no resolution) is the right choice because it's faster and the output is more compact.</p>"},{"location":"mcp-ux-findings/#documentation-gaps","title":"Documentation Gaps","text":"<ol> <li><code>group_by</code> allowed values: documented in schema descriptions but not in the MCP server docs (<code>docs/mcp-server.md</code>). A table of \"tool -&gt; group_by values\" would help.</li> <li><code>walk_refs</code> total semantics: the <code>total</code> field means \"unique ref targets\", not \"total $ref occurrences\". This should be documented.</li> <li>Empty string in group keys: <code>\"\"</code> appears in <code>group_by</code> results for schemas without <code>type</code>, parameters without <code>in</code> (due to <code>$ref</code>), and responses without explicit status codes. What <code>\"\"</code> means varies by context and should be explained.</li> <li><code>walk_headers</code> and <code>walk_refs</code> aren't in the MCP server docs yet: they were added in PR #321 but the documentation page hasn't been updated.</li> <li>Plugin rebuild after update: the docs don't mention that updating oastools source requires rebuilding the plugin to get new MCP features.</li> </ol>"},{"location":"mcp-ux-findings/#summary-of-actionable-suggestions","title":"Summary of Actionable Suggestions","text":"Priority Suggestion High Add <code>walk_headers</code> and <code>walk_refs</code> to MCP server documentation High Document <code>group_by</code> values in a table in MCP docs High Document what <code>\"\"</code> means in each group_by context Medium Add <code>group_by=node_type</code> to <code>walk_refs</code> Medium ~~Label empty parameter locations~~ \u2014 resolved: labeled as <code>(ref)</code> Medium Truncate <code>description</code> in <code>parse</code> output Medium Add <code>group_by</code> to <code>walk_paths</code> (e.g., by first segment or depth) Low Add <code>component</code> filter to <code>walk_headers</code> Low Add <code>enum</code> constraints to <code>group_by</code> fields in JSON Schema Low Add version/build info to plugin for staleness detection Low Consider case-insensitive header name grouping option"},{"location":"whitepaper/","title":"oastools: A Comprehensive OpenAPI Toolkit for Go","text":"<p>White Paper</p> <p>Current as of: v1.52.0 Repository: github.com/erraggy/oastools Documentation: pkg.go.dev/github.com/erraggy/oastools License: MIT</p>"},{"location":"whitepaper/#executive-summary","title":"Executive Summary","text":"<p>oastools is a comprehensive, high-performance toolkit for working with OpenAPI Specification (OAS) documents in Go. It provides a complete solution for parsing, validating, fixing, converting, joining, diffing, walking, and generating code from API specifications spanning OAS 2.0 (Swagger) through OAS 3.2.0. The toolkit also ships an MCP server exposing all capabilities to AI-assisted development environments. oastools distinguishes itself through minimal dependencies, battle-tested quality against production APIs, significant performance optimizations, comprehensive security hardening, and native support for the OpenAPI Overlay Specification v1.0.0.</p> <p>This white paper provides an in-depth exploration of oastools, covering its architecture, package ecosystem, integration with external specifications, real-world validation, and practical usage patterns. It serves as both a technical reference and an evaluation guide for teams considering adoption.</p>"},{"location":"whitepaper/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction and Motivation</li> <li>External Specification Compliance</li> <li>Package Architecture</li> <li>Parser Package</li> <li>Validator Package</li> <li>Fixer Package</li> <li>Converter Package</li> <li>Joiner Package</li> <li>Overlay Package</li> <li>Differ Package</li> <li>Generator Package</li> <li>Builder Package</li> <li>HTTP Validator Package</li> <li>Walker Package</li> <li>MCP Server</li> <li>Error Handling with oaserrors</li> <li>Performance Analysis</li> <li>Real-World Validation</li> <li>CLI Reference</li> <li>API Design Patterns</li> <li>Security Considerations</li> <li>Conclusion</li> <li>References</li> </ol>"},{"location":"whitepaper/#1-introduction-and-motivation","title":"1. Introduction and Motivation","text":"<p>The OpenAPI Specification has become the de facto standard for describing HTTP APIs. As organizations adopt API-first development practices, the need for robust tooling to parse, validate, transform, and generate code from OpenAPI documents has grown significantly. The Go ecosystem, while rich in many areas, has historically lacked comprehensive OpenAPI tooling that addresses enterprise-scale requirements.</p> <p>oastools was created to fill this gap, addressing several key pain points. First, existing Go libraries often lack support for newer OAS versions, particularly OAS 3.1.x with its JSON Schema 2020-12 alignment, and the recently released OAS 3.2.0 with streaming and QUERY method support. Second, many OpenAPI tools bring extensive dependency trees, complicating builds, increasing binary sizes, and introducing potential security vulnerabilities. Third, repeatedly parsing the same document across validation, conversion, and generation pipelines creates unnecessary overhead at scale. Finally, generating idiomatic Go code that properly handles OAuth2 flows, Proof Key for Code Exchange (PKCE), and OpenID Connect (OIDC) discovery remains challenging with existing tools.</p> <p>oastools addresses these challenges through a modular twelve-package architecture, each package designed to excel at a specific task while integrating seamlessly with others. In addition, a built-in MCP server exposes all capabilities over the Model Context Protocol, enabling AI-assisted API development workflows. The toolkit emphasizes correctness, performance, and developer experience.</p>"},{"location":"whitepaper/#design-philosophy","title":"Design Philosophy","text":"<p>The development of oastools follows several guiding principles. The toolkit maintains minimal dependencies, relying only on <code>go.yaml.in/yaml/v4</code> for YAML parsing, <code>golang.org/x/text</code> for Unicode handling, <code>golang.org/x/tools</code> for import analysis during code generation, <code>github.com/modelcontextprotocol/go-sdk</code> for MCP server support, and <code>github.com/stretchr/testify</code> for testing. The parse-once pattern ensures documents flow through multiple operations without redundant parsing. All parser types include generated <code>DeepCopy()</code> methods for safe document mutation without serialization overhead. The toolkit supports OAS 2.0 through OAS 3.2.0 comprehensively, adapting behavior for version-specific features. Both functional options for one-off operations and reusable struct instances for batch processing are supported.</p>"},{"location":"whitepaper/#practical-examples","title":"Practical Examples","text":"<p>For hands-on examples demonstrating oastools capabilities, see the examples directory in the repository. The Petstore example showcases a complete workflow including parsing, validation, code generation, and server implementation.</p>"},{"location":"whitepaper/#2-external-specification-compliance","title":"2. External Specification Compliance","text":"<p>oastools implements and integrates with several external specifications. Understanding these relationships is essential for evaluating the toolkit's capabilities and limitations.</p>"},{"location":"whitepaper/#21-openapi-specification","title":"2.1 OpenAPI Specification","text":"<p>The OpenAPI Specification (OAS) defines a standard, programming language-agnostic interface description for HTTP APIs. oastools supports the complete OAS version range as specified by the OpenAPI Initiative.</p> <p>Supported Versions:</p> Version Specification URL Key Features OAS 2.0 spec.openapis.org/oas/v2.0.html Swagger foundation, <code>definitions</code>, <code>host</code>/<code>basePath</code> OAS 3.0.0 spec.openapis.org/oas/v3.0.0.html <code>requestBody</code>, <code>servers[]</code>, <code>components</code> OAS 3.0.1 spec.openapis.org/oas/v3.0.1.html Clarifications to 3.0.0 OAS 3.0.2 spec.openapis.org/oas/v3.0.2.html Additional clarifications OAS 3.0.3 spec.openapis.org/oas/v3.0.3.html Bug fixes, clarifications OAS 3.0.4 spec.openapis.org/oas/v3.0.4.html Latest 3.0.x patch release OAS 3.1.0 spec.openapis.org/oas/v3.1.0.html JSON Schema 2020-12 alignment, webhooks OAS 3.1.1 spec.openapis.org/oas/v3.1.1.html Clarifications to 3.1.0 OAS 3.1.2 spec.openapis.org/oas/v3.1.2.html Latest 3.1.x patch release OAS 3.2.0 spec.openapis.org/oas/v3.2.0.html QUERY method, streaming media types, tag hierarchies <p>OAS 3.1.x JSON Schema Alignment:</p> <p>OAS 3.1.x introduced significant changes by aligning with JSON Schema Draft 2020-12. Key differences that oastools handles include polymorphic <code>type</code> fields (string or array), nullable representation (type arrays including <code>\"null\"</code> rather than <code>nullable: true</code>), <code>exclusiveMinimum</code>/<code>exclusiveMaximum</code> as numbers rather than booleans, and new keywords like <code>unevaluatedProperties</code>, <code>unevaluatedItems</code>, <code>contentEncoding</code>, <code>contentMediaType</code>, and <code>contentSchema</code>.</p> <p>OAS 3.2.0 Features:</p> <p>The latest OAS version introduces several capabilities that oastools fully supports: the <code>$self</code> document identity URI, the QUERY HTTP method for complex queries, <code>additionalOperations</code> for custom HTTP methods, <code>pathItems</code> reusability via components (OAS 3.1+), and reusable <code>mediaTypes</code> in components.</p>"},{"location":"whitepaper/#22-openapi-overlay-specification","title":"2.2 OpenAPI Overlay Specification","text":"<p>The Overlay Specification v1.0.0 defines a document format for transforming OpenAPI descriptions while remaining separate from the source documents. oastools provides native overlay support through its dedicated overlay package.</p> <p>The specification defines an overlay document structure with a required <code>overlay</code> version field, <code>info</code> metadata, an optional <code>extends</code> URL pointing to the target OpenAPI document, and an <code>actions</code> array containing transformation instructions.</p> <p>Action Types:</p> <p>The <code>update</code> action merges objects and appends to arrays at the target location. When targeting an object, properties are merged with overlay values taking precedence. When targeting an array, the update value is appended.</p> <p>The <code>remove</code> action deletes nodes at the target location. When set to <code>true</code>, the matched nodes are removed from the document.</p> <p>JSONPath Implementation:</p> <p>oastools implements JSONPath per RFC 9535 for targeting nodes within OpenAPI documents. Supported features include root navigation (<code>$</code>), child access (dot and bracket notation), wildcards (<code>*</code> for all children), array indices (positive and negative), recursive descent (<code>..</code>), simple filter expressions (<code>[?(@.property == value)]</code>), compound filters with logical operators, and comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).</p>"},{"location":"whitepaper/#23-go-language-specification","title":"2.3 Go Language Specification","text":"<p>oastools targets Go 1.24+ and leverages language features accordingly. The toolkit uses generics for type-safe operations where appropriate, Go 1.24 benchmark patterns with <code>b.Loop()</code> for accurate performance measurement, and standard library patterns for HTTP handling that integrate with <code>net/http</code>. The generator package produces code compatible with Go 1.18+ when using generics for optional types.</p>"},{"location":"whitepaper/#24-related-rfcs","title":"2.4 Related RFCs","text":"<p>The toolkit implements or references several IETF RFCs. RFC 9535 (JSONPath) provides the query language for overlay targeting. RFC 7636 (PKCE) is implemented in OAuth2 code generation for secure authorization flows. RFC 6749 (OAuth 2.0) is the foundation for security scheme code generation. RFC 3986 (URIs) governs reference resolution and URL handling. RFC 6570 (URI Templates) underlies path parameter serialization.</p>"},{"location":"whitepaper/#3-package-architecture","title":"3. Package Architecture","text":"<p>oastools comprises twelve public packages, each with a focused responsibility and clear integration points.</p> <pre><code>oastools/\n\u251c\u2500\u2500 parser/         # Parse OAS documents from files, URLs, readers, or bytes\n\u251c\u2500\u2500 validator/      # Validate documents against their declared OAS version\n\u251c\u2500\u2500 fixer/          # Automatically fix common validation errors\n\u251c\u2500\u2500 httpvalidator/  # Runtime HTTP request/response validation\n\u251c\u2500\u2500 converter/      # Convert between OAS versions (2.0 \u2194 3.x)\n\u251c\u2500\u2500 joiner/         # Merge multiple OAS documents with collision handling\n\u251c\u2500\u2500 overlay/        # Apply OpenAPI Overlay transformations\n\u251c\u2500\u2500 differ/         # Compare documents, detect breaking changes\n\u251c\u2500\u2500 generator/      # Generate Go client/server code with security support\n\u251c\u2500\u2500 builder/        # Programmatically construct OAS documents\n\u251c\u2500\u2500 walker/         # Traverse OAS documents with typed handlers and flow control\n\u251c\u2500\u2500 oaserrors/      # Structured error types for programmatic handling\n\u2514\u2500\u2500 internal/       # Internal utilities (not public API)\n    \u251c\u2500\u2500 mcpserver/  # MCP server exposing all capabilities over stdio\n    \u251c\u2500\u2500 httputil/   # HTTP constants and validation\n    \u251c\u2500\u2500 severity/   # Issue severity levels\n    \u251c\u2500\u2500 issues/     # Unified issue reporting\n    \u251c\u2500\u2500 schemautil/ # Schema utilities\n    \u251c\u2500\u2500 jsonpath/   # JSONPath RFC 9535 implementation\n    \u251c\u2500\u2500 corpusutil/ # Test corpus management\n    \u2514\u2500\u2500 testutil/   # Test helpers\n</code></pre>"},{"location":"whitepaper/#package-relationships","title":"Package Relationships","text":"<pre><code>flowchart TB\n    subgraph Input[\"\ud83d\udce5 Input Sources\"]\n        File[File Path]\n        URL[URL]\n        Reader[io.Reader]\n        Bytes[Byte Slice]\n    end\n\n    subgraph Core[\"\ud83d\udd27 Core Processing\"]\n        Parser[parser&lt;br/&gt;ParseResult]\n        Validator[validator]\n        Fixer[fixer]\n        Converter[converter]\n    end\n\n    subgraph Transform[\"\ud83d\udd04 Transformation\"]\n        Joiner[joiner]\n        Overlay[overlay]\n        Differ[differ]\n        Walker[walker]\n    end\n\n    subgraph Output[\"\ud83d\udce4 Output\"]\n        Generator[generator&lt;br/&gt;Go Code]\n        Builder[builder&lt;br/&gt;OAS Document]\n        HTTPValidator[httpvalidator&lt;br/&gt;Runtime Validation]\n    end\n\n    subgraph Integration[\"\ud83c\udf10 Integration\"]\n        MCPServer[MCP Server&lt;br/&gt;AI Tooling]\n    end\n\n    subgraph Shared[\"\ud83d\udd17 Shared\"]\n        OASErrors[oaserrors]\n    end\n\n    File --&gt; Parser\n    URL --&gt; Parser\n    Reader --&gt; Parser\n    Bytes --&gt; Parser\n\n    Parser --&gt; Validator\n    Parser --&gt; Fixer\n    Parser --&gt; Converter\n    Parser --&gt; Joiner\n    Parser --&gt; Overlay\n    Parser --&gt; Differ\n    Parser --&gt; Walker\n    Parser --&gt; Generator\n    Parser --&gt; HTTPValidator\n    Parser --&gt; MCPServer\n\n    Builder --&gt; Parser\n\n    OASErrors -.-&gt; Core\n    OASErrors -.-&gt; Transform\n    OASErrors -.-&gt; Output\n\n    style Parser fill:#4db6ac,color:#000\n    style OASErrors fill:#ff8a65,color:#000\n    style MCPServer fill:#7986cb,color:#000</code></pre> <p>The packages form a coherent processing pipeline. The parser sits at the foundation, providing <code>ParseResult</code> structures consumed by all other packages. The validator depends on parser output for structural and semantic validation. The fixer uses parser output and can optionally leverage validator feedback for targeted fixes. The converter transforms parser output between OAS versions. The joiner combines multiple <code>ParseResult</code> instances into a unified document. The overlay applies transformations to parser output using JSONPath targeting. The differ compares two <code>ParseResult</code> instances to detect changes. The walker traverses parser output with typed handlers for analysis, mutation, and filtering. The generator produces Go code from parser output. The builder constructs documents programmatically, producing output compatible with parser structures. The httpvalidator uses parser output to validate runtime HTTP traffic. The oaserrors package provides error types used throughout all other packages.</p>"},{"location":"whitepaper/#format-preservation","title":"Format Preservation","text":"<p>A critical feature is format preservation across the pipeline. The parser detects source format (JSON or YAML) from file extension or content inspection and stores it in <code>ParseResult.SourceFormat</code>. This format flows through converter, joiner, and fixer operations, ensuring output matches input format. When joining multiple documents, the first document's format determines output format.</p>"},{"location":"whitepaper/#package-chaining","title":"Package Chaining","text":"<p>oastools packages are designed for seamless composition. Each package's result type provides a <code>ToParseResult()</code> method, enabling fluid pipelines without manual rewrapping:</p> <pre><code>result, err := parser.ParseWithOptions(parser.WithFilePath(\"spec.yaml\"))\nif err != nil { return err }\n\n// Chain through the entire toolchain without losing context\nvalidated, err := validator.ValidateWithOptions(validator.WithParsed(*result))\nif err != nil { return err }\nfixed, err := fixer.FixWithOptions(fixer.WithParsed(*validated.ToParseResult()))\nif err != nil { return err }\nconverted, err := converter.ConvertWithOptions(\n    converter.WithParsed(*fixed.ToParseResult()),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\nif err != nil { return err }\njoined, err := joiner.JoinWithOptions(\n    joiner.WithParsed(*converted.ToParseResult(), *other.ToParseResult()),\n)\nif err != nil { return err }\n</code></pre> Package Result Type Provides ToParseResult() validator <code>ValidationResult</code> v1.41.0 fixer <code>FixResult</code> v1.41.0 converter <code>ConversionResult</code> v1.40.0 joiner <code>JoinResult</code> v1.40.0 overlay <code>ApplyResult</code> v1.41.0 <p>This pattern eliminates boilerplate and preserves metadata (source path, OAS version, parse options) throughout the pipeline.</p>"},{"location":"whitepaper/#4-parser-package","title":"4. Parser Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The parser package forms the foundation of oastools, providing comprehensive parsing for OpenAPI documents across all supported versions.</p>"},{"location":"whitepaper/#41-core-capabilities","title":"4.1 Core Capabilities","text":"<p>The parser offers automatic version detection by examining the <code>openapi</code> or <code>swagger</code> field to determine version and select appropriate parsing strategy. It supports format detection through file extension inspection, content analysis (JSON starts with <code>{</code> or <code>[</code>), and falls back to YAML when uncertain. Multiple input sources are supported, including local file paths, remote URLs (with security controls), <code>io.Reader</code> implementations, and raw byte slices.</p>"},{"location":"whitepaper/#42-reference-resolution","title":"4.2 Reference Resolution","text":"<p>Reference handling is central to OpenAPI processing. The parser supports three reference types with distinct security profiles.</p> <p>Local references (<code>#/components/schemas/User</code>) point within the same document and are always resolved. File references (<code>./common.yaml#/schemas/Error</code>) point to external files and are resolved with path traversal protection. HTTP references (<code>https://example.com/schemas.yaml</code>) point to remote URLs and require explicit opt-in via <code>WithResolveHTTPRefs(true)</code>.</p> <p>Circular Reference Handling:</p> <p>When circular references are detected, the <code>$ref</code> node remains unresolved (preserving the original reference), a warning is added to <code>result.Warnings</code>, and the document remains valid for most operations. Detection triggers when a <code>$ref</code> points to an ancestor in the resolution path or when resolution depth exceeds <code>MaxRefDepth</code>.</p>"},{"location":"whitepaper/#43-resource-limits","title":"4.3 Resource Limits","text":"<p>Configurable limits protect against resource exhaustion attacks.</p> Limit Default Description <code>MaxRefDepth</code> 100 Maximum nested <code>$ref</code> resolution depth <code>MaxCachedDocuments</code> 100 Maximum external documents to cache <code>MaxFileSize</code> 10MB Maximum file size for external references"},{"location":"whitepaper/#44-json-fast-path-v1470","title":"4.4 \u26a1 JSON Fast-Path (v1.47.0+)","text":"<p>When parsing JSON input, the parser automatically uses an optimized fast-path that bypasses YAML AST overhead. This provides dramatic performance improvements for JSON specifications.</p> <p>Automatic Triggering Conditions:</p> <p>The fast-path activates when all conditions are met:</p> <ul> <li>\u2705 Input is detected as JSON format</li> <li>\u2705 Source map building is disabled (<code>WithSourceMap(false)</code>)</li> <li>\u2705 Order preservation is disabled (<code>WithPreserveOrder(false)</code>)</li> </ul> <p>Performance Improvements:</p> Metric Standard Path JSON Fast-Path Improvement Parse time (large specs) ~2.5s ~0.3s ~88% reduction Memory allocation ~750MB ~50MB ~93% reduction <p>Why This Matters:</p> <p>The yaml.v4 library builds a complete Abstract Syntax Tree with comprehensive token tracking. While necessary for YAML features (anchors, aliases, multiline strings), this is wasteful for JSON input where <code>encoding/json</code> is more efficient.</p> <pre><code>// Automatically uses fast-path (JSON input, no source map)\nresult, err := parser.ParseWithOptions(\n    parser.WithBytes(jsonData),\n)\n\n// Bypasses fast-path (source map requires YAML AST tracking)\nresult, err := parser.ParseWithOptions(\n    parser.WithBytes(jsonData),\n    parser.WithSourceMap(true),\n)\n</code></pre>"},{"location":"whitepaper/#45-api-usage","title":"4.5 API Usage","text":"<p>Functional Options Pattern:</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"api.yaml\"),\n    parser.WithResolveRefs(true),\n    parser.WithSourceMap(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Parsed %s, version %s\\n\", result.SourcePath, result.OASVersion)\n</code></pre> <p>Struct-Based Pattern:</p> <pre><code>p := parser.New()\np.ResolveRefs = true\np.ValidateStructure = true\n\nresult1, _ := p.Parse(\"api1.yaml\")\nresult2, _ := p.Parse(\"api2.yaml\")\n</code></pre>"},{"location":"whitepaper/#46-parseresult-structure","title":"4.6 ParseResult Structure","text":"<p>The <code>ParseResult</code> type contains all parsed information.</p> <pre><code>type ParseResult struct {\n    // Document contains the parsed document (version-specific type)\n    Document any\n\n    // Version-specific accessors (methods, not fields)\n    // doc2, ok := result.OAS2Document()  // Returns (*OAS2Document, bool)\n    // doc3, ok := result.OAS3Document()  // Returns (*OAS3Document, bool)\n\n    // Metadata\n    Version      string         // Raw version string from document\n    OASVersion   OASVersion     // Detected version (e.g., \"3.1.0\")\n    SourcePath   string         // Source file path\n    SourceFormat SourceFormat   // JSON or YAML\n\n    // Optional features\n    SourceMap    *SourceMap     // Line/column mapping (if enabled)\n    Warnings     []string       // Non-fatal warnings\n    Errors       []error        // Parse errors\n}\n</code></pre>"},{"location":"whitepaper/#47-type-safe-cloning","title":"4.7 Type-Safe Cloning","text":"<p>All parser types include generated <code>DeepCopy()</code> methods for safe mutation.</p> <pre><code>original, _ := result.OAS3Document()\ncopy := original.DeepCopy()\ncopy.Info.Title = \"Modified API\"\n// original.Info.Title unchanged\n</code></pre>"},{"location":"whitepaper/#48-streaming-extension-extraction-v1490","title":"4.8 Streaming Extension Extraction (v1.49.0+)","text":"<p>Vendor extension extraction (<code>x-*</code> fields) now uses a streaming fast-path. A <code>bytes.Contains</code> check for <code>\"x-</code> is performed before any JSON parsing, eliminating allocations entirely when no extensions are present. This optimization provides a 15x speedup for the common case (most specifications have few or no vendor extensions at the document level).</p>"},{"location":"whitepaper/#49-direct-map-to-struct-decoding-v1510","title":"4.9 Direct Map-to-Struct Decoding (v1.51.0+)","text":"<p>Reference resolution previously used a <code>map \u2192 JSON bytes \u2192 struct</code> roundtrip, which doubled peak memory during <code>ResolveRefs=true</code>. A new code-generated <code>decodeFromMap</code> approach decodes <code>map[string]any</code> values directly to typed structs for all 29 OAS types, eliminating the intermediate <code>[]byte</code> allocation.</p> <p>A companion <code>ShallowCopy</code> optimization on the <code>RefResolver</code> skips deep copy for non-circular references. When circular references are detected, the resolver automatically falls back to a full deep copy to avoid Go pointer cycles. Together these changes significantly reduce memory usage when resolving references in large specifications.</p> <p>Unlike JSON marshal/unmarshal approaches, <code>DeepCopy()</code> preserves type information for polymorphic fields like <code>Schema.Type</code> (which may be <code>string</code> or <code>[]string</code> in OAS 3.1+), version-specific semantics such as <code>ExclusiveMinimum</code> representation, and all <code>x-*</code> extension fields.</p>"},{"location":"whitepaper/#410-documentaccessor-interface","title":"4.10 DocumentAccessor Interface","text":"<p>The <code>DocumentAccessor</code> interface provides version-agnostic access to common document fields across OAS 2.0 and OAS 3.x documents, eliminating the need for version-specific type switches.</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\naccessor := result.AsAccessor()\n\n// Works identically for OAS 2.0 and 3.x\nfor path := range accessor.GetPaths() {\n    fmt.Println(\"Path:\", path)\n}\nfor name := range accessor.GetSchemas() {\n    fmt.Println(\"Schema:\", name)\n}\nfmt.Println(\"Ref prefix:\", accessor.SchemaRefPrefix())\n</code></pre> <p>Available Methods:</p> Method OAS 2.0 Source OAS 3.x Source <code>GetInfo()</code> <code>doc.Info</code> <code>doc.Info</code> <code>GetPaths()</code> <code>doc.Paths</code> <code>doc.Paths</code> <code>GetSchemas()</code> <code>doc.Definitions</code> <code>doc.Components.Schemas</code> <code>GetSecuritySchemes()</code> <code>doc.SecurityDefinitions</code> <code>doc.Components.SecuritySchemes</code> <code>GetParameters()</code> <code>doc.Parameters</code> <code>doc.Components.Parameters</code> <code>GetResponses()</code> <code>doc.Responses</code> <code>doc.Components.Responses</code> <code>GetVersion()</code> <code>doc.OASVersion</code> <code>doc.OASVersion</code> <code>SchemaRefPrefix()</code> <code>#/definitions/</code> <code>#/components/schemas/</code> <p>This abstraction is particularly useful for tooling that needs to operate on documents regardless of their OAS version.</p>"},{"location":"whitepaper/#structural-comparison","title":"Structural Comparison","text":"<p>Key document types (<code>OAS2Document</code>, <code>OAS3Document</code>, <code>Schema</code>, <code>ParseResult</code>) provide <code>Equals()</code> methods for deep structural comparison:</p> <pre><code>if doc1.Equals(doc2) {\n    fmt.Println(\"Documents are structurally identical\")\n}\n</code></pre> <p>This is useful for detecting changes, caching decisions, and test assertions.</p>"},{"location":"whitepaper/#deterministic-output","title":"Deterministic Output","text":"<p>The <code>MarshalOrderedJSON()</code> and <code>MarshalOrderedYAML()</code> methods on <code>*ParseResult</code> produce deterministic output by preserving key order. This ensures:</p> <ul> <li>Reproducible diffs between versions</li> <li>Consistent output for CI/CD pipelines</li> <li>Predictable test snapshots</li> </ul>"},{"location":"whitepaper/#5-validator-package","title":"5. Validator Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The validator package ensures OpenAPI documents conform to their declared specification version, catching structural errors and semantic violations.</p>"},{"location":"whitepaper/#51-validation-modes","title":"5.1 Validation Modes","text":"<p>Structural Validation verifies required fields are present, types are correct per specification, format constraints are satisfied, and reference targets exist.</p> <p>Semantic Validation ensures operationIds are unique across the document, HTTP status codes are valid, parameter names are unique per location, and security scheme references exist in components.</p> <p>Strict Mode performs additional checks including flagging non-standard HTTP status codes, requiring at least one success response (2xx) per operation, and detecting deprecated feature usage.</p>"},{"location":"whitepaper/#52-api-usage","title":"5.2 API Usage","text":"<pre><code>// Functional options with file path\nresult, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"api.yaml\"),\n    validator.WithStrictMode(true),\n)\n\n// Pre-parsed for performance (31x faster)\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nresult, err := validator.ValidateWithOptions(\n    validator.WithParsed(*parsed),\n    validator.WithStrictMode(true),\n)\n\nif !result.Valid {\n    for _, e := range result.Errors {\n        fmt.Printf(\"Error at %s: %s\\n\", e.Path, e.Message)\n    }\n}\n</code></pre>"},{"location":"whitepaper/#53-validation-result","title":"5.3 Validation Result","text":"<pre><code>type ValidationResult struct {\n    Valid         bool              // Overall validity\n    Errors        []ValidationError // Errors (spec violations)\n    Warnings      []ValidationError // Warnings (best practice)\n    ErrorCount    int\n    WarningCount  int\n    Version       string\n    OASVersion    parser.OASVersion\n}\n\ntype ValidationError struct {\n    Path             string                   // JSON path to error location\n    Message          string                   // Human-readable description\n    Severity         severity.Severity        // Error, Warning, or Info\n    SpecRef          string                   // URL to relevant spec section\n    Line             int                      // Line number (if source map enabled)\n    Column           int                      // Column number (if source map enabled)\n    File             string                   // File path (if source map enabled)\n    OperationContext *issues.OperationContext // API operation context (v1.46.0+)\n}\n</code></pre>"},{"location":"whitepaper/#54-source-map-integration","title":"5.4 Source Map Integration","text":"<p>When parsing with <code>WithSourceMap(true)</code>, validation errors include precise location information.</p> <pre><code>parsed, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"api.yaml\"),\n    parser.WithSourceMap(true),\n)\nresult, _ := validator.ValidateWithOptions(\n    validator.WithParsed(*parsed),\n)\n\nfor _, e := range result.Errors {\n    fmt.Printf(\"%s:%d:%d: %s\\n\", e.File, e.Line, e.Column, e.Message)\n}\n</code></pre>"},{"location":"whitepaper/#55-cli-integration","title":"5.5 CLI Integration","text":"<p>The <code>--validate-structure</code> CLI flag controls parser validation behavior, enabling strict structural validation during parsing.</p>"},{"location":"whitepaper/#56-operation-context-v1460","title":"5.6 Operation Context (v1.46.0+)","text":"<p>Validation errors now include operation context, making it easy to identify which API endpoint triggered each error. The <code>OperationContext</code> field provides the HTTP method, path, and operationId.</p> <pre><code>result, _ := validator.ValidateWithOptions(\n    validator.WithParsed(*parsed),\n)\n\nfor _, e := range result.Errors {\n    if e.OperationContext != nil {\n        fmt.Printf(\"%s %s (%s): %s\\n\",\n            e.OperationContext.Method,\n            e.OperationContext.Path,\n            e.OperationContext.OperationID,\n            e.Message)\n    }\n}\n// Output: GET /users/{userId} (getUser): missing path parameter \"userId\"\n</code></pre>"},{"location":"whitepaper/#6-fixer-package","title":"6. Fixer Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The fixer package automatically corrects common validation errors, reducing manual intervention in API specification maintenance.</p>"},{"location":"whitepaper/#61-supported-fix-types","title":"6.1 Supported Fix Types","text":"<p>Missing Path Parameters (FixTypeMissingPathParameter): When a path template contains variables like <code>/users/{userId}</code> but the operation lacks a corresponding parameter declaration, the fixer adds one. Type inference can be enabled to assign appropriate types based on naming conventions.</p> <p>Invalid Schema Names (FixTypeRenamedGenericSchema): Schemas with names containing URL-encoding-required characters (such as <code>Response[User]</code> from code generators) are renamed using configurable strategies. All <code>$ref</code> values throughout the document are updated accordingly.</p> <p>Unused Schemas (FixTypePrunedUnusedSchema): Schema definitions not referenced anywhere in the document are removed, cleaning up orphaned definitions.</p> <p>Empty Paths (FixTypePrunedEmptyPath): Path items with no HTTP operations (only parameters or extensions) are removed.</p> <p>Missing Reference Targets (FixTypeStubMissingRef, v1.46.0+): When a <code>$ref</code> points to a non-existent schema or response definition, the fixer creates a stub placeholder to prevent validation errors. Stub descriptions are configurable via <code>WithStubConfig()</code> or <code>WithStubResponseDescription()</code>.</p>"},{"location":"whitepaper/#62-default-behavior","title":"6.2 Default Behavior","text":"<p>For performance, only <code>FixTypeMissingPathParameter</code> is enabled by default. Schema renaming and pruning involve expensive operations (walking all references, computing unused schemas) that can significantly slow processing of large specifications.</p>"},{"location":"whitepaper/#63-type-inference","title":"6.3 Type Inference","text":"<p>When enabled, the fixer infers parameter types from naming conventions.</p> Pattern Inferred Type Format <code>*id</code>, <code>*Id</code>, <code>*ID</code> integer - <code>*uuid</code>, <code>*guid</code> string uuid Everything else string -"},{"location":"whitepaper/#64-generic-naming-strategies","title":"6.4 Generic Naming Strategies","text":"<p>When fixing invalid schema names, several strategies are available.</p> Strategy Example Input Example Output <code>GenericNamingUnderscore</code> <code>Response[User]</code> <code>Response_User_</code> <code>GenericNamingOf</code> <code>Response[User]</code> <code>ResponseOfUser</code> <code>GenericNamingFor</code> <code>Response[User]</code> <code>ResponseForUser</code> <code>GenericNamingFlattened</code> <code>Response[User]</code> <code>ResponseUser</code> <code>GenericNamingDot</code> <code>Response[User]</code> <code>Response.User</code>"},{"location":"whitepaper/#65-api-usage","title":"6.5 API Usage","text":"<pre><code>// Enable specific fixes\nresult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"api.yaml\"),\n    fixer.WithEnabledFixes(\n        fixer.FixTypeMissingPathParameter,\n        fixer.FixTypeRenamedGenericSchema,\n        fixer.FixTypePrunedUnusedSchema,\n    ),\n    fixer.WithInferTypes(true),\n    fixer.WithGenericNaming(fixer.GenericNamingOf),\n)\n\nfmt.Printf(\"Applied %d fixes\\n\", result.FixCount)\nfor _, fix := range result.Fixes {\n    fmt.Printf(\"  %s at %s\\n\", fix.Type, fix.Path)\n}\n</code></pre>"},{"location":"whitepaper/#66-duplicate-operationid-detection","title":"6.6 Duplicate OperationId Detection","text":"<p>The fixer detects duplicate <code>operationId</code> values and automatically generates unique replacements, preventing spec validation failures.</p>"},{"location":"whitepaper/#67-csv-enum-expansion","title":"6.7 CSV Enum Expansion","text":"<p>Enum values specified as comma-separated strings are automatically expanded to proper typed arrays.</p>"},{"location":"whitepaper/#68-mutable-input-mode-v1480","title":"6.8 \u26a0\ufe0f Mutable Input Mode (v1.48.0+)","text":"<p>For performance-critical scenarios, <code>WithMutableInput(true)</code> skips the defensive deep copy of the input document. This is particularly useful when chaining multiple fix passes.</p> <p>When to Use:</p> <ul> <li>\u2705 Chaining multiple fixer passes (the first pass already creates a fresh copy)</li> <li>\u2705 Memory efficiency is critical for large specifications</li> <li>\u2705 You've already copied the document for your own mutations</li> </ul> <p>Warning: \u26a0\ufe0f When enabled, the input document will be mutated directly. Do not use the original document after calling <code>FixWithOptions</code>.</p> <pre><code>// First pass: creates a defensive copy (default behavior)\npass1, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*parseResult),\n    fixer.WithEnabledFixes(fixer.FixTypeMissingPathParameter),\n)\n\n// Second pass: skip copy since we already own pass1's document\npass2, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*pass1.ToParseResult()),\n    fixer.WithMutableInput(true),  // Skip defensive copy\n    fixer.WithEnabledFixes(fixer.FixTypePrunedUnusedSchema),\n)\n</code></pre> <p>Performance: Typical memory savings of 10-30% for large specifications during fix operations.</p>"},{"location":"whitepaper/#7-converter-package","title":"7. Converter Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The converter package transforms OpenAPI documents between versions, handling the significant structural differences between OAS 2.0 and OAS 3.x.</p>"},{"location":"whitepaper/#71-supported-conversions","title":"7.1 Supported Conversions","text":"From To Notes OAS 2.0 OAS 3.0.x Full upgrade with structural transformation OAS 2.0 OAS 3.1.x Includes JSON Schema 2020-12 alignment OAS 3.x OAS 2.0 Downgrade with potential feature loss OAS 3.0.x OAS 3.1.x Version update within 3.x family OAS 3.1.x OAS 3.0.x Version downgrade with schema adjustments"},{"location":"whitepaper/#72-key-transformations","title":"7.2 Key Transformations","text":"<p>OAS 2.0 \u2192 OAS 3.x:</p> <p>The conversion handles structural changes between versions. The <code>host</code>, <code>basePath</code>, and <code>schemes</code> fields become the <code>servers</code> array. The <code>consumes</code>/<code>produces</code> fields and <code>body</code> parameter combine into <code>requestBody</code> with <code>content</code> map. The <code>securityDefinitions</code> becomes <code>components/securitySchemes</code> with restructured OAuth2 flows. The <code>definitions</code> section becomes <code>components/schemas</code>.</p> <p>OAS 3.x \u2192 OAS 2.0:</p> <p>Downgrade conversions handle feature reduction. Multiple servers collapse to <code>host</code> and <code>basePath</code>. The <code>requestBody</code> becomes a <code>body</code> parameter. Features without OAS 2.0 equivalents (callbacks, links) generate warnings.</p> <p>Enhanced Downgrade Detection (v1.49.0+):</p> <p>The converter now detects additional OAS 3.x features that cannot be faithfully represented in OAS 2.0, reporting them as issues with appropriate severity levels:</p> Feature Severity Reason Webhooks (3.1+) Critical No OAS 2.0 equivalent Server variables Warning Extracted but incompatible Multiple servers Warning Only first server used Callbacks Critical No OAS 2.0 equivalent Links Warning No OAS 2.0 equivalent (not yet detected -- planned)"},{"location":"whitepaper/#73-issue-tracking","title":"7.3 Issue Tracking","text":"<p>Conversions may produce issues at different severity levels.</p> <p>Critical: The conversion cannot be completed accurately, such as when incompatible features block conversion.</p> <p>Warning: Information may be lost, such as when multiple servers are collapsed to one or callbacks are removed.</p> <p>Info: Structural changes were applied, such as when a security scheme was restructured.</p>"},{"location":"whitepaper/#74-api-usage","title":"7.4 API Usage","text":"<pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\n\nfor _, issue := range result.Issues {\n    fmt.Printf(\"[%s] %s: %s\\n\", issue.Severity, issue.Path, issue.Message)\n}\n</code></pre>"},{"location":"whitepaper/#8-joiner-package","title":"8. Joiner Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The joiner package merges multiple OpenAPI documents into a single unified specification, handling collisions and maintaining referential integrity.</p>"},{"location":"whitepaper/#81-collision-strategies","title":"8.1 Collision Strategies","text":"<p>When joining documents, name collisions may occur in schemas, paths, or other components. The joiner provides configurable strategies.</p> Strategy Behavior <code>StrategyFailOnCollision</code> Error immediately on any collision (default) <code>StrategyAcceptLeft</code> Keep the first (left) definition <code>StrategyAcceptRight</code> Keep the last (right) definition <code>StrategyRenameLeft</code> Rename conflicting item from left document <code>StrategyRenameRight</code> Rename conflicting item from right document <code>StrategyDeduplicateEquivalent</code> Keep one if structurally identical, error if different <code>StrategyFailOnPaths</code> Error only on path collisions, accept others"},{"location":"whitepaper/#82-semantic-deduplication","title":"8.2 Semantic Deduplication","text":"<p>The <code>StrategyDeduplicateEquivalent</code> strategy performs deep structural comparison. Two schemas are considered equivalent if they have identical types, properties, required fields, and constraints. When equivalent schemas are found, one is kept and all references are updated to point to the surviving definition. Empty schemas (those with no properties, type, or constraints) are correctly preserved during deduplication rather than being collapsed (fixed in v1.46.2).</p>"},{"location":"whitepaper/#83-reference-rewriting","title":"8.3 Reference Rewriting","text":"<p>When schemas are renamed (via <code>StrategyRenameLeft</code> or <code>StrategyRenameRight</code>), the joiner automatically updates all <code>$ref</code> values throughout the merged document. This includes references in other schemas, request bodies, responses, parameters, and anywhere else references may appear.</p>"},{"location":"whitepaper/#84-array-merging","title":"8.4 Array Merging","text":"<p>Arrays like <code>servers</code>, <code>security</code>, and <code>tags</code> are merged according to configurable strategies.</p> <pre><code>config := joiner.DefaultConfig()\nconfig.MergeArrays = true    // Combine server, security, and tag arrays\n</code></pre>"},{"location":"whitepaper/#85-overlay-integration","title":"8.5 Overlay Integration","text":"<p>The joiner integrates with the overlay package for transformations at different stages.</p> <p>Pre-Join Overlays are applied to each input document before joining.</p> <p>Post-Join Overlays are applied to the merged result.</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"api1.yaml\", \"api2.yaml\"),\n    joiner.WithPreJoinOverlayFile(\"standardize.yaml\"),\n    joiner.WithPostJoinOverlayFile(\"finalize.yaml\"),\n)\n</code></pre>"},{"location":"whitepaper/#86-operation-aware-renaming","title":"8.6 Operation-Aware Renaming","text":"<p>When schemas collide during joining, simple source-based renaming (e.g., <code>User_users</code>) can produce unclear names that obscure the schema's purpose. Operation-aware renaming traces schemas back to their originating operations, enabling semantic names like <code>CreateUserRequest</code> or <code>GetPetResponse</code> that reflect how schemas are actually used.</p> <p>Enabling Operation Context:</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users.yaml\", \"orders.yaml\"),\n    joiner.WithSchemaStrategy(joiner.StrategyRenameRight),\n    joiner.WithOperationContext(true),\n    joiner.WithRenameTemplate(\"{{.OperationID | pascalCase}}{{.Name}}\"),\n)\n</code></pre> <p>Reference Graph Building:</p> <p>When <code>WithOperationContext(true)</code> is enabled, the joiner builds a reference graph that traces schema relationships:</p> <ol> <li>Direct references - Schemas referenced directly by operations (request bodies, responses, parameters)</li> <li>Indirect references - Schemas referenced through intermediate schemas (e.g., <code>Order</code> references <code>Address</code>)</li> <li>Lineage resolution - Traverses the graph to find all operations that ultimately use each schema</li> </ol> <p>This graph enables rename templates to access operation context even for deeply nested schemas.</p> <p>Template Functions:</p> Category Functions Description Path <code>pathSegment</code>, <code>pathResource</code>, <code>pathLast</code>, <code>pathClean</code> Extract and transform API path components Case <code>pascalCase</code>, <code>camelCase</code>, <code>snakeCase</code>, <code>kebabCase</code> Transform string casing Tag <code>firstTag</code>, <code>joinTags</code>, <code>hasTag</code> Work with operation tags Conditional <code>default</code>, <code>coalesce</code> Fallback value selection <p>Template Examples:</p> <pre><code>// Use operationId when available, fall back to path resource\n\"{{coalesce .OperationID (pathResource .Path) .Source | pascalCase}}{{.Name}}\"\n\n// Include usage type for clarity\n\"{{.OperationID | pascalCase}}{{.UsageType | pascalCase}}{{.Name}}\"\n\n// Path-based naming when operationIds are inconsistent\n\"{{pathResource .Path | pascalCase}}{{.Name}}\"\n</code></pre> <p>Primary Operation Policy:</p> <p>When a schema is referenced by multiple operations, the <code>PrimaryOperationPolicy</code> determines which operation provides context:</p> Policy Behavior <code>PolicyFirstEncountered</code> Uses the first operation found during traversal (default) <code>PolicyMostSpecific</code> Prefers operations with <code>operationId</code>, then tags <code>PolicyAlphabetical</code> Sorts by path+method and uses first alphabetically <pre><code>joiner.WithPrimaryOperationPolicy(joiner.PolicyMostSpecific)\n</code></pre> <p>Deep Dive: For comprehensive <code>RenameContext</code> documentation including all available fields, aggregate context for shared schemas, and advanced template patterns, see the Joiner Deep Dive.</p>"},{"location":"whitepaper/#87-api-usage","title":"8.7 API Usage","text":"<pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users.yaml\", \"orders.yaml\", \"products.yaml\"),\n    joiner.WithPathStrategy(joiner.StrategyAcceptLeft),\n    joiner.WithSchemaStrategy(joiner.StrategyDeduplicateEquivalent),\n)\n\nfmt.Printf(\"Joined documents into %d paths\\n\",\n    result.Stats.PathCount)\n</code></pre>"},{"location":"whitepaper/#88-source-name-warnings","title":"8.8 Source Name Warnings","text":"<p>Collision messages now include source file names for easier debugging when joining multiple specs.</p>"},{"location":"whitepaper/#89-collision-handler-callbacks-v1470","title":"8.9 \ud83d\udd27 Collision Handler Callbacks (v1.47.0+)","text":"<p>For advanced use cases, custom collision handlers enable programmatic control over collision resolution. Handlers receive full context about each collision and can return custom resolution actions.</p> <p>Collision Context:</p> <pre><code>type CollisionContext struct {\n    Type               CollisionType    // schema, path, webhook, etc.\n    Name               string           // The colliding name (e.g., \"User\")\n    JSONPath           string           // Full path (e.g., \"$.components.schemas.User\")\n    LeftSource         string           // Source file for left document\n    LeftValue          any              // The left component (*parser.Schema, etc.)\n    RightSource        string           // Source file for right document\n    RightValue         any              // The right component\n    ConfiguredStrategy CollisionStrategy // Default strategy that would apply\n}\n</code></pre> <p>Resolution Actions:</p> Action Behavior <code>ResolutionContinue</code> Defer to configured strategy (observe-only) <code>ResolutionAcceptLeft</code> Keep the left (base) value <code>ResolutionAcceptRight</code> Keep the right (incoming) value <code>ResolutionRename</code> Rename the right value (schemas only) <code>ResolutionDeduplicate</code> Treat colliding values as equivalent <code>ResolutionFail</code> Abort the join with an error <code>ResolutionCustom</code> Use a caller-provided merged value <p>Usage Pattern:</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"overlay.yaml\"),\n    joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n        // Log all collisions for auditing\n        log.Printf(\"Collision: %s %s\", collision.Type, collision.Name)\n\n        // Custom logic for schema collisions\n        if collision.Type == joiner.CollisionTypeSchema {\n            merged := customMergeLogic(collision.LeftValue, collision.RightValue)\n            return joiner.UseCustomValue(merged), nil\n        }\n\n        // Defer to strategy for other types\n        return joiner.ContinueWithStrategy(), nil\n    }),\n)\n</code></pre> <p>Use Cases:</p> <ul> <li>Semantic schema deduplication with custom logic</li> <li>Collision detection and auditing pipelines</li> <li>Domain-specific resolution (e.g., API versioning strategies)</li> </ul>"},{"location":"whitepaper/#9-overlay-package","title":"9. Overlay Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The overlay package implements the OpenAPI Overlay Specification v1.0.0, enabling declarative transformations of OpenAPI documents.</p>"},{"location":"whitepaper/#91-overlay-structure","title":"9.1 Overlay Structure","text":"<p>An overlay document contains metadata and a sequence of actions.</p> <pre><code>overlay: \"1.0.0\"\ninfo:\n  title: Production Configuration\n  version: \"1.0.0\"\nextends: openapi.yaml  # Optional: target document\nactions:\n  - target: $.info\n    update:\n      x-environment: production\n  - target: $.servers[?(@.description == 'Development')]\n    remove: true\n</code></pre>"},{"location":"whitepaper/#92-action-types","title":"9.2 Action Types","text":"<p>Update Actions merge content at the target location.</p> <p>When updating objects, properties from the overlay are merged with the target, with overlay values taking precedence for conflicting keys.</p> <p>When updating arrays, the update value is appended to the target array.</p> <p>Remove Actions delete nodes at the target location.</p> <pre><code>actions:\n  - target: $.paths['/internal/*']\n    remove: true\n</code></pre>"},{"location":"whitepaper/#93-jsonpath-support","title":"9.3 JSONPath Support","text":"<p>The overlay package implements JSONPath per RFC 9535 with comprehensive feature support.</p> <p>Supported Syntax:</p> Expression Description Example <code>$</code> Root object <code>$</code> <code>.property</code> Child access <code>$.info.title</code> <code>[name]</code> Bracket notation <code>$.paths['/users']</code> <code>*</code> Wildcard <code>$.paths.*</code> <code>[0]</code> Array index <code>$.servers[0]</code> <code>[-1]</code> Negative index <code>$.tags[-1]</code> <code>[0:3]</code> Slice <code>$.servers[0:3]</code> <code>..</code> Recursive descent <code>$..schema</code> <code>[?()]</code> Filter expression <code>$.paths.*[?(@.deprecated == true)]</code> <p>Filter Operators:</p> <p>Comparison operators include <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. Logical operators include <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (not). Existence checks use <code>@.property</code> to test if property exists.</p>"},{"location":"whitepaper/#94-dry-run-mode","title":"9.4 Dry-Run Mode","text":"<p>Preview changes without applying them.</p> <pre><code>dryRun, err := overlay.DryRunWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\n\nfor _, change := range dryRun.Changes {\n    fmt.Printf(\"Would %s %d nodes at %s\\n\",\n        change.Operation, change.MatchCount, change.Target)\n}\n</code></pre>"},{"location":"whitepaper/#95-strict-targets","title":"9.5 Strict Targets","text":"<p>Enable strict mode to fail when targets match no nodes.</p> <pre><code>result, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n    overlay.WithStrictTargets(true),\n)\n</code></pre>"},{"location":"whitepaper/#10-differ-package","title":"10. Differ Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The differ package compares OpenAPI documents to detect changes, with special focus on identifying breaking changes that may affect API consumers.</p>"},{"location":"whitepaper/#101-diff-modes","title":"10.1 Diff Modes","text":"<p>Simple Mode (ModeSimple): Reports all differences between documents without severity classification.</p> <p>Breaking Mode (ModeBreaking): Categorizes differences by their impact on API consumers.</p>"},{"location":"whitepaper/#102-change-categories","title":"10.2 Change Categories","text":"<p>Changes are grouped by their location in the specification.</p> Category Examples Endpoint Path added/removed Operation Method added/removed/changed Parameter Parameter added/removed/modified RequestBody Request body changed Response Response added/removed/modified Schema Schema definition changed Security Security requirements changed Server Server configuration changed"},{"location":"whitepaper/#103-severity-levels","title":"10.3 Severity Levels","text":"<p>In breaking mode, changes are classified by severity.</p> <p>Critical changes will break existing clients. Examples include removing endpoints, making optional parameters required, and changing parameter types.</p> <p>Error changes are likely to cause problems. Examples include removing response schemas and changing required fields.</p> <p>Warning changes may affect some clients. Examples include adding new required parameters with defaults and changing descriptions.</p> <p>Info changes are additive or cosmetic. Examples include adding new optional endpoints and updating documentation.</p>"},{"location":"whitepaper/#104-api-usage","title":"10.4 API Usage","text":"<pre><code>result, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"v1.yaml\"),\n    differ.WithTargetFilePath(\"v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n)\n\nfmt.Printf(\"Changes: %d Breaking, %d Warning\\n\",\n    result.BreakingCount, result.WarningCount)\n\nfor _, change := range result.Changes {\n    if change.Severity == differ.SeverityCritical {\n        fmt.Printf(\"BREAKING: %s - %s\\n\", change.Path, change.Message)\n    }\n}\n</code></pre>"},{"location":"whitepaper/#105-pre-parsed-comparison","title":"10.5 Pre-Parsed Comparison","text":"<p>For comparing multiple versions, parse once and diff repeatedly.</p> <pre><code>v1, _ := parser.ParseWithOptions(parser.WithFilePath(\"v1.yaml\"))\nv2, _ := parser.ParseWithOptions(parser.WithFilePath(\"v2.yaml\"))\nv3, _ := parser.ParseWithOptions(parser.WithFilePath(\"v3.yaml\"))\n\ndiff12, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(*v1),\n    differ.WithTargetParsed(*v2),\n)\ndiff23, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(*v2),\n    differ.WithTargetParsed(*v3),\n)\n</code></pre>"},{"location":"whitepaper/#11-generator-package","title":"11. Generator Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The generator package produces idiomatic Go code from OpenAPI specifications, with comprehensive support for authentication, file organization, and both client and server generation.</p>"},{"location":"whitepaper/#111-generation-modes","title":"11.1 Generation Modes","text":"<p>Client Mode generates an HTTP client with typed methods for each operation, request/response serialization, error handling, and authentication support.</p> <p>Server Mode generates interface definitions that server implementations must satisfy, providing compile-time type safety for API contracts.</p> <p>Types Mode generates Go structs from schema definitions, suitable for use across client and server implementations.</p>"},{"location":"whitepaper/#112-type-mapping","title":"11.2 Type Mapping","text":"<p>OpenAPI types map to Go types according to established conventions.</p> OpenAPI Type Go Type Notes string string string (format: date-time) time.Time string (format: uuid) string Can use uuid package integer int64 integer (format: int32) int32 number float64 number (format: float) float32 boolean bool array []T object struct or map[string]T oneOf/anyOf interface{} Or discriminated types"},{"location":"whitepaper/#113-security-generation","title":"11.3 Security Generation","text":"<p>The generator provides comprehensive authentication support based on RFC 6749 (OAuth 2.0) and RFC 7636 (PKCE).</p> <p>API Key Authentication:</p> <pre><code>// Generated helper\nfunc WithPetstoreAPIKey(key string) ClientOption {\n    return func(c *Client) error {\n        c.apiKey = key\n        return nil\n    }\n}\n\n// Usage\nclient, _ := NewClient(baseURL, WithPetstoreAPIKey(\"my-key\"))\n</code></pre> <p>HTTP Basic/Bearer:</p> <pre><code>func WithBasicAuth(username, password string) ClientOption { ... }\nfunc WithBearerToken(token string) ClientOption { ... }\n</code></pre> <p>OAuth2 Flows:</p> <p>When <code>GenerateOAuth2Flows</code> is enabled, the generator produces complete OAuth2 clients for each security scheme.</p> <pre><code>// Generated OAuth2 client\ntype PetstoreAuthOAuth2Client struct {\n    Config           OAuth2Config\n    AuthorizationURL string\n    TokenURL         string\n}\n\nfunc (c *PetstoreAuthOAuth2Client) GetAuthorizationURL(state string) string { ... }\nfunc (c *PetstoreAuthOAuth2Client) ExchangeCode(ctx context.Context, code string) (*OAuth2Token, error) { ... }\nfunc (c *PetstoreAuthOAuth2Client) GetClientCredentialsToken(ctx context.Context) (*OAuth2Token, error) { ... }\nfunc (c *PetstoreAuthOAuth2Client) RefreshToken(ctx context.Context, refreshToken string) (*OAuth2Token, error) { ... }\n</code></pre> <p>PKCE Support (RFC 7636):</p> <p>Authorization code flow includes PKCE for enhanced security.</p> <pre><code>verifier, challenge := GeneratePKCE()\nauthURL := oauth2Client.GetAuthorizationURLWithPKCE(state, challenge)\n// After redirect...\ntoken, err := oauth2Client.ExchangeCodeWithPKCE(ctx, code, verifier)\n</code></pre> <p>OpenID Connect Discovery:</p> <p>When <code>GenerateOIDCDiscovery</code> is enabled, an OIDC discovery client is generated.</p> <pre><code>discovery := NewOIDCDiscoveryClient(discoveryURL)\nconfig, err := discovery.GetConfiguration(ctx)\n// config contains authorization_endpoint, token_endpoint, etc.\n</code></pre>"},{"location":"whitepaper/#114-credential-management","title":"11.4 Credential Management","text":"<p>The generator produces a credential provider system for secure credential handling.</p> <pre><code>// Generated interfaces\ntype CredentialProvider interface {\n    GetCredential(ctx context.Context, scheme string) (string, error)\n}\n\n// Built-in implementations\ntype MemoryCredentialProvider struct { ... }\ntype EnvCredentialProvider struct { ... }\ntype CredentialChain struct { ... }\n\n// Usage\nprovider := NewCredentialChain(\n    NewEnvCredentialProvider(\"API_KEY\"),\n    NewMemoryCredentialProvider(credentials),\n)\nclient, _ := NewClient(baseURL, WithCredentialProvider(provider))\n</code></pre>"},{"location":"whitepaper/#115-server-extensions","title":"11.5 Server Extensions","text":"<p>Server generation includes optional extensions for complete server implementation.</p> Extension File Description <code>ServerRouter</code> <code>server_router.go</code> HTTP router with path matching <code>ServerMiddleware</code> <code>server_middleware.go</code> Request/response validation <code>ServerBinder</code> <code>server_binder.go</code> Type-safe parameter binding <code>ServerResponses</code> <code>server_responses.go</code> Typed response writers <code>ServerStubs</code> <code>server_stubs.go</code> Stub implementations for testing <code>SecurityEnforce</code> <code>security_enforce.go</code> Server-side security enforcement"},{"location":"whitepaper/#116-file-splitting","title":"11.6 File Splitting","text":"<p>Large APIs can be split across multiple files for better organization and compilation times.</p> <pre><code>result, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"large-api.yaml\"),\n    generator.WithMaxLinesPerFile(500),\n    generator.WithSplitByTag(true),\n    generator.WithClient(true),\n)\n</code></pre>"},{"location":"whitepaper/#117-api-usage","title":"11.7 API Usage","text":"<pre><code>result, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"petstore.yaml\"),\n    generator.WithPackageName(\"petstore\"),\n    generator.WithClient(true),\n    generator.WithServer(true),\n    generator.WithServerAll(), // All server extensions\n    generator.WithOAuth2Flows(true),\n    generator.WithCredentialMgmt(true),\n    generator.WithOIDCDiscovery(true),\n    generator.WithReadme(true),\n)\n\nfor _, file := range result.Files {\n    fmt.Printf(\"Generated %s (%d bytes)\\n\", file.Name, len(file.Content))\n}\n</code></pre>"},{"location":"whitepaper/#12-builder-package","title":"12. Builder Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The builder package enables programmatic construction of OpenAPI documents, with reflection-based schema generation from Go types.</p>"},{"location":"whitepaper/#121-document-construction","title":"12.1 Document Construction","text":"<pre><code>spec := builder.New(parser.OASVersion310)\nspec.SetTitle(\"My API\").\n    SetVersion(\"1.0.0\").\n    SetDescription(\"A sample API\").\n    AddServer(\"https://api.example.com\",\n        builder.WithServerDescription(\"Production\"))\n\nspec.AddOperation(http.MethodGet, \"/users\",\n    builder.WithOperationID(\"listUsers\"),\n    builder.WithSummary(\"List users\"),\n    builder.WithResponseRef(http.StatusOK, spec.SchemaRef(\"UserList\")),\n)\n\ndoc, err := spec.BuildOAS3()\n</code></pre>"},{"location":"whitepaper/#122-reflection-based-schema-generation","title":"12.2 Reflection-Based Schema Generation","text":"<p>Generate OpenAPI schemas from Go types automatically.</p> <pre><code>type User struct {\n    ID        int64     `json:\"id\"`\n    Name      string    `json:\"name\" oas:\"required\"`\n    Email     string    `json:\"email\" oas:\"format=email\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    Role      string    `json:\"role\" oas:\"enum=admin|user|guest\"`\n}\n\nspec := builder.New(parser.OASVersion310)\nspec.RegisterType(User{})\n\n// Generates:\n// User:\n//   type: object\n//   required: [name]\n//   properties:\n//     id: { type: integer, format: int64 }\n//     name: { type: string }\n//     email: { type: string, format: email }\n//     created_at: { type: string, format: date-time }\n//     role: { type: string, enum: [admin, user, guest] }\n</code></pre>"},{"location":"whitepaper/#123-type-mappings","title":"12.3 Type Mappings","text":"<p>Go types map to OpenAPI schemas according to established conventions.</p> Go Type OpenAPI Type Format string string int, int32 integer int32 int64 integer int64 float32 number float float64 number double bool boolean []T array items: T map[string]T object additionalProperties: T struct object properties from fields *T nullable T time.Time string date-time"},{"location":"whitepaper/#124-schema-naming-strategies","title":"12.4 Schema Naming Strategies","text":"<p>Configurable naming strategies handle generic types and package prefixes.</p> Strategy Example Type Result <code>SchemaNamingDefault</code> <code>models.User</code> <code>models.User</code> <code>SchemaNamingPascalCase</code> <code>models.User</code> <code>ModelsUser</code> <code>SchemaNamingTypeOnly</code> <code>models.User</code> <code>User</code> <code>GenericNamingUnderscore</code> <code>Response[User]</code> <code>Response_User_</code> <code>GenericNamingOf</code> <code>Response[User]</code> <code>ResponseOfUser</code> Custom User-defined Via <code>WithSchemaNameFunc</code>"},{"location":"whitepaper/#125-server-builder","title":"12.5 Server Builder","text":"<p>The <code>ServerBuilder</code> extends the standard builder to produce runnable HTTP servers directly from the fluent API. This enables a \"spec-first\" development workflow where OpenAPI documentation and implementation stay synchronized. Request validation is performed automatically using the httpvalidator package.</p> <p>Creating a Server:</p> <pre><code>srv := builder.NewServerBuilder(parser.OASVersion320).\n    SetTitle(\"Pet Store API\").\n    SetVersion(\"1.0.0\")\n\nsrv.AddOperation(http.MethodGet, \"/pets\",\n    builder.WithHandler(func(ctx context.Context, req *builder.Request) builder.Response {\n        return builder.JSON(http.StatusOK, pets)\n    }),\n    builder.WithResponse(http.StatusOK, []Pet{}),\n)\n\nresult, _ := srv.BuildServer()\nhttp.ListenAndServe(\":8080\", result.Handler)\n</code></pre> <p>Key Capabilities:</p> Capability Description Request Validation Automatic validation of path/query/header parameters and request bodies Response Helpers <code>JSON()</code>, <code>NoContent()</code>, <code>Error()</code>, <code>Redirect()</code>, <code>Stream()</code> for consistent responses Middleware Support Chain middleware functions for auth, logging, etc. Testing Utilities <code>NewTestRequest()</code>, <code>ServerTest()</code>, <code>StubHandler()</code> for easy testing Fluent ResponseBuilder Set headers, cookies, and streaming responses <p>Handler Registration:</p> <pre><code>// Inline registration\nsrv.AddOperation(http.MethodGet, \"/pets\",\n    builder.WithHandler(listPetsHandler),\n    builder.WithResponse(http.StatusOK, []Pet{}),\n)\n\n// Dynamic registration\nsrv.Handle(http.MethodGet, \"/pets\", listPetsHandler)\nsrv.HandleFunc(http.MethodGet, \"/health\", healthHandler)\n</code></pre> <p>Operations without registered handlers return 501 Not Implemented at runtime.</p>"},{"location":"whitepaper/#126-semantic-deduplication","title":"12.6 Semantic Deduplication","text":"<p>When multiple types generate identical schemas, the builder consolidates them.</p> <pre><code>// Enable semantic deduplication via constructor option\nspec := builder.New(parser.OASVersion310, builder.WithSemanticDeduplication(true))\n\nspec.RegisterType(UserRequest{})  // Creates UserRequest schema\nspec.RegisterType(UserResponse{}) // If identical, reuses UserRequest\n</code></pre>"},{"location":"whitepaper/#13-http-validator-package","title":"13. HTTP Validator Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The httpvalidator package validates HTTP requests and responses against OpenAPI specifications at runtime, suitable for API gateways, middleware, and testing.</p>"},{"location":"whitepaper/#131-core-capabilities","title":"13.1 Core Capabilities","text":"<p>Request Validation covers path parameters with template matching, query parameters with type coercion, header parameters, cookie parameters, and request body schema validation.</p> <p>Response Validation covers status code verification against documented responses, response header validation, and response body schema validation.</p>"},{"location":"whitepaper/#132-parameter-deserialization","title":"13.2 Parameter Deserialization","text":"<p>All OAS serialization styles are supported per the OpenAPI Specification.</p> Style Location Example simple path, header <code>value</code> or <code>val1,val2</code> form query, cookie <code>?ids=1,2,3</code> matrix path <code>;id=5</code> label path <code>.blue.red</code> deepObject query <code>?filter[status]=active</code> spaceDelimited query <code>?ids=1%202%203</code> pipeDelimited query <code>?ids=1\\|2\\|3</code>"},{"location":"whitepaper/#133-api-usage","title":"13.3 API Usage","text":"<p>Creating a Validator:</p> <pre><code>parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\nv, err := httpvalidator.New(parsed)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p>Validating Requests:</p> <pre><code>result, err := v.ValidateRequest(req)\nif !result.Valid {\n    for _, e := range result.Errors {\n        fmt.Printf(\"Error: %s - %s\\n\", e.Path, e.Message)\n    }\n}\n\n// Access deserialized parameters\nuserID := result.PathParams[\"userId\"]\nlimit := result.QueryParams[\"limit\"]\n</code></pre> <p>Validating Responses:</p> <pre><code>result, err := v.ValidateResponseData(req, statusCode, headers, body)\nif !result.Valid {\n    log.Printf(\"Response validation failed: %v\", result.Errors)\n}\n</code></pre>"},{"location":"whitepaper/#134-middleware-integration","title":"13.4 Middleware Integration","text":"<p>The validator integrates naturally with HTTP middleware patterns.</p> <pre><code>func ValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            result, _ := v.ValidateRequest(r)\n            if !result.Valid {\n                w.WriteHeader(http.StatusBadRequest)\n                json.NewEncoder(w).Encode(map[string]any{\n                    \"error\":   \"Validation failed\",\n                    \"details\": result.Errors,\n                })\n                return\n            }\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n</code></pre>"},{"location":"whitepaper/#135-strict-mode","title":"13.5 Strict Mode","text":"<p>Enable strict mode for stricter validation.</p> <pre><code>v.StrictMode = true\n</code></pre> <p>In strict mode, unknown query parameters cause validation errors, unknown headers (except standard HTTP headers) cause errors, unknown cookies cause errors, and undocumented response status codes cause errors.</p>"},{"location":"whitepaper/#14-walker-package","title":"14. Walker Package","text":"<p>Links: pkg.go.dev | Deep Dive</p> <p>The walker package provides typed, handler-based traversal of OpenAPI documents, enabling analysis, mutation, validation, and filtering patterns.</p>"},{"location":"whitepaper/#141-core-concepts","title":"14.1 Core Concepts","text":"<p>The walker uses a handler-based approach where you register callbacks for specific node types. Each handler receives a pointer to the node (enabling mutation) and the JSON path to that node.</p> <p>Flow Control:</p> Action Behavior <code>Continue</code> Process children and continue to siblings <code>SkipChildren</code> Skip descendants, continue to siblings <code>Stop</code> Halt traversal immediately"},{"location":"whitepaper/#142-handler-types","title":"14.2 Handler Types","text":"<p>The walker provides 19 typed handlers covering all OAS node types:</p> Handler Description <code>WithDocumentHandler</code> Root document (version-agnostic) <code>WithOAS2DocumentHandler</code> OAS 2.0 document <code>WithOAS3DocumentHandler</code> OAS 3.x document <code>WithInfoHandler</code> API metadata <code>WithServerHandler</code> Server definitions (3.x only) <code>WithPathHandler</code> Path entries with template <code>WithOperationHandler</code> HTTP operations <code>WithParameterHandler</code> Parameters <code>WithRequestBodyHandler</code> Request bodies (3.x only) <code>WithResponseHandler</code> Responses <code>WithSchemaHandler</code> All schemas (including nested) <code>WithSecuritySchemeHandler</code> Security schemes <code>WithTagHandler</code> Tags <code>WithHeaderHandler</code> Headers <code>WithMediaTypeHandler</code> Media types (3.x only) <code>WithLinkHandler</code> Links (3.x only) <code>WithCallbackHandler</code> Callbacks (3.x only) <code>WithExampleHandler</code> Examples <code>WithExternalDocsHandler</code> External documentation"},{"location":"whitepaper/#143-api-usage","title":"14.3 API Usage","text":"<p>Analysis Pattern:</p> <pre><code>var stats struct {\n    Operations int\n    Schemas    int\n}\n\nwalker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        stats.Operations++\n        return walker.Continue\n    }),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        stats.Schemas++\n        return walker.Continue\n    }),\n)\n\nfmt.Printf(\"Operations: %d, Schemas: %d\\n\", stats.Operations, stats.Schemas)\n</code></pre> <p>Mutation Pattern:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if schema.Extra == nil {\n            schema.Extra = make(map[string]any)\n        }\n        schema.Extra[\"x-processed\"] = true\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Filtering Pattern:</p> <pre><code>walker.Walk(result,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pi *parser.PathItem) walker.Action {\n        if strings.HasPrefix(wc.PathTemplate, \"/internal\") {\n            return walker.SkipChildren  // Skip internal endpoints\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"whitepaper/#144-cycle-detection","title":"14.4 Cycle Detection","text":"<p>The walker automatically detects circular schema references and provides notifications via <code>WithSchemaSkippedHandler</code>:</p> <pre><code>walker.Walk(result,\n    walker.WithMaxSchemaDepth(50), // WithMaxDepth is deprecated; prefer WithMaxSchemaDepth\n    walker.WithSchemaSkippedHandler(func(wc *walker.WalkContext, reason string, schema *parser.Schema) {\n        if reason == \"cycle\" {\n            fmt.Printf(\"Circular reference at: %s\\n\", wc.JSONPath)\n        }\n    }),\n)\n</code></pre>"},{"location":"whitepaper/#145-use-cases","title":"14.5 Use Cases","text":"<p>The walker package enables several common patterns:</p> Use Case Handlers Flow Control API Statistics Operation, Schema, Parameter Continue Security Audit Operation, Schema, Path Continue, Stop Vendor Extensions Schema, Operation, Path Continue, SkipChildren Public API Filter Path, Operation SkipChildren Documentation Gen Info, Server, Operation, Response Continue Reference Analysis Schema, SchemaSkipped Continue"},{"location":"whitepaper/#146-recent-enhancements-v138-v146","title":"14.6 Recent Enhancements (v1.38-v1.46)","text":"<p>The walker has gained several powerful features:</p> <ul> <li>Reference Tracking - <code>WithRefHandler()</code> and <code>WithMapRefTracking()</code> for comprehensive <code>$ref</code> detection</li> <li>Parent Tracking - <code>WithParentTracking()</code> provides type-safe ancestor access via <code>ParentInfo</code></li> <li>Post-Visit Hooks - <code>WithSchemaPostHandler()</code>, <code>WithOperationPostHandler()</code>, etc. for bottom-up processing</li> <li>Built-in Collectors - <code>CollectSchemas()</code> and <code>CollectOperations()</code> reduce boilerplate</li> </ul> <p>For comprehensive documentation, examples, and performance considerations, see the Walker Deep Dive.</p>"},{"location":"whitepaper/#15-mcp-server","title":"15. MCP Server","text":"<p>Links: MCP Server Guide | Claude Code Plugin | Model Context Protocol</p> <p>oastools includes a built-in Model Context Protocol (MCP) server that exposes all toolkit capabilities to AI-assisted development environments such as Claude Code, Cursor, and other MCP-compatible clients. The server communicates over stdio transport and is launched via the CLI.</p> <pre><code>oastools mcp\n</code></pre>"},{"location":"whitepaper/#151-tool-categories","title":"15.1 Tool Categories","text":"<p>The MCP server provides 17 tools organized into two categories.</p> <p>Core Tools (9 tools):</p> Tool Description <code>validate</code> Validate OAS documents with error/warning counts and JSON path locations <code>parse</code> Parse OAS with structural summary (title, version, path/operation/schema counts) <code>fix</code> Auto-fix common issues with dry-run support <code>convert</code> Convert between OAS versions with issue tracking <code>diff</code> Compare specs with breaking change detection and severity levels <code>join</code> Merge multiple specs with configurable collision strategies <code>overlay_apply</code> Apply Overlay documents using JSONPath expressions <code>overlay_validate</code> Validate Overlay document structure and JSONPath syntax <code>generate</code> Generate Go client/server/types code <p>Walk Tools (8 tools):</p> Tool Description <code>walk_operations</code> Filter by method, path, tag, operationId, deprecated status <code>walk_schemas</code> Filter by name, type, component/inline location <code>walk_parameters</code> Filter by location, name, path pattern, method <code>walk_responses</code> Filter by status code, path, method <code>walk_security</code> Filter by security scheme name or type <code>walk_paths</code> Filter by path pattern with glob support <code>walk_refs</code> Query <code>$ref</code> references ranked by count with target filtering <code>walk_headers</code> Query response and component headers"},{"location":"whitepaper/#152-key-capabilities","title":"15.2 Key Capabilities","text":"<p>Pagination: All tools support <code>offset</code>/<code>limit</code> parameters (default limit: 100, maximum: 1000) for handling large specifications.</p> <p>Group-By Aggregation: Most walk tools support a <code>group_by</code> parameter (all except <code>walk_security</code>) that returns distribution counts instead of individual items. For example, <code>walk_operations</code> with <code>group_by=method</code> returns a count of operations per HTTP method.</p> <p>Detail Mode: Walk tools support a <code>detail</code> flag that returns full nested objects instead of summary tables (default limit: 25 items in detail mode).</p> <p>Spec Caching: Parsed specifications are cached within MCP sessions with TTL-based expiration. File entries auto-invalidate on modification, URL entries expire based on configurable TTLs, and a background sweeper removes expired entries.</p>"},{"location":"whitepaper/#153-configuration","title":"15.3 Configuration","text":"<p>The MCP server is configured via environment variables, since the Go MCP SDK does not support <code>initializationOptions</code>. MCP clients set these via their <code>env</code> field in server configuration.</p> <p>Cache Configuration:</p> Variable Default Description <code>OASTOOLS_CACHE_ENABLED</code> <code>true</code> Enable/disable spec caching <code>OASTOOLS_CACHE_MAX_SIZE</code> <code>10</code> Maximum cached specifications <code>OASTOOLS_CACHE_FILE_TTL</code> <code>15m</code> File spec expiration <code>OASTOOLS_CACHE_URL_TTL</code> <code>5m</code> URL-fetched spec expiration <code>OASTOOLS_CACHE_CONTENT_TTL</code> <code>15m</code> Inline content spec expiration <code>OASTOOLS_CACHE_SWEEP_INTERVAL</code> <code>60s</code> Background cleanup frequency <p>Behavior Defaults:</p> Variable Default Description <code>OASTOOLS_WALK_LIMIT</code> <code>100</code> Default result limit <code>OASTOOLS_WALK_DETAIL_LIMIT</code> <code>25</code> Detail mode result limit <code>OASTOOLS_VALIDATE_STRICT</code> <code>false</code> Enable strict validation <code>OASTOOLS_VALIDATE_NO_WARNINGS</code> <code>false</code> Suppress validation warnings <code>OASTOOLS_JOIN_PATH_STRATEGY</code> \u2014 Default path collision strategy <code>OASTOOLS_JOIN_SCHEMA_STRATEGY</code> \u2014 Default schema collision strategy"},{"location":"whitepaper/#154-security","title":"15.4 Security","text":"<p>The MCP server implements several security measures:</p> <ul> <li>Error sanitization \u2014 Filesystem paths are stripped from error messages to prevent information disclosure</li> <li>Output path sanitization \u2014 Generated output paths are validated against path traversal, with symlink checks</li> <li>SSRF protection \u2014 Blocks resolution of private, loopback, and link-local IP addresses (opt-out via <code>OASTOOLS_ALLOW_PRIVATE_IPS</code>)</li> <li>Input size bounds \u2014 Inline content limited to 10 MiB (configurable via <code>OASTOOLS_MAX_INLINE_SIZE</code>)</li> <li>Pagination safety \u2014 Limit parameter capped at 1000 (<code>OASTOOLS_MAX_LIMIT</code>)</li> <li>Join spec bounds \u2014 Maximum 20 specs per join operation (<code>OASTOOLS_MAX_JOIN_SPECS</code>)</li> <li>Package name validation \u2014 Generated package names validated against <code>^[a-z][a-z0-9_]*$</code></li> </ul>"},{"location":"whitepaper/#16-error-handling-with-oaserrors","title":"16. Error Handling with oaserrors","text":"<p>Links: pkg.go.dev</p> <p>The oaserrors package provides structured error types that integrate with Go's standard error handling mechanisms.</p>"},{"location":"whitepaper/#161-error-types","title":"16.1 Error Types","text":"Type Description Sentinel <code>ParseError</code> YAML/JSON parsing failures <code>ErrParse</code> <code>ReferenceError</code> <code>$ref</code> resolution failures <code>ErrReference</code> <code>ValidationError</code> Specification violations <code>ErrValidation</code> <code>ResourceLimitError</code> Resource exhaustion <code>ErrResourceLimit</code> <code>ConversionError</code> Version conversion failures <code>ErrConversion</code> <code>ConfigError</code> Invalid configuration <code>ErrConfig</code>"},{"location":"whitepaper/#162-specialized-sentinels","title":"16.2 Specialized Sentinels","text":"Sentinel Matches Condition <code>ErrCircularReference</code> <code>ReferenceError</code> <code>IsCircular == true</code> <code>ErrPathTraversal</code> <code>ReferenceError</code> <code>IsPathTraversal == true</code>"},{"location":"whitepaper/#163-usage-with-errorsis","title":"16.3 Usage with errors.Is","text":"<pre><code>result, err := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nif err != nil {\n    if errors.Is(err, oaserrors.ErrPathTraversal) {\n        log.Fatal(\"Security: path traversal blocked\")\n    }\n    if errors.Is(err, oaserrors.ErrCircularReference) {\n        log.Println(\"Warning: circular reference detected\")\n        // May still be usable\n    }\n    if errors.Is(err, oaserrors.ErrParse) {\n        log.Fatal(\"Failed to parse document\")\n    }\n}\n</code></pre>"},{"location":"whitepaper/#164-usage-with-errorsas","title":"16.4 Usage with errors.As","text":"<pre><code>var refErr *oaserrors.ReferenceError\nif errors.As(err, &amp;refErr) {\n    fmt.Printf(\"Failed ref: %s (type: %s)\\n\", refErr.Ref, refErr.RefType)\n    if refErr.IsCircular {\n        fmt.Println(\"Circular reference detected\")\n    }\n}\n\nvar valErr *oaserrors.ValidationError\nif errors.As(err, &amp;valErr) {\n    fmt.Printf(\"Validation error at %s: %s\\n\", valErr.Path, valErr.Message)\n    if valErr.SpecRef != \"\" {\n        fmt.Printf(\"See: %s\\n\", valErr.SpecRef)\n    }\n}\n</code></pre>"},{"location":"whitepaper/#165-error-chaining","title":"16.5 Error Chaining","text":"<p>All error types support chaining via the <code>Cause</code> field and <code>Unwrap()</code> method.</p> <pre><code>var refErr *oaserrors.ReferenceError\nif errors.As(err, &amp;refErr) {\n    if errors.Is(refErr.Cause, os.ErrNotExist) {\n        fmt.Println(\"Referenced file does not exist\")\n    }\n}\n</code></pre>"},{"location":"whitepaper/#166-structured-error-locality","title":"16.6 Structured Error Locality","text":"<p>Error and warning types in the builder, joiner, and overlay packages implement the <code>HasLocation()</code> and <code>Location()</code> methods for programmatic error handling with source context. This enables IDE-friendly error reporting and structured handling of non-fatal issues.</p> <p>BuilderError:</p> <pre><code>var builderErr *builder.BuilderError\nif errors.As(err, &amp;builderErr) {\n    if builderErr.HasLocation() {\n        fmt.Printf(\"Error at %s: %s\\n\", builderErr.Location(), builderErr.Message)\n        // Output: Error at POST /users: duplicate operationId \"createUser\"\n    }\n}\n</code></pre> <p>JoinWarning:</p> <pre><code>for _, w := range result.StructuredWarnings {\n    if w.HasLocation() {\n        fmt.Printf(\"%s: %s\\n\", w.Location(), w.Message)\n        // Output: users.yaml:42:5: schema 'User' collision resolved\n    }\n}\n</code></pre> <p>ApplyWarning (Overlay):</p> <pre><code>for _, w := range result.StructuredWarnings {\n    if w.HasLocation() {\n        fmt.Printf(\"%s: %s\\n\", w.Location(), w.Message)\n        // Output: action[2]: target matched no nodes\n    }\n}\n</code></pre>"},{"location":"whitepaper/#17-performance-analysis","title":"17. Performance Analysis","text":"<p>oastools includes comprehensive benchmarking infrastructure and has undergone targeted optimization to achieve significant performance improvements.</p>"},{"location":"whitepaper/#171-pre-parsed-workflow-optimization","title":"17.1 Pre-Parsed Workflow Optimization","text":"<p>The most significant performance gain comes from the parse-once pattern. When the same document undergoes multiple operations, parsing once and passing the result to subsequent operations eliminates redundant work.</p> Operation Standard Pre-Parsed Speedup Validate 135 \u03bcs 4.8 \u03bcs 31x Convert 152 \u03bcs 3.2 \u03bcs 47x Join (2 docs) 110 \u03bcs 732 ns 150x Diff 280 \u03bcs 12.7 \u03bcs 81x Fix 140 \u03bcs 2.8 \u03bcs ~60x Apply (overlay) 120 \u03bcs ~8 \u03bcs ~11x <p>Usage Pattern:</p> <pre><code>// Parse once\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\n\n// Reuse for multiple operations\nvalResult, _ := validator.ValidateWithOptions(validator.WithParsed(*parsed))\nfixResult, _ := fixer.FixWithOptions(fixer.WithParsed(*parsed))\nconvResult, _ := converter.ConvertWithOptions(\n    converter.WithParsed(*parsed),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\n</code></pre>"},{"location":"whitepaper/#172-json-marshaling-optimization","title":"17.2 JSON Marshaling Optimization","text":"<p>Version 1.7.0 introduced optimized JSON marshaling that eliminates double-marshal patterns across all 29 custom JSON marshalers in the parser package.</p> Improvement Before After Performance Baseline 25-32% faster Allocations Baseline 29-37% fewer"},{"location":"whitepaper/#173-deepcopy-optimization","title":"17.3 DeepCopy Optimization","text":"<p>Version 1.20.0 replaced JSON marshal/unmarshal with code-generated <code>DeepCopy()</code> methods.</p> Improvement Before After Deep copy speed Baseline ~37x faster Type preservation No Yes Memory efficiency Baseline Significantly better"},{"location":"whitepaper/#174-http-validator-performance","title":"17.4 HTTP Validator Performance","text":"<p>The httpvalidator package is optimized for high-throughput scenarios.</p> Operation Time Memory Allocations Path matching (small spec) 210 ns 528 B 8 Path matching (large spec) 502 ns 528 B 8 With JSON body 455 ns 1.5 KB 16 Response validation 110 ns 256 B 2"},{"location":"whitepaper/#175-benchmark-reliability","title":"17.5 Benchmark Reliability","text":"<p>File-based benchmarks can vary \u00b150% due to I/O variance. For reliable regression detection, use I/O-isolated benchmarks.</p> <p>Reliable Benchmarks:</p> Package Benchmark Measures parser <code>BenchmarkParseCore</code> Parsing logic only joiner <code>BenchmarkJoinParsed</code> Joining logic only validator <code>BenchmarkValidateParsed</code> Validation logic only fixer <code>BenchmarkFixParsed</code> Fixing logic only converter <code>BenchmarkConvertParsed*</code> Conversion logic only differ <code>BenchmarkDiff/Parsed</code> Diffing logic only walker <code>BenchmarkWalk/Parsed</code> Walking logic only"},{"location":"whitepaper/#176-memory-optimization-syncpool-v1450","title":"17.6 Memory Optimization: sync.Pool (v1.45.0)","text":"<p>The parser and generator packages use <code>sync.Pool</code> to reduce GC pressure:</p> <p>Marshal Buffer Pool (parser):</p> <ul> <li>Reuses <code>bytes.Buffer</code> for JSON/YAML marshaling</li> <li>Up to 36% fewer allocations for large documents</li> <li>78x faster buffer acquisition vs allocation</li> </ul> <p>Template Buffer Pool (generator):</p> <ul> <li>Tiered pools (8KB/32KB/64KB) based on operation count</li> <li>Prevents oversized allocations during code generation</li> </ul> <p>Design Decisions:</p> <ul> <li>All pools are internal (package-private)</li> <li>Reset-on-get pattern ensures clean state</li> <li>Size guards prevent memory leaks from oversized objects</li> <li>7 planned pools were cut (YAGNI) due to use-after-put risks</li> </ul> <p>Capacity decisions are data-driven from corpus analysis of 10 real-world OpenAPI specs (19,147 operations, 360,577 schemas).</p>"},{"location":"whitepaper/#177-json-fast-path-v1470","title":"17.7 \u26a1 JSON Fast-Path (v1.47.0)","text":"<p>The parser now automatically uses an optimized path for JSON input that bypasses YAML AST overhead.</p> Metric Standard Path JSON Fast-Path Improvement Parse time (large specs) ~2.5s ~0.3s ~88% reduction Memory allocation ~750MB ~50MB ~93% reduction <p>The fast-path activates automatically when:</p> <ul> <li>\u2705 Input is detected as JSON format</li> <li>\u2705 Source map building is disabled</li> <li>\u2705 Order preservation is disabled</li> </ul>"},{"location":"whitepaper/#178-pathbuilder-optimization-v1480-v1481","title":"17.8 \ud83d\ude80 PathBuilder Optimization (v1.48.0-v1.48.1)","text":"<p>A new internal <code>pathutil</code> package provides efficient incremental path building using push/pop semantics, eliminating allocations during recursive document traversal.</p> Operation fmt.Sprintf PathBuilder Improvement Deep path building ~1-2\u03bcs ~200-300ns ~6-8x faster Path without String() ~200-300ns ~20-50ns ~4-10x faster SchemaRef building ~30-50ns ~5-10ns ~5x faster <p>The v1.48.1 release migrated the validator, fixer, builder, and joiner packages to use <code>pathutil</code> for all internal ref string building, reducing hot path allocations by ~5-15%.</p>"},{"location":"whitepaper/#179-mutable-input-mode-v1480","title":"17.9 \u26a0\ufe0f Mutable Input Mode (v1.48.0)","text":"<p>The fixer's <code>WithMutableInput(true)</code> option eliminates defensive copying when chaining multiple fix passes:</p> Scenario Standard WithMutableInput Improvement Chained fix passes 2\u00d7 copy 1\u00d7 copy 50% memory Large spec fixes Baseline 10-30% less memory Significant"},{"location":"whitepaper/#1710-streaming-extension-extraction-v1490","title":"17.10 \ud83d\udd0d Streaming Extension Extraction (v1.49.0)","text":"<p>Vendor extension extraction was optimized with a <code>bytes.Contains</code> pre-check for <code>\"x-</code> before expensive JSON parsing. This eliminates allocations entirely for documents without vendor extensions.</p> Scenario Before After Improvement No extensions (common case) ~2,818 ns ~186 ns 15x faster Allocations (no extensions) Baseline 0 Zero-alloc"},{"location":"whitepaper/#1711-direct-map-to-struct-decoding-v1510","title":"17.11 \ud83e\udde0 Direct Map-to-Struct Decoding (v1.51.0)","text":"<p>Reference resolution previously used a <code>map \u2192 JSON bytes \u2192 struct</code> roundtrip that doubled peak memory. Code-generated <code>decodeFromMap</code> methods now decode <code>map[string]any</code> directly to typed structs for all 29 OAS types, eliminating the intermediate <code>[]byte</code> allocation. Combined with a <code>ShallowCopy</code> optimization that skips deep copy for non-circular references, this significantly reduces memory usage when resolving references in large specifications.</p>"},{"location":"whitepaper/#18-real-world-validation","title":"18. Real-World Validation","text":"<p>The oastools test suite validates against a corpus of ten production APIs spanning diverse domains, sizes, and OAS versions.</p>"},{"location":"whitepaper/#181-test-corpus","title":"18.1 Test Corpus","text":"API OAS Version Size Domain Key Testing Focus Microsoft Graph 3.0.4 34 MB, ~18k ops Enterprise Largest spec, stress testing Stripe 3.0.0 2.5 MB, 900+ ops FinTech Polymorphic types, callbacks GitHub 3.0.3 424 KB, 600+ ops Developer Tools Extensive $ref linking Plaid 3.0.0 1.2 MB FinTech Multi-server, strict security Discord 3.1.0 2-5 MB Communications OAS 3.1 features, webhooks DigitalOcean 3.0.0 2.4 MB Cloud External $ref files, bundling Google Maps 3.0.3 500 KB Geo/Mapping Geo-coordinate parameters US NWS 3.0.3 800 KB Public/Weather JSON-LD extensions Petstore 2.0 20 KB Reference Baseline OAS 2.0 compatibility Asana 3.0.0 405 KB Productivity OAuth2, clean YAML structure"},{"location":"whitepaper/#182-corpus-access","title":"18.2 Corpus Access","text":"<p>The test corpus can be downloaded for local testing.</p> <pre><code>make corpus-download\n</code></pre> <p>Specifications are stored in <code>testdata/corpus/</code> with consistent naming.</p>"},{"location":"whitepaper/#183-testing-coverage","title":"18.3 Testing Coverage","text":"<p>The corpus exercises key functionality across packages. Parser testing covers format detection (JSON and YAML), reference resolution (local and external), version detection (2.0 through 3.1), large document handling, and circular reference detection. Validator testing covers structural validation, semantic validation, strict mode validation, and source map integration. Converter testing covers OAS 2.0 to 3.x upgrade, OAS 3.x to 2.0 downgrade, and issue tracking. Joiner testing covers multi-document merging, collision handling, and reference rewriting. Differ testing covers breaking change detection and change categorization. Generator testing covers client generation, server generation, security code generation, and OAuth2 flow generation.</p>"},{"location":"whitepaper/#19-cli-reference","title":"19. CLI Reference","text":"<p>oastools provides a comprehensive command-line interface for all major operations.</p>"},{"location":"whitepaper/#191-installation","title":"19.1 Installation","text":"<p>Homebrew:</p> <pre><code>brew install erraggy/oastools/oastools\n</code></pre> <p>Go Install:</p> <pre><code>go install github.com/erraggy/oastools/cmd/oastools@latest\n</code></pre>"},{"location":"whitepaper/#192-commands","title":"19.2 Commands","text":"<p>Parse:</p> <pre><code>oastools parse openapi.yaml\noastools parse --resolve-refs openapi.yaml\noastools parse --source-map openapi.yaml\n</code></pre> <p>Validate:</p> <pre><code>oastools validate openapi.yaml\noastools validate --strict openapi.yaml\noastools validate -q openapi.yaml  # Quiet mode\n</code></pre> <p>Fix:</p> <pre><code>oastools fix openapi.yaml\noastools fix --infer openapi.yaml  # With type inference\noastools fix --prune-unused openapi.yaml  # Remove unused schemas\noastools fix -o fixed.yaml openapi.yaml  # Output to file\n</code></pre> <p>Convert:</p> <pre><code>oastools convert -t 3.1.0 swagger.yaml\noastools convert -t 2.0 openapi.yaml  # Downgrade\noastools convert -t 3.1.0 -o converted.yaml swagger.yaml\n</code></pre> <p>Join:</p> <pre><code>oastools join api1.yaml api2.yaml api3.yaml\noastools join --strategy accept-left *.yaml\noastools join -o combined.yaml users.yaml orders.yaml\n</code></pre> <p>Overlay:</p> <pre><code>oastools overlay apply -s openapi.yaml changes.yaml\noastools overlay apply --dry-run -s openapi.yaml changes.yaml\noastools overlay apply --strict -s openapi.yaml changes.yaml\n</code></pre> <p>Diff:</p> <pre><code>oastools diff v1.yaml v2.yaml\noastools diff --breaking v1.yaml v2.yaml  # Breaking changes only\noastools diff --format json v1.yaml v2.yaml\n</code></pre> <p>Generate:</p> <pre><code>oastools generate -client -p petstore openapi.yaml\noastools generate -server -server-all -p petstore openapi.yaml\noastools generate -client -server -oauth2-flows -p petstore openapi.yaml\noastools generate -client -security-enforce -credential-mgmt -p petstore openapi.yaml\n</code></pre> <p>Walk (v1.50.0+):</p> <pre><code>oastools walk operations openapi.yaml                  # List all operations\noastools walk operations --method GET openapi.yaml     # Filter by method\noastools walk schemas --type object openapi.yaml       # Filter schemas by type\noastools walk parameters --in query openapi.yaml       # Filter by location\noastools walk responses --status 2xx openapi.yaml      # Wildcard status codes\noastools walk security openapi.yaml                    # List security schemes\noastools walk paths --path '/pets/*' openapi.yaml      # Glob pattern matching\n</code></pre> <p>Walk subcommands support <code>--format</code> (text/json/yaml), <code>--detail</code> for full output, <code>--extension</code> for vendor extension filtering, and <code>--resolve-refs</code> for <code>$ref</code> resolution.</p> <p>MCP (v1.51.0+):</p> <pre><code>oastools mcp  # Start MCP server over stdio\n</code></pre> <p>The MCP command launches a Model Context Protocol server that exposes all oastools capabilities as tools. See \u00a715. MCP Server for details.</p>"},{"location":"whitepaper/#193-global-flags","title":"19.3 Global Flags","text":"Flag Description <code>-h, --help</code> Show help <code>-v, --version</code> Show version <code>-q, --quiet</code> Suppress informational output <code>--no-color</code> Disable colored output"},{"location":"whitepaper/#20-api-design-patterns","title":"20. API Design Patterns","text":"<p>oastools provides two complementary API styles for different use cases.</p>"},{"location":"whitepaper/#201-functional-options-pattern","title":"20.1 Functional Options Pattern","text":"<p>Best for one-off operations with explicit configuration.</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"api.yaml\"),\n    parser.WithResolveRefs(true),\n    parser.WithSourceMap(true),\n)\n</code></pre> <p>Advantages: Self-documenting, compile-time safety, easy to extend.</p>"},{"location":"whitepaper/#202-struct-based-pattern","title":"20.2 Struct-Based Pattern","text":"<p>Best for batch processing with shared configuration.</p> <pre><code>p := parser.New()\np.ResolveRefs = true\np.ValidateStructure = true\n\nfor _, file := range files {\n    result, err := p.Parse(file)\n    // Process result\n}\n</code></pre> <p>Advantages: Reusable configuration, lower allocation overhead for multiple operations.</p>"},{"location":"whitepaper/#203-pre-parsed-pattern","title":"20.3 Pre-Parsed Pattern","text":"<p>Best for pipeline processing where multiple operations apply to the same document.</p> <pre><code>parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\n\n// All subsequent operations skip parsing\nvalResult, _ := validator.ValidateWithOptions(validator.WithParsed(*parsed))\nfixResult, _ := fixer.FixWithOptions(fixer.WithParsed(*parsed))\ngenResult, _ := generator.GenerateWithOptions(\n    generator.WithParsed(*parsed),\n    generator.WithClient(true),\n)\n</code></pre>"},{"location":"whitepaper/#204-error-handling-pattern","title":"20.4 Error Handling Pattern","text":"<p>Consistent error handling across all packages using oaserrors.</p> <pre><code>result, err := someOperation()\nif err != nil {\n    // Check category with errors.Is\n    if errors.Is(err, oaserrors.ErrParse) {\n        // Handle parse error\n    }\n\n    // Extract details with errors.As\n    var refErr *oaserrors.ReferenceError\n    if errors.As(err, &amp;refErr) {\n        fmt.Printf(\"Failed ref: %s\\n\", refErr.Ref)\n    }\n\n    return err\n}\n</code></pre>"},{"location":"whitepaper/#21-security-considerations","title":"21. Security Considerations","text":"<p>oastools incorporates several security measures to protect against common vulnerabilities.</p>"},{"location":"whitepaper/#211-path-traversal-protection","title":"21.1 Path Traversal Protection","text":"<p>External file references are validated to prevent path traversal attacks.</p> <pre><code>resolver := parser.NewRefResolver(\"/base/path\", 0, 0, 0)\n// Attempting to resolve \"../../../etc/passwd\" will fail with ErrPathTraversal\n</code></pre> <p>The resolver ensures resolved paths remain within the allowed base directory, even on Windows with path variations.</p>"},{"location":"whitepaper/#212-http-reference-control","title":"21.2 HTTP Reference Control","text":"<p>Remote URL resolution is disabled by default and requires explicit opt-in.</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"api.yaml\"),\n    parser.WithResolveHTTPRefs(true),  // Explicit opt-in required\n)\n</code></pre>"},{"location":"whitepaper/#213-resource-limits","title":"21.3 Resource Limits","text":"<p>Configurable limits prevent resource exhaustion.</p> Limit Default Purpose <code>MaxRefDepth</code> 100 Prevents stack overflow from deep/circular refs <code>MaxCachedDocuments</code> 100 Limits memory usage for external docs <code>MaxFileSize</code> 10 MB Prevents memory exhaustion from large files"},{"location":"whitepaper/#214-pkce-for-oauth2","title":"21.4 PKCE for OAuth2","text":"<p>Generated OAuth2 code uses PKCE (RFC 7636) for authorization code flows, preventing authorization code interception attacks.</p> <pre><code>// Generated code includes PKCE support\nverifier, challenge := GeneratePKCE()\nauthURL := oauth2Client.GetAuthorizationURLWithPKCE(state, challenge)\n</code></pre>"},{"location":"whitepaper/#215-credential-management","title":"21.5 Credential Management","text":"<p>Generated credential management systems avoid hardcoding secrets.</p> <pre><code>// Credential chain allows secure secret retrieval\nprovider := NewCredentialChain(\n    NewEnvCredentialProvider(\"API_KEY\"),\n    NewVaultCredentialProvider(vaultClient),\n)\n</code></pre>"},{"location":"whitepaper/#216-security-hardening-v1520","title":"21.6 Security Hardening (v1.52.0)","text":"<p>Version 1.52.0 introduced a comprehensive security audit addressing 7 High and 19 Medium severity findings across five attack surfaces.</p> <p>MCP Server:</p> <ul> <li>Output path sanitization with <code>filepath.Clean</code>, <code>..</code> traversal rejection, and symlink checks</li> <li>SSRF protection blocking private, loopback, and link-local IP addresses (opt-out via <code>OASTOOLS_ALLOW_PRIVATE_IPS</code>)</li> <li>Input size bounds (10 MiB inline content limit)</li> <li>Pagination safety (limit capped at 1000)</li> <li>Error sanitization stripping filesystem paths from error messages</li> </ul> <p>Parser &amp; Resolver:</p> <ul> <li>Input size limit of 100 MiB (configurable via parser option)</li> <li>HTTP fetch response size wrapped with <code>io.LimitReader</code></li> <li>Redirect safety with custom <code>CheckRedirect</code> validation</li> <li>Same-origin enforcement for relative reference resolution</li> </ul> <p>HTTP Validator:</p> <ul> <li>Body size limits (10 MiB default, configurable via <code>WithMaxBodySize()</code>)</li> <li>Concurrent pattern cache replaced with <code>sync.Map</code> and 1000-entry size cap</li> <li><code>additionalProperties: false</code> enforcement for unexpected properties</li> <li>Error sanitization using <code>%q</code> formatting and 200-character truncation for user-supplied values</li> </ul> <p>Generator:</p> <ul> <li>Path traversal prevention with <code>[a-z0-9_]</code> allowlist and <code>filepath.Base</code> safety</li> <li>Comment injection prevention through <code>cleanDescription</code> sanitization</li> <li>Generated clients default to <code>&amp;http.Client{Timeout: 30 * time.Second}</code></li> <li>OAuth2/OIDC URL scheme validation in generated code</li> <li>Discriminator JSON name escaping</li> </ul> <p>Cross-Cutting:</p> <ul> <li>Symlink safety via <code>os.Lstat</code> checks before file writes</li> <li>JSONPath recursion depth cap at 500</li> <li>Stdlib replacement sweep for hand-rolled form parsing</li> <li>Dependency update: <code>go-sdk</code> v1.3.0 \u2192 v1.3.1 (case-sensitive JSON unmarshaling security patch)</li> </ul>"},{"location":"whitepaper/#22-conclusion","title":"22. Conclusion","text":"<p>oastools represents a comprehensive solution for OpenAPI tooling in the Go ecosystem. Its strengths lie in several key areas.</p> <p>Complete OAS Coverage: Supporting versions 2.0 through 3.2.0 ensures compatibility with both legacy and cutting-edge specifications, including the latest JSON Schema 2020-12 alignment and streaming capabilities.</p> <p>Native Overlay Support: First-class implementation of the OpenAPI Overlay Specification v1.0.0 enables declarative transformations that integrate throughout the toolkit.</p> <p>Performance Optimization: The parse-once pattern, code-generated deep copy methods, JSON fast-path, and streaming extension extraction deliver 9-150x speedups for common workflows with up to 93% memory reduction for large JSON specifications.</p> <p>Security-First Design: Comprehensive OAuth2, PKCE, and OIDC support in generated clients, combined with v1.52.0 security hardening across the MCP server, parser, validator, and generator, addresses both code generation security and runtime protection.</p> <p>AI-Assisted Development: The built-in MCP server exposes all 17 tools over the Model Context Protocol, enabling AI development environments to query, validate, transform, and generate code from OpenAPI specifications with configurable caching and pagination.</p> <p>Minimal Dependencies: Only <code>go.yaml.in/yaml/v4</code>, <code>golang.org/x/text</code>, <code>golang.org/x/tools</code>, and <code>github.com/modelcontextprotocol/go-sdk</code> are required, minimizing attack surface and build complexity.</p> <p>Battle-Tested Quality: Validation against ten production APIs from Microsoft Graph to Petstore ensures real-world reliability across 19,000+ operations and 10,000+ schemas.</p> <p>The modular architecture allows teams to adopt individual packages as needed while benefiting from seamless integration when using multiple components together. Whether parsing a simple specification, querying API structure with the walk command, validating runtime HTTP traffic, integrating with AI tools via MCP, or generating complete client/server implementations with security, oastools provides the foundation for robust API development in Go.</p>"},{"location":"whitepaper/#23-references","title":"23. References","text":""},{"location":"whitepaper/#openapi-initiative-specifications","title":"OpenAPI Initiative Specifications","text":"<ol> <li> <p>OpenAPI Specification v2.0. OpenAPI Initiative. https://spec.openapis.org/oas/v2.0.html</p> </li> <li> <p>OpenAPI Specification v3.0.0. OpenAPI Initiative. https://spec.openapis.org/oas/v3.0.0.html</p> </li> <li> <p>OpenAPI Specification v3.0.3. OpenAPI Initiative. https://spec.openapis.org/oas/v3.0.3.html</p> </li> <li> <p>OpenAPI Specification v3.0.4. OpenAPI Initiative. https://spec.openapis.org/oas/v3.0.4.html</p> </li> <li> <p>OpenAPI Specification v3.1.0. OpenAPI Initiative. https://spec.openapis.org/oas/v3.1.0.html</p> </li> <li> <p>OpenAPI Specification v3.1.2. OpenAPI Initiative. https://spec.openapis.org/oas/v3.1.2.html</p> </li> <li> <p>OpenAPI Specification v3.2.0. OpenAPI Initiative. https://spec.openapis.org/oas/v3.2.0.html</p> </li> <li> <p>OpenAPI Overlay Specification v1.0.0. OpenAPI Initiative. https://spec.openapis.org/overlay/v1.0.0.html</p> </li> </ol>"},{"location":"whitepaper/#json-schema","title":"JSON Schema","text":"<ol> <li>JSON Schema: A Media Type for Describing JSON Documents (Draft 2020-12). https://json-schema.org/draft/2020-12/json-schema-core.html</li> </ol>"},{"location":"whitepaper/#ietf-rfcs","title":"IETF RFCs","text":"<ol> <li> <p>RFC 9535: JSONPath: Query Expressions for JSON. IETF. https://datatracker.ietf.org/doc/html/rfc9535</p> </li> <li> <p>RFC 7636: Proof Key for Code Exchange (PKCE). IETF. https://datatracker.ietf.org/doc/html/rfc7636</p> </li> <li> <p>RFC 6749: The OAuth 2.0 Authorization Framework. IETF. https://datatracker.ietf.org/doc/html/rfc6749</p> </li> <li> <p>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax. IETF. https://datatracker.ietf.org/doc/html/rfc3986</p> </li> <li> <p>RFC 6570: URI Template. IETF. https://datatracker.ietf.org/doc/html/rfc6570</p> </li> </ol>"},{"location":"whitepaper/#go-language","title":"Go Language","text":"<ol> <li> <p>The Go Programming Language Specification. https://go.dev/ref/spec</p> </li> <li> <p>Go 1.24 Release Notes. https://go.dev/doc/go1.24</p> </li> </ol>"},{"location":"whitepaper/#oastools-documentation","title":"oastools Documentation","text":"<ol> <li> <p>oastools GitHub Repository. https://github.com/erraggy/oastools</p> </li> <li> <p>oastools API Documentation. https://pkg.go.dev/github.com/erraggy/oastools</p> </li> <li> <p>oastools GitHub Pages. https://erraggy.github.io/oastools/</p> </li> </ol>"},{"location":"whitepaper/#package-documentation","title":"Package Documentation","text":"Package pkg.go.dev Deep Dive parser pkg.go.dev Deep Dive validator pkg.go.dev Deep Dive fixer pkg.go.dev Deep Dive converter pkg.go.dev Deep Dive joiner pkg.go.dev Deep Dive overlay pkg.go.dev Deep Dive differ pkg.go.dev Deep Dive generator pkg.go.dev Deep Dive builder pkg.go.dev Deep Dive httpvalidator pkg.go.dev Deep Dive walker pkg.go.dev Deep Dive oaserrors pkg.go.dev \u2014"},{"location":"whitepaper/#model-context-protocol","title":"Model Context Protocol","text":"<ol> <li> <p>Model Context Protocol Specification. https://modelcontextprotocol.io/</p> </li> <li> <p>Go MCP SDK. https://github.com/modelcontextprotocol/go-sdk</p> </li> </ol> <p>For the latest features, updates, and documentation, visit the GitHub repository or the documentation site.</p>"},{"location":"why-oastools/","title":"Why oastools?","text":"<p>oastools is designed around three principles: minimal dependencies, production-grade quality, and performance. This page explains what that means in practice.</p>"},{"location":"why-oastools/#minimal-dependencies","title":"\ud83d\udce6 Minimal Dependencies","text":"<pre><code>github.com/erraggy/oastools\n\u251c\u2500\u2500 go.yaml.in/yaml/v4                    (YAML parsing)\n\u251c\u2500\u2500 golang.org/x/text                     (Title casing)\n\u251c\u2500\u2500 golang.org/x/tools                    (Code generation \u2014 imports analysis)\n\u2514\u2500\u2500 github.com/modelcontextprotocol/go-sdk (MCP server)\n</code></pre> <p>Unlike many OpenAPI tools that pull in dozens of transitive dependencies, oastools is designed to be self-contained. The <code>stretchr/testify</code> dependency is test-only and not included in your production builds.</p>"},{"location":"why-oastools/#battle-tested-quality","title":"\u2705 Battle-Tested Quality","text":"<p>The entire toolchain is validated against a corpus of 10 real-world production APIs:</p> Domain APIs FinTech Stripe, Plaid Developer Tools GitHub, DigitalOcean Communications Discord (OAS 3.1) Enterprise Microsoft Graph (34MB, 18k+ operations) Location Google Maps Public US National Weather Service Reference Petstore (OAS 2.0) Productivity Asana <p>This corpus spans OAS 2.0 through 3.1, JSON and YAML formats, and document sizes from 20KB to 34MB.</p>"},{"location":"why-oastools/#performance","title":"\u26a1 Performance","text":"<p>Pre-parsed workflows eliminate redundant parsing when processing multiple operations:</p> Method Speedup <code>ValidateParsed()</code> 31x faster <code>ConvertParsed()</code> 47x faster <code>JoinParsed()</code> 150x faster <code>DiffParsed()</code> 81x faster <code>FixParsed()</code> ~60x faster <code>ApplyParsed()</code> ~11x faster <p>JSON marshaling is optimized for 25-32% better performance with 29-37% fewer allocations. See the whitepaper performance section for detailed analysis.</p>"},{"location":"why-oastools/#type-safe-document-cloning","title":"\ud83d\udd12 Type-Safe Document Cloning","text":"<p>All parser types include generated <code>DeepCopy()</code> methods for safe document mutation. Unlike JSON marshal/unmarshal approaches used by other tools, oastools provides:</p> <ul> <li>Type preservation \u2014 Polymorphic fields maintain their actual types (e.g., <code>Schema.Type</code> as <code>string</code> vs <code>[]string</code> for OAS 3.1)</li> <li>Version-aware copying \u2014 Handles OAS version differences correctly (<code>ExclusiveMinimum</code> as bool in 3.0 vs number in 3.1)</li> <li>Extension preservation \u2014 All <code>x-*</code> extension fields are deep copied</li> <li>Performance \u2014 Direct struct copying without serialization overhead</li> </ul> <pre><code>// Safe mutation without affecting the original\ncopy := result.OAS3Document.DeepCopy()\ncopy.Info.Title = \"Modified API\"\n</code></pre> <p>All OAS types also provide <code>Equals()</code> methods for structural comparison.</p>"},{"location":"why-oastools/#enterprise-grade-error-handling","title":"\ud83d\udee1\ufe0f Enterprise-Grade Error Handling","text":"<p>The <code>oaserrors</code> package provides structured error types that work with Go's standard <code>errors.Is()</code> and <code>errors.As()</code>:</p> <pre><code>import (\n    \"errors\"\n    \"github.com/erraggy/oastools/oaserrors\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nresult, err := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nif err != nil {\n    // Check error category with errors.Is()\n    if errors.Is(err, oaserrors.ErrPathTraversal) {\n        log.Fatal(\"Security: path traversal attempt blocked\")\n    }\n\n    // Extract details with errors.As()\n    var refErr *oaserrors.ReferenceError\n    if errors.As(err, &amp;refErr) {\n        log.Printf(\"Failed to resolve: %s (type: %s)\", refErr.Ref, refErr.RefType)\n    }\n}\n</code></pre> <p>Error types include <code>ParseError</code>, <code>ReferenceError</code>, <code>ValidationError</code>, <code>ResourceLimitError</code>, <code>ConversionError</code>, and <code>ConfigError</code>.</p>"},{"location":"why-oastools/#configurable-resource-limits","title":"\u2699\ufe0f Configurable Resource Limits","text":"<p>Protect against resource exhaustion with configurable limits:</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"api.yaml\"),\n    parser.WithMaxRefDepth(50),           // Max $ref nesting (default: 100)\n    parser.WithMaxCachedDocuments(200),   // Max cached external docs (default: 100)\n    parser.WithMaxFileSize(20*1024*1024), // Max file size in bytes (default: 10MB)\n)\n</code></pre>"},{"location":"why-oastools/#http-client-configuration","title":"\ud83c\udf10 HTTP Client Configuration","text":"<p>For advanced scenarios like custom timeouts, proxies, or authentication:</p> <pre><code>// Custom timeout for slow networks\nclient := &amp;http.Client{Timeout: 120 * time.Second}\nresult, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://api.example.com/openapi.yaml\"),\n    parser.WithHTTPClient(client),\n)\n</code></pre> <pre><code>// Corporate proxy\nproxyURL, _ := url.Parse(\"http://proxy.corp:8080\")\nclient := &amp;http.Client{\n    Transport: &amp;http.Transport{Proxy: http.ProxyURL(proxyURL)},\n}\nresult, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://internal-api.corp/spec.yaml\"),\n    parser.WithHTTPClient(client),\n)\n</code></pre> <p>When a custom client is provided, <code>InsecureSkipVerify</code> is ignored \u2014 configure TLS on your client's transport instead.</p>"},{"location":"blog/building-the-mcp-server/","title":"Building an MCP Server for OpenAPI in 48 Hours","text":"<p>How corpus-driven development turned a prototype into a production-grade tool server across 6 releases.</p> <p>Published: February 2026 | Releases: v1.51.0 \u2013 v1.51.5 | Pull Requests: 8 PRs, 8,274 lines of Go</p>"},{"location":"blog/building-the-mcp-server/#the-pitch","title":"The Pitch","text":"<p>OpenAPI specs are everywhere, but working with them from AI coding assistants is painful. You can ask an LLM to read a YAML file, but it has no understanding of what <code>$ref: '#/components/schemas/Pet'</code> actually resolves to, whether a spec is valid, or how two API versions differ. The LLM sees text; it needs structure.</p> <p>Model Context Protocol (MCP) changes this equation. Instead of asking the LLM to interpret raw YAML, you give it tools \u2014 validate this spec, walk its operations, diff these two versions \u2014 and it calls them like functions, receiving typed JSON back. The LLM reasons about structure instead of parsing syntax.</p> <p>oastools already had all the capabilities: parsing, validation, fixing, diffing, joining, converting, overlays, code generation, and deep traversal with filtering. They just needed to be exposed over MCP's JSON-RPC protocol.</p> <p>What followed was an unexpectedly intense 48-hour development sprint.</p>"},{"location":"blog/building-the-mcp-server/#day-0-the-foundation-v1510","title":"Day 0: The Foundation (v1.51.0)","text":"<p>February 13, 2026 \u2014 PR #310</p> <p>The initial implementation landed as a single PR: 15 MCP tools covering every oastools capability, a CLI subcommand (<code>oastools mcp</code>), a Claude Code plugin with guided skills, and documentation.</p>"},{"location":"blog/building-the-mcp-server/#architecture","title":"Architecture","text":"<p>The MCP server lives in <code>internal/mcpserver/</code> \u2014 deliberately internal, since the wire protocol is the public API, not the Go types. Each tool follows the same pattern:</p> <pre><code>Input struct (JSON Schema) \u2192 Resolve spec \u2192 Call library package \u2192 Output struct (JSON)\n</code></pre> <p>The Go MCP SDK uses generics for type-safe tool registration. You define an input struct with <code>jsonschema</code> tags, and the SDK handles JSON Schema generation, validation, and deserialization:</p> <pre><code>type validateInput struct {\n    Spec       specInput `json:\"spec\"       jsonschema:\"required,description=The OAS document\"`\n    Strict     bool      `json:\"strict\"     jsonschema:\"description=Enable stricter validation\"`\n    NoWarnings bool      `json:\"no_warnings\" jsonschema:\"description=Suppress warnings\"`\n}\n</code></pre> <p>A shared <code>specInput</code> type handles the three input modes (file path, URL, inline content) with mutual exclusivity validation. This one type serves all 15 tools (and later, the 2 added in v1.51.3).</p>"},{"location":"blog/building-the-mcp-server/#the-15-tools","title":"The 15 tools","text":"<ul> <li>Spec lifecycle: <code>parse</code>, <code>validate</code>, <code>fix</code>, <code>convert</code></li> <li>Multi-spec: <code>diff</code>, <code>join</code></li> <li>Overlays: <code>overlay_apply</code>, <code>overlay_validate</code></li> <li>Code generation: <code>generate</code></li> <li>Walk tools: <code>walk_paths</code>, <code>walk_operations</code>, <code>walk_schemas</code>, <code>walk_parameters</code>, <code>walk_responses</code>, <code>walk_security</code></li> </ul> <p>Each walk tool supports filtering by relevant dimensions (path pattern, HTTP method, status code, schema type, parameter location) and a <code>detail</code> flag for full objects vs. summaries.</p>"},{"location":"blog/building-the-mcp-server/#design-decisions","title":"Design decisions","text":"<p>Format preservation. If you feed in JSON, you get JSON back. YAML in, YAML out. This seems obvious but matters enormously for LLM workflows where the agent writes a fixed spec back to disk \u2014 it shouldn't silently convert your YAML project to JSON.</p> <p>Structured summaries by default. The <code>parse</code> tool returns counts and metadata, not the entire parsed document. Walk tools return compact summaries. An LLM working with a 36MB spec (MS Graph has 16,098 operations) needs aggregated intelligence, not a firehose.</p> <p>Consistent error handling. Every error returns as an MCP tool error (<code>IsError: true</code>) rather than crashing the server. The agent sees the error, adjusts its input, and retries. This is critical for autonomous workflows.</p> <p>At this point, 8,000+ tests passed, and the server worked. Ship it.</p>"},{"location":"blog/building-the-mcp-server/#day-1-morning-the-overflow-problem-v1511","title":"Day 1, Morning: The Overflow Problem (v1.51.1)","text":"<p>February 14, 2026 \u2014 PR #315</p> <p>We immediately ran the MCP tools against our corpus of 10 real-world OpenAPI specs: Petstore, Google Maps, NWS Weather, Asana, Discord, Plaid, DigitalOcean, Stripe, GitHub, and Microsoft Graph. The results were... large:</p> Tool Spec Output size Items <code>validate</code> GitHub API 367 KB 2,158 errors <code>fix</code> GitHub API 381 KB 2,051 fixes <code>diff</code> Stripe vs GitHub 591 KB 3,445 changes <p>Half a megabyte of validation errors in a single tool response. LLM context windows are precious \u2014 we were burning them on pagination that should happen server-side.</p>"},{"location":"blog/building-the-mcp-server/#the-solution-paginatet","title":"The solution: <code>paginate[T]</code>","text":"<p>A generic helper that all array-returning tools share:</p> <pre><code>func paginate[T any](items []T, offset, limit int) []T\n</code></pre> <p>Nine tools gained <code>offset</code> and <code>limit</code> parameters. Default limit: 100. Totals (<code>error_count</code>, <code>fix_count</code>, <code>breaking_count</code>) always reflect the full result set \u2014 the agent knows there are 2,158 errors even when only seeing 100 at a time. A <code>returned</code> field tells the agent how many items are in the current page.</p> <p>With <code>limit=5</code>, that 367KB validate response drops to ~0.8KB. The agent can triage the first page, apply filters (<code>no_warnings: true</code>), and drill deeper as needed.</p>"},{"location":"blog/building-the-mcp-server/#day-1-afternoon-completing-the-pipeline-v1512","title":"Day 1, Afternoon: Completing the Pipeline (v1.51.2)","text":"<p>February 14, 2026 \u2014 PR #318</p> <p>Corpus testing also revealed a workflow gap: the <code>fix</code> tool could apply fixes but couldn't write the result to disk. An agent using the MCP server had to fall back to CLI commands for persistence. Meanwhile, <code>convert</code>, <code>join</code>, and <code>overlay_apply</code> all had <code>output</code> parameters.</p> <p>This was a quick fix \u2014 add <code>output</code> to <code>fixInput</code>, add <code>written_to</code> to <code>fixOutput</code> \u2014 but it completed a crucial pattern: every transform tool can now persist its results, enabling multi-tool pipelines entirely through MCP:</p> <pre><code>fix(spec, output=\"/tmp/fixed.yaml\")\n  \u2192 validate(file=\"/tmp/fixed.yaml\")\n  \u2192 convert(file=\"/tmp/fixed.yaml\", target=\"3.1\", output=\"/tmp/converted.yaml\")\n</code></pre>"},{"location":"blog/building-the-mcp-server/#plugin-maturation","title":"Plugin maturation","text":"<p>This release also restructured the Claude Code plugin:</p> <ul> <li>Version coupling: Plugin version now tracks the binary version instead of independent semver. A <code>SessionStart</code> hook warns when they diverge.</li> <li>Skills auto-discovery: Moved from flat <code>skills/*.md</code> to <code>skills/*/SKILL.md</code> subdirectories, matching Claude Code's auto-discovery convention.</li> <li>Workflow docs: Added \"Persisting Results\" and \"Pipelining Tools\" sections to teach agents multi-tool chaining.</li> </ul>"},{"location":"blog/building-the-mcp-server/#corpus-bugs-found-and-fixed","title":"Corpus bugs found (and fixed)","text":"<p>Running the tools against real specs also uncovered three bugs in the underlying library:</p> <ol> <li>Generator schema collision (Discord): Schema names ending in \"Request\" collided with generated server wrapper structs. Fixed with a suffix cascade (<code>Request</code> \u2192 <code>Input</code> \u2192 <code>Req</code> \u2192 numeric fallback).</li> <li>Converter formData passthrough (Petstore 2.0\u21923.x): <code>in: \"formData\"</code> parameters were passed through unconverted instead of building a <code>requestBody</code>.</li> <li>Converter downconversion loss (NWS 3.0\u21922.0): Composite schemas lost their <code>type</code> field, and header refs went unresolved.</li> </ol> <p>None of these were found by unit tests. They needed real-world specs with real-world complexity.</p>"},{"location":"blog/building-the-mcp-server/#day-1-night-the-aggregation-leap-v1513","title":"Day 1, Night: The Aggregation Leap (v1.51.3)","text":"<p>February 15, 2026 \u2014 PR #321</p> <p>This was the largest single feature release. We'd been using the walk tools in a loop \u2014 \"group operations by tag\" meant calling <code>walk_operations</code> once per tag and counting results. For MS Graph with 457 tags, that's 457 API calls to answer one question.</p>"},{"location":"blog/building-the-mcp-server/#group_by","title":"<code>group_by</code>","text":"<p>Every walk tool gained a <code>group_by</code> parameter that returns <code>{key, count}</code> groups sorted by count:</p> <pre><code>{\"spec\": {\"file\": \"github-api.json\"}, \"group_by\": \"method\"}\n</code></pre> <pre><code>{\n  \"total\": 1078,\n  \"groups\": [\n    {\"key\": \"GET\", \"count\": 568},\n    {\"key\": \"POST\", \"count\": 171},\n    {\"key\": \"DELETE\", \"count\": 166},\n    {\"key\": \"PUT\", \"count\": 112},\n    {\"key\": \"PATCH\", \"count\": 61}\n  ]\n}\n</code></pre> <p>One call instead of five. For the corpus analysis of 10 specs across multiple dimensions, <code>group_by</code> reduced hundreds of calls to dozens.</p> <p>The implementation uses a generic <code>groupAndSort[T any]</code> helper with filter-before-group semantics (WHERE then GROUP BY, like SQL). Pagination applies to grouped results too.</p>"},{"location":"blog/building-the-mcp-server/#two-new-walk-tools","title":"Two new walk tools","text":"<p><code>walk_headers</code> fills a genuine gap \u2014 before this, finding response headers required <code>walk_responses</code> with <code>detail=true</code> and manual inspection. Headers are crucial for understanding rate limiting, CORS, and pagination patterns. Discord's spec has 5 rate-limit headers across 240 operations (1,200 header instances).</p> <p><code>walk_refs</code> shows dependency graphs \u2014 which schemas reference which, with counts. Discord's <code>SnowflakeType</code> (554 references) reveals more about the API's design than any documentation. GitHub's <code>owner</code>/<code>repo</code> parameters (480/479 refs) reveal the repo-centric architecture.</p>"},{"location":"blog/building-the-mcp-server/#glob-style-filtering","title":"Glob-style filtering","text":"<p>Path filters gained <code>**</code> for multi-segment matching:</p> <ul> <li><code>/users/*</code> matches <code>/users/{id}</code> but not <code>/users/{id}/posts</code></li> <li><code>/drives/**/workbook/**</code> matches any depth under both segments</li> </ul> <p>Schema name filters gained glob support too: <code>Pet*</code> matches <code>Pet</code>, <code>PetStore</code>, <code>PetResponse</code>.</p> <p>Tool count: 15 \u2192 17.</p>"},{"location":"blog/building-the-mcp-server/#day-2-afternoon-performance-and-polish-v1514","title":"Day 2, Afternoon: Performance and Polish (v1.51.4)","text":"<p>February 15, 2026 \u2014 PR #324</p> <p>With <code>group_by</code> in hand, we ran a systematic corpus analysis \u2014 all 10 specs, every dimension. The full results are in the Corpus Analysis, but here are some highlights that surprised us:</p> <p>Corpus Analysis Highlights</p> <p>The analysis covers 19,173 operations across 10 real-world specs spanning 3 orders of magnitude (20 to 16,098 operations). Some of the most interesting patterns:</p> <ul> <li>Plaid is 99.4% POST \u2014 pure RPC-over-HTTP, every endpoint is a command</li> <li>MS Graph uses 4 integers total across 4,294 schemas \u2014 their OData convention prefers <code>number</code> for everything</li> <li>Discord's <code>SnowflakeType</code> is referenced 554 times \u2014 one schema reveals their entire ID architecture</li> <li>GitHub has 20,123 string schemas (63% of all component schemas) \u2014 enums and scalars expanded individually</li> <li>Stripe documents zero response headers despite having rate limits in practice</li> <li>NWS uses User-Agent as a security scheme \u2014 creative abuse tracking via a required header</li> </ul> <p>Each pattern tells a story about API design philosophy. Read the full analysis \u2192</p> <p>But the analysis also exposed pain points. Every <code>group_by</code> call on the same spec meant re-parsing it. MS Graph (36MB YAML) takes noticeable time to parse. Multiply by 8 walk tools and it's frustrating.</p>"},{"location":"blog/building-the-mcp-server/#session-scoped-spec-cache","title":"Session-scoped spec cache","text":"<p>An LRU cache (max 10 entries) stores parsed specs for the session duration:</p> <ul> <li>File inputs: keyed by absolute path + modification time \u2014 invalidates automatically on file change</li> <li>Content inputs: keyed by SHA-256 hash \u2014 identical inline specs reuse cached results</li> <li>URL inputs: bypass cache (remote content may change)</li> </ul> <p>Read-only tools (<code>parse</code>, <code>validate</code>, <code>walk_*</code>, <code>diff</code>, <code>generate</code>) use the cache. Mutating tools (<code>fix</code>, <code>convert</code>, <code>join</code>, <code>overlay_apply</code>) bypass it since they modify the document.</p>"},{"location":"blog/building-the-mcp-server/#better-labels","title":"Better labels","text":"<p>Empty group keys were confusing. <code>\"\"</code> in <code>group_by=type</code> results means \"schema without an explicit type\" \u2014 compositions, <code>$ref</code> wrappers. Now these display meaningful labels:</p> <ul> <li><code>(untyped)</code> for typeless schemas</li> <li><code>(ref)</code> for unresolved <code>$ref</code> parameters</li> <li><code>(component)</code> for component-level responses</li> </ul>"},{"location":"blog/building-the-mcp-server/#new-aggregation-dimensions","title":"New aggregation dimensions","text":"<ul> <li><code>walk_refs</code> gained <code>group_by=node_type</code> (schema vs. parameter vs. response)</li> <li><code>walk_paths</code> gained <code>group_by=segment</code> (first path segment for API structure overview)</li> </ul>"},{"location":"blog/building-the-mcp-server/#parse-truncation","title":"Parse truncation","text":"<p>DigitalOcean's <code>info.description</code> was 8,000 characters \u2014 their entire API introduction with curl examples and CORS docs. The <code>parse</code> tool now truncates to 200 characters in summary mode, with rune-safe truncation so multi-byte UTF-8 characters are never split mid-codepoint.</p>"},{"location":"blog/building-the-mcp-server/#day-2-evening-final-edge-cases-v1515","title":"Day 2, Evening: Final Edge Cases (v1.51.5)","text":"<p>February 15, 2026 \u2014 PRs #327, #329, #330</p> <p>The final release addressed three distinct issues found during continued corpus stress-testing.</p>"},{"location":"blog/building-the-mcp-server/#detail-mode-was-too-verbose","title":"Detail mode was too verbose","text":"<p>Walk tools with <code>detail=true</code> returned up to 100 full objects \u2014 each 2-10KB of JSON. For MS Graph, that's potentially 1MB per call. A shared <code>detailLimit()</code> helper now defaults detail mode to 25 results (explicitly overridable).</p>"},{"location":"blog/building-the-mcp-server/#parameter-filters-silently-failed","title":"Parameter filters silently failed","text":"<p><code>walk_parameters</code> with <code>in=query</code> returned 0 results on GitHub's spec, even though it has hundreds of query parameters. The problem: 86% of GitHub's parameters use <code>$ref</code>, and unresolved refs don't have an <code>in</code> field. The fix: auto-resolve refs when <code>in</code> or <code>name</code> filters are specified, so users don't need to know about <code>resolve_refs=true</code>.</p>"},{"location":"blog/building-the-mcp-server/#a-naming-mismatch-caused-100-first-attempt-failures","title":"A naming mismatch caused 100% first-attempt failures","text":"<p>The <code>join</code> tool documented <code>accept_left</code>/<code>accept_right</code> (underscored) as collision strategies, but the underlying joiner package uses <code>accept-left</code>/<code>accept-right</code> (hyphenated). Every LLM agent passed invalid values on first attempt, got an error, and had to retry. A one-line fix in the <code>jsonschema</code> tags, but it eliminated a guaranteed round-trip for every join call.</p>"},{"location":"blog/building-the-mcp-server/#circular-reference-resolution-bonus-parser-fix","title":"Circular reference resolution (bonus: parser fix)","text":"<p>While testing <code>walk_parameters</code> auto-resolution, we discovered that the parser's <code>resolve_refs</code> mode had a nuclear fallback: detecting any circular <code>$ref</code> caused it to discard all resolution work. The fix was surgical \u2014 only truly circular nodes remain as <code>$ref</code> pointers; everything else resolves normally. As a bonus, the new <code>decodeFromMap</code> approach eliminated an intermediate <code>[]byte</code> allocation that was inflating memory 10x on large specs (GitHub API: 11.6MB input \u2192 108MB intermediate \u2192 now eliminated).</p>"},{"location":"blog/building-the-mcp-server/#the-feedback-loop","title":"The Feedback Loop","text":"<p>Looking back, the most interesting aspect isn't any single feature \u2014 it's the development cadence. Six releases in 48 hours, each driven by the same cycle:</p> <pre><code>Build \u2192 Test against real specs \u2192 Discover gap \u2192 Fix \u2192 Ship\n</code></pre> <p>The corpus of 10 specs acted as a forcing function. Every new feature immediately met reality:</p> <ul> <li>Pagination was born from 367KB validate responses</li> <li><code>group_by</code> was born from looping <code>walk_operations</code> 457 times for MS Graph</li> <li>Spec caching was born from re-parsing 36MB of YAML on every call</li> <li>Auto-resolution was born from <code>in=query</code> returning 0 results</li> <li>Detail limits were born from 1MB detail responses</li> <li>Strategy name fix was born from 100% first-attempt failures</li> </ul> <p>The corpus didn't just find bugs \u2014 it shaped the API surface. Features like <code>group_by</code>, auto-resolution, and meaningful group labels all emerged from watching the tools fail in practice rather than from upfront design.</p>"},{"location":"blog/building-the-mcp-server/#by-the-numbers","title":"By the Numbers","text":"Metric Value Development window 48 hours (Feb 13\u201315, 2026) Releases 6 (v1.51.0 \u2013 v1.51.5) Pull requests 8 MCP-focused PRs MCP tools 15 \u2192 17 Lines of Go 8,274 across 37 files Test count 8,000 \u2192 8,200+ Corpus specs tested 10 (19,173 total operations) Corpus size range 20 operations (Petstore) to 16,098 (MS Graph) Features added Pagination, group_by, caching, walk_headers, walk_refs, glob matching, auto-resolution, detail limits Bugs found via corpus 6 (3 library, 3 MCP-specific)"},{"location":"blog/building-the-mcp-server/#getting-started","title":"Getting Started","text":"<pre><code># Install\nbrew install erraggy/oastools/oastools\n\n# Start the MCP server\noastools mcp\n\n# Or add to Claude Code\nclaude mcp add --transport stdio oastools -- oastools mcp\n</code></pre> <p>The full tool reference is in the MCP Server documentation.</p>"},{"location":"examples/","title":"oastools Examples","text":"<p>Complete, runnable examples demonstrating the full oastools ecosystem across parsing, validation, transformation, and code generation.</p>"},{"location":"examples/#quick-start","title":"Quick Start","text":"Time Category Example Description 2 min Getting Started quickstart/ Parse and validate a minimal spec 5 min Getting Started validation-pipeline/ Complete validation with error reporting 5 min Workflows pipeline-compositions/ Chain multiple oastools operations 5 min Workflows fixer-showcase/ All available fix types demonstrated 3 min Workflows validate-and-fix/ Auto-fix common spec errors 3 min Workflows version-conversion/ Convert OAS 2.0 \u2192 3.0.3 4 min Workflows version-migration/ OAS 3.1/3.2 upgrades and downgrades 4 min Workflows multi-api-merge/ Merge microservice specs 3 min Workflows collision-resolution/ Handle schema collisions 3 min Workflows schema-deduplication/ Consolidate identical schemas 4 min Workflows schema-renaming/ Preserve both schemas with renaming 4 min Workflows breaking-change-detection/ CI/CD breaking change gates 3 min Workflows overlay-transformations/ Environment-specific customizations 5 min Workflows http-validation/ Runtime request/response validation 5 min Programmatic API builder/ Build specs from Go code + ServerBuilder 3 min Walker api-statistics/ Collect API statistics in single pass 4 min Walker security-audit/ Audit API for security issues 3 min Walker vendor-extensions/ Add vendor extensions for tooling 3 min Walker public-api-filter/ Filter internal endpoints 4 min Walker api-documentation/ Generate Markdown documentation 4 min Walker reference-collector/ Analyze schema references 10 min Code Generation petstore/ Full client/server generation"},{"location":"examples/#examples-by-category","title":"Examples by Category","text":""},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>Best for first-time users learning oastools.</p> Example Description quickstart/ 100-line example demonstrating parse \u2192 validate workflow validation-pipeline/ Complete validation with source maps and severity classification"},{"location":"examples/#workflow-examples","title":"Workflow Examples","text":"<p>Common OpenAPI transformation patterns covering 6 packages.</p> Example Package Description pipeline-compositions/ multiple Chain convert\u2192fix\u2192join\u2192generate pipelines fixer-showcase/ fixer All 6 fix types with before/after validate-and-fix/ fixer Parse, validate, auto-fix common errors version-conversion/ converter Convert OAS 2.0 (Swagger) \u2192 OAS 3.0.3 version-migration/ converter OAS 3.1/3.2 upgrades, lossy downgrades multi-api-merge/ joiner Merge specs with collision resolution collision-resolution/ joiner fail-on-collision, accept-left, accept-right schema-deduplication/ joiner deduplicate-equivalent, semantic-dedup schema-renaming/ joiner rename-left/right, templates, namespaces breaking-change-detection/ differ Detect breaking changes between versions overlay-transformations/ overlay Apply JSONPath-based transformations http-validation/ httpvalidator Runtime HTTP request/response validation"},{"location":"examples/#programmatic-api","title":"Programmatic API","text":"<p>Build OpenAPI specifications from Go code.</p> Example Package Description builder/ builder Fluent API + ServerBuilder for runnable servers"},{"location":"examples/#walker-examples","title":"Walker Examples","text":"<p>Document traversal patterns for analysis, mutation, and filtering.</p> Example Category Description api-statistics/ Analysis Collect API statistics in a single traversal pass security-audit/ Validation Audit API for security issues and compliance vendor-extensions/ Mutation Add vendor extensions for downstream tooling public-api-filter/ Filtering Extract public API, filter internal endpoints api-documentation/ Reporting Generate Markdown documentation from spec reference-collector/ Integration Collect schema references and detect cycles"},{"location":"examples/#code-generation","title":"Code Generation","text":"<p>Generate production-ready Go client and server code.</p> Example Description petstore/ Complete code generation with OAuth2, OIDC, chi router"},{"location":"examples/#feature-matrix","title":"Feature Matrix","text":"Feature quickstart validation-pipeline workflows builder walker petstore Parser API \u2713 \u2713 \u2713 \u2713 Validator API \u2713 \u2713 \u2713 \u2713 Fixer API \u2713 Converter API \u2713 Joiner API \u2713 Differ API \u2713 Overlay API \u2713 HTTPValidator API \u2713 Builder API \u2713 ServerBuilder \u2713 Walker API \u2713 Source Maps \u2713 Code Generation \u2713 Client Generation \u2713 Server Generation \u2713 OAuth2 Flows \u2713 OIDC Discovery \u2713 <p>Package Coverage: 11/11 packages demonstrated</p>"},{"location":"examples/#oas-version-coverage","title":"OAS Version Coverage","text":"Version Examples OAS 2.0 (Swagger) petstore, version-conversion OAS 3.0.x quickstart, all workflows OAS 3.2.0 builder Any version validation-pipeline (accepts any OAS file)"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>Each example is a standalone Go module. To run any example:</p> <pre><code>cd examples/&lt;category&gt;/&lt;example-name&gt;\ngo run main.go\n</code></pre> <p>Or build and run:</p> <pre><code>cd examples/&lt;category&gt;/&lt;example-name&gt;\ngo build -o example .\n./example\n</code></pre>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#parse-once-optimization","title":"Parse-Once Optimization","text":"<p>All workflow examples demonstrate the parse-once pattern:</p> <pre><code>parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"spec.yaml\"))\n\n// Reuse for multiple operations (9-154x faster)\nfixer.FixWithOptions(fixer.WithParsed(parsed))\nvalidator.ValidateWithOptions(validator.WithParsed(parsed))\n</code></pre>"},{"location":"examples/#functional-options","title":"Functional Options","text":"<p>All packages use the functional options pattern:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n</code></pre>"},{"location":"examples/#learn-more","title":"Learn More","text":"<ul> <li>CLI Reference</li> <li>Developer Guide</li> <li>Package Documentation:</li> <li>parser</li> <li>validator</li> <li>fixer</li> <li>converter</li> <li>joiner</li> <li>differ</li> <li>overlay</li> <li>httpvalidator</li> <li>builder</li> <li>walker</li> <li>generator</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/quickstart/","title":"Quickstart Example","text":"<p>A minimal 5-minute introduction to oastools, demonstrating the parse and validate workflow.</p>"},{"location":"examples/quickstart/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to parse an OpenAPI specification with oastools</li> <li>How to validate a specification against OAS schema rules</li> <li>How to access parsed document structure programmatically</li> </ul>"},{"location":"examples/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> <li>oastools module dependency (auto-fetched)</li> </ul>"},{"location":"examples/quickstart/#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/erraggy/oastools.git\ncd oastools/examples/quickstart\n</code></pre> <ol> <li>Run the example:</li> </ol> <pre><code>go run main.go\n</code></pre> <ol> <li>Expected output:</li> </ol> <pre><code>oastools Quickstart\n===================\n\n[1/3] Parsing OpenAPI specification...\n      Version: 3.0.3\n      Format: yaml\n\n[2/3] Validating against OAS schema...\n      Valid: true\n      Errors: 0\n      Warnings: 0\n\n[3/3] Accessing document structure...\n      API Title: Quickstart API\n      API Version: 1.0.0\n      Paths: 1\n      Schemas: 1\n\n      Paths defined:\n        - /hello\n      Schemas defined:\n        - Greeting\n\n---\nQuickstart complete!\n</code></pre>"},{"location":"examples/quickstart/#files","title":"Files","text":"File Purpose <code>spec.yaml</code> Minimal OpenAPI 3.0.3 specification (27 lines) <code>main.go</code> Demonstrates parse \u2192 validate \u2192 inspect workflow <code>go.mod</code> Go module definition"},{"location":"examples/quickstart/#key-concepts","title":"Key Concepts","text":"<p>Parse-Once Pattern: The example uses <code>parser.ParseWithOptions()</code> to parse the specification once, then passes the result to <code>v.ValidateParsed()</code> (a method on <code>*validator.Validator</code>). This avoids re-parsing and provides significant performance improvement for repeated operations.</p> <p>Version-Agnostic Access: The <code>AsAccessor()</code> method returns a <code>DocumentAccessor</code> interface that works identically for OAS 2.0, 3.0.x, 3.1.x, and 3.2.0 documents, abstracting away version-specific structure differences.</p> <p>Validation Severity Levels: oastools uses four severity levels:</p> <ul> <li><code>Critical</code> - Specification cannot be processed</li> <li><code>Error</code> - Violates OpenAPI specification requirements</li> <li><code>Warning</code> - Best practice recommendations</li> <li><code>Info</code> - Informational notes</li> </ul>"},{"location":"examples/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Validation Pipeline Example - Detailed validation workflow with source maps</li> <li>PetStore Generator Example - Generate Go client/server code</li> <li>Parser Deep Dive</li> <li>Validator Deep Dive</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/validation-pipeline/","title":"Validation Pipeline Example","text":"<p>Demonstrates a complete validation pipeline with source map integration for IDE-friendly line numbers in error messages.</p>"},{"location":"examples/validation-pipeline/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to parse and validate any OpenAPI specification</li> <li>How to enable source maps for line numbers in errors</li> <li>How to classify and report validation issues by severity</li> <li>The parse-once optimization pattern for better performance</li> </ul>"},{"location":"examples/validation-pipeline/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> <li>An OpenAPI specification file to validate</li> </ul>"},{"location":"examples/validation-pipeline/#quick-start","title":"Quick Start","text":"<ol> <li>Run against the petstore spec:</li> </ol> <pre><code>cd examples/validation-pipeline\ngo run main.go ../petstore/spec/petstore-v2.json\n</code></pre> <ol> <li>Expected output:</li> </ol> <pre><code>Validation Pipeline\n===================\n\nInput: ../petstore/spec/petstore-v2.json\n\n[1/3] Parsing specification...\n      OAS Version: 2.0\n      Format: json\n      Size: 13.5 KiB\n\n[2/3] Validating against OpenAPI schema...\n\n[3/3] Validation Results\n      Valid: true\n      Errors: 0\n      Warnings: 0\n\n---\nValidation PASSED\n</code></pre> <ol> <li>Try with your own specification:</li> </ol> <pre><code>go run main.go /path/to/your/openapi.yaml\n</code></pre>"},{"location":"examples/validation-pipeline/#files","title":"Files","text":"File Purpose <code>main.go</code> Complete validation pipeline with error reporting <code>go.mod</code> Go module definition"},{"location":"examples/validation-pipeline/#key-concepts","title":"Key Concepts","text":"<p>Source Map Integration: By enabling <code>parser.WithSourceMap(true)</code> and passing it to the validator via <code>v.SourceMap = result.SourceMap</code>, validation errors include line numbers. This is essential for IDE integration and debugging.</p> <p>Severity Levels: oastools uses four severity levels:</p> <ul> <li><code>CRITICAL</code> - Specification cannot be processed</li> <li><code>ERROR</code> - Violates OpenAPI specification requirements</li> <li><code>WARNING</code> - Best practice recommendations</li> <li><code>INFO</code> - Informational notes</li> </ul> <p>Parse-Once Pattern: The example parses once with <code>ParseWithOptions()</code> then validates with <code>ValidateParsed()</code>. This avoids re-parsing the document and provides 9-154x performance improvement for multi-step workflows.</p> <p>Exit Codes: The example exits with code 0 for success and code 1 for validation failures, making it suitable for CI/CD pipelines.</p>"},{"location":"examples/validation-pipeline/#cli-equivalent","title":"CLI Equivalent","text":"<p>This example replicates the functionality of:</p> <pre><code>oastools validate --source-map openapi.yaml\n</code></pre>"},{"location":"examples/validation-pipeline/#next-steps","title":"Next Steps","text":"<ul> <li>Quickstart Example - Minimal introduction</li> <li>PetStore Example - Code generation</li> <li>Validator Deep Dive</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/petstore/","title":"PetStore Example","text":"<p>A comprehensive code generation example demonstrating the full capabilities of oastools generator, including client, server, security, and credential management.</p>"},{"location":"examples/petstore/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to generate complete Go client and server code from an OpenAPI specification</li> <li>Framework variants: stdlib (net/http) and Chi router</li> <li>Security features: OAuth2 flows, OIDC discovery, credential management</li> </ul>"},{"location":"examples/petstore/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> <li>oastools CLI installed (<code>go install github.com/erraggy/oastools/cmd/oastools@latest</code>)</li> </ul>"},{"location":"examples/petstore/#variants","title":"Variants","text":"Directory Router Description stdlib/ net/http Standard library HTTP server with path matching chi/ go-chi/chi Chi router with native path parameter extraction"},{"location":"examples/petstore/#source-specification","title":"Source Specification","text":"<ul> <li>File: spec/petstore-v2.json</li> <li>API: Swagger Petstore API</li> <li>OAS Version: 2.0 (Swagger)</li> <li>Source URL: https://petstore.swagger.io/v2/swagger.json</li> </ul>"},{"location":"examples/petstore/#generated-features","title":"Generated Features","text":"<p>Both variants include:</p> Feature Files Generated Type definitions <code>types.go</code> HTTP client <code>client.go</code> Server interface <code>server.go</code> Router <code>server_router.go</code> Request binding <code>server_binder.go</code> Response writers <code>server_responses.go</code> Validation middleware <code>server_middleware.go</code> Stub implementations <code>server_stubs.go</code> OAuth2 flows <code>oauth2_petstore_auth.go</code> OIDC discovery <code>oidc_discovery.go</code> Credential management <code>credentials.go</code> Security enforcement <code>security_enforce.go</code>, <code>security_helpers.go</code>"},{"location":"examples/petstore/#regeneration","title":"Regeneration","text":"<p>stdlib variant:</p> <pre><code>oastools generate --server --server-all --client --security-enforce \\\n  --oauth2-flows --oidc-discovery --credential-mgmt \\\n  -p petstore -o examples/petstore/stdlib \\\n  examples/petstore/spec/petstore-v2.json\n</code></pre> <p>chi variant:</p> <pre><code>oastools generate --server --server-all --server-router chi --client \\\n  --security-enforce --oauth2-flows --oidc-discovery --credential-mgmt \\\n  -p petstore -o examples/petstore/chi \\\n  examples/petstore/spec/petstore-v2.json\n</code></pre>"},{"location":"examples/petstore/#next-steps","title":"Next Steps","text":"<ul> <li>Generator Documentation</li> <li>Quickstart Example - Minimal introduction</li> <li>Validation Pipeline Example - Parse and validate workflow</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/petstore/chi/","title":"Swagger Petstore","text":"<p>This is a sample server Petstore server.  You can find out more about Swagger at http://swagger.io or on irc.freenode.net, #swagger.  For this sample, you can use the api key <code>special-key</code> to test the authorization filters.</p>"},{"location":"examples/petstore/chi/#overview","title":"Overview","text":"<p>This package was generated by oastools from an OpenAPI specification.</p> Property Value API Version 1.0.7 OpenAPI Version 2.0 Package <code>petstore</code> Generated 2025-12-26T23:04:26-08:00"},{"location":"examples/petstore/chi/#generated-files","title":"Generated Files","text":"File Description <code>types.go</code> Data types and models (61 lines) <code>client.go</code> HTTP client implementation (755 lines) <code>server.go</code> Server interface (265 lines) <code>server_responses.go</code> Generated code (918 lines) <code>server_binder.go</code> Generated code (528 lines) <code>server_middleware.go</code> Generated code (165 lines) <code>server_router.go</code> Generated code (1031 lines) <code>server_stubs.go</code> Generated code (578 lines) <code>security_helpers.go</code> Security authentication helpers (35 lines) <code>oauth2_petstore_auth.go</code> OAuth2 token flow management (137 lines) <code>credentials.go</code> Credential management (141 lines) <code>security_enforce.go</code> Security enforcement and validation (120 lines) <code>oidc_discovery.go</code> OpenID Connect discovery client (253 lines)"},{"location":"examples/petstore/chi/#security","title":"Security","text":"<p>This API uses the following authentication methods:</p>"},{"location":"examples/petstore/chi/#api_key","title":"api_key","text":"<ul> <li>Type: apiKey</li> <li>Location: header</li> </ul>"},{"location":"examples/petstore/chi/#petstore_auth","title":"petstore_auth","text":"<ul> <li>Type: oauth2</li> <li>Flows: implicit</li> </ul>"},{"location":"examples/petstore/chi/#usage","title":"Usage","text":""},{"location":"examples/petstore/chi/#creating-a-client","title":"Creating a Client","text":"<pre><code>import \"petstore\"\n\nclient, err := NewClient(\"https://api.example.com\")\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"examples/petstore/chi/#authentication","title":"Authentication","text":"<p>api_key (API Key in Header):</p> <pre><code>client, err := NewClient(baseURL, WithApiKeyAPIKey(\"your-api-key\"))\n</code></pre> <p>petstore_auth (OAuth2):</p> <pre><code>client, err := NewClient(baseURL, WithPetstoreAuthOAuth2Token(\"your-access-token\"))\n</code></pre> <p>For OAuth2 token management, see the generated OAuth2 client:</p> <pre><code>oauth2Client := NewPetstoreAuthOAuth2Client(config)\n// Use authorization code flow, client credentials, etc.\n</code></pre>"},{"location":"examples/petstore/chi/#credential-providers","title":"Credential Providers","text":"<p>Use credential providers for dynamic credential management:</p> <pre><code>// Environment variables\nenvProvider := NewEnvCredentialProvider(\"MYAPP_\")\nclient, err := NewClient(baseURL, WithCredentialProvider(envProvider, \"api_key\"))\n\n// Memory provider (for testing)\nmemProvider := NewMemoryCredentialProvider()\nmemProvider.Set(\"api_key\", \"test-key\")\nclient, err := NewClient(baseURL, WithCredentialProvider(memProvider, \"api_key\"))\n\n// Chain providers (try memory first, then env)\nchain := NewCredentialChain(memProvider, envProvider)\nclient, err := NewClient(baseURL, WithCredentialProvider(chain, \"api_key\"))\n</code></pre>"},{"location":"examples/petstore/chi/#security-validation","title":"Security Validation","text":"<p>Validate that required security is configured:</p> <pre><code>validator := NewSecurityValidator()\nvalidator.ConfigureScheme(\"oauth2\", \"read\", \"write\")\n\nif err := validator.ValidateOperation(\"listUsers\"); err != nil {\n    log.Printf(\"Security not configured: %v\", err)\n}\n</code></pre>"},{"location":"examples/petstore/chi/#regeneration","title":"Regeneration","text":"<p>To regenerate this code, run:</p> <pre><code>oastools generate --package petstore\n</code></pre> <p>Note: Do not edit generated files directly. Make changes to the OpenAPI specification and regenerate.</p> <p>Generated by oastools</p>"},{"location":"examples/petstore/stdlib/","title":"Swagger Petstore","text":"<p>This is a sample server Petstore server.  You can find out more about Swagger at http://swagger.io or on irc.freenode.net, #swagger.  For this sample, you can use the api key <code>special-key</code> to test the authorization filters.</p>"},{"location":"examples/petstore/stdlib/#overview","title":"Overview","text":"<p>This package was generated by oastools from an OpenAPI specification.</p> Property Value API Version 1.0.7 OpenAPI Version 2.0 Package <code>petstore</code> Generated 2025-12-23T23:24:58-08:00"},{"location":"examples/petstore/stdlib/#generated-files","title":"Generated Files","text":"File Description <code>types.go</code> Data types and models (61 lines) <code>client.go</code> HTTP client implementation (755 lines) <code>server.go</code> Server interface (265 lines) <code>server_responses.go</code> Generated code (918 lines) <code>server_binder.go</code> Generated code (528 lines) <code>server_middleware.go</code> Generated code (165 lines) <code>server_router.go</code> Generated code (1031 lines) <code>server_stubs.go</code> Generated code (578 lines) <code>security_helpers.go</code> Security authentication helpers (35 lines) <code>oauth2_petstore_auth.go</code> OAuth2 token flow management (137 lines) <code>credentials.go</code> Credential management (141 lines) <code>security_enforce.go</code> Security enforcement and validation (120 lines) <code>oidc_discovery.go</code> OpenID Connect discovery client (253 lines)"},{"location":"examples/petstore/stdlib/#security","title":"Security","text":"<p>This API uses the following authentication methods:</p>"},{"location":"examples/petstore/stdlib/#api_key","title":"api_key","text":"<ul> <li>Type: apiKey</li> <li>Location: header</li> </ul>"},{"location":"examples/petstore/stdlib/#petstore_auth","title":"petstore_auth","text":"<ul> <li>Type: oauth2</li> <li>Flows: implicit</li> </ul>"},{"location":"examples/petstore/stdlib/#usage","title":"Usage","text":""},{"location":"examples/petstore/stdlib/#creating-a-client","title":"Creating a Client","text":"<pre><code>import \"petstore\"\n\nclient, err := NewClient(\"https://api.example.com\")\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"examples/petstore/stdlib/#authentication","title":"Authentication","text":"<p>api_key (API Key in Header):</p> <pre><code>client, err := NewClient(baseURL, WithApiKeyAPIKey(\"your-api-key\"))\n</code></pre> <p>petstore_auth (OAuth2):</p> <pre><code>client, err := NewClient(baseURL, WithPetstoreAuthOAuth2Token(\"your-access-token\"))\n</code></pre> <p>For OAuth2 token management, see the generated OAuth2 client:</p> <pre><code>oauth2Client := NewPetstoreAuthOAuth2Client(config)\n// Use authorization code flow, client credentials, etc.\n</code></pre>"},{"location":"examples/petstore/stdlib/#credential-providers","title":"Credential Providers","text":"<p>Use credential providers for dynamic credential management:</p> <pre><code>// Environment variables\nenvProvider := NewEnvCredentialProvider(\"MYAPP_\")\nclient, err := NewClient(baseURL, WithCredentialProvider(envProvider, \"api_key\"))\n\n// Memory provider (for testing)\nmemProvider := NewMemoryCredentialProvider()\nmemProvider.Set(\"api_key\", \"test-key\")\nclient, err := NewClient(baseURL, WithCredentialProvider(memProvider, \"api_key\"))\n\n// Chain providers (try memory first, then env)\nchain := NewCredentialChain(memProvider, envProvider)\nclient, err := NewClient(baseURL, WithCredentialProvider(chain, \"api_key\"))\n</code></pre>"},{"location":"examples/petstore/stdlib/#security-validation","title":"Security Validation","text":"<p>Validate that required security is configured:</p> <pre><code>validator := NewSecurityValidator()\nvalidator.ConfigureScheme(\"oauth2\", \"read\", \"write\")\n\nif err := validator.ValidateOperation(\"listUsers\"); err != nil {\n    log.Printf(\"Security not configured: %v\", err)\n}\n</code></pre>"},{"location":"examples/petstore/stdlib/#regeneration","title":"Regeneration","text":"<p>To regenerate this code, run:</p> <pre><code>oastools generate --package petstore\n</code></pre> <p>Note: Do not edit generated files directly. Make changes to the OpenAPI specification and regenerate.</p> <p>Generated by oastools</p>"},{"location":"examples/programmatic-api/","title":"Programmatic API Examples","text":"<p>This directory contains examples demonstrating how to construct OpenAPI specifications programmatically using Go code.</p>"},{"location":"examples/programmatic-api/#available-examples","title":"Available Examples","text":"Example Package Description Time builder builder Fluent API for constructing specs + ServerBuilder for runnable servers 5 min"},{"location":"examples/programmatic-api/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/programmatic-api/builder\ngo run main.go\n</code></pre>"},{"location":"examples/programmatic-api/#why-programmatic-api","title":"Why Programmatic API?","text":"<p>Instead of writing YAML/JSON by hand, the builder package lets you:</p> <ul> <li>Type-safe construction - Compile-time checks catch errors</li> <li>Code reuse - Share schemas and patterns across APIs</li> <li>Dynamic generation - Build specs from runtime configuration</li> <li>IDE support - Autocomplete, documentation, refactoring</li> </ul>"},{"location":"examples/programmatic-api/#builder-overview","title":"Builder Overview","text":"<p>The builder example demonstrates:</p>"},{"location":"examples/programmatic-api/#specification-construction","title":"Specification Construction","text":"<pre><code>spec := builder.New(parser.OASVersion320).\n    SetTitle(\"My API\").\n    SetVersion(\"1.0.0\").\n    AddServer(\"https://api.example.com/v1\")\n\nspec.AddOperation(http.MethodGet, \"/users/{id}\",\n    builder.WithPathParam(\"id\", int64(0)),\n    builder.WithResponse(http.StatusOK, User{}),\n)\n\ndoc, err := spec.BuildOAS3()\n</code></pre>"},{"location":"examples/programmatic-api/#struct-based-schema-generation","title":"Struct-Based Schema Generation","text":"<pre><code>type User struct {\n    ID    int64  `json:\"id\" oas:\"readOnly=true\"`\n    Email string `json:\"email\" oas:\"format=email\"`\n    Role  string `json:\"role\" oas:\"enum=admin|user|guest\"`\n}\n</code></pre> <p>The <code>oas</code> struct tag provides full control over schema properties.</p>"},{"location":"examples/programmatic-api/#serverbuilder-new","title":"ServerBuilder (New!)","text":"<p>Create runnable HTTP servers from your spec:</p> <pre><code>srv := builder.NewServerBuilder(parser.OASVersion320, builder.WithoutValidation()).\n    SetTitle(\"Quick API\").\n    SetVersion(\"1.0.0\")\n\nsrv.AddOperation(http.MethodGet, \"/status\",\n    builder.WithResponse(http.StatusOK, StatusResponse{}),\n)\n\nsrv.Handle(http.MethodGet, \"/status\", func(ctx context.Context, req *builder.Request) builder.Response {\n    return builder.JSON(http.StatusOK, StatusResponse{Status: \"ok\"})\n})\n\nresult := srv.MustBuildServer()\nhttp.ListenAndServe(\":8080\", result.Handler)\n</code></pre>"},{"location":"examples/programmatic-api/#use-cases","title":"Use Cases","text":"Use Case Approach Code-first API development Define types \u2192 generate spec Dynamic spec generation Build from config/database Test fixtures Create synthetic specs API composition Combine specs programmatically Rapid prototyping ServerBuilder for working APIs Contract-first validation ServerBuilder with validation enabled"},{"location":"examples/programmatic-api/#features-demonstrated","title":"Features Demonstrated","text":""},{"location":"examples/programmatic-api/#builder-package","title":"Builder Package","text":"<ul> <li><code>builder.New()</code> - Create new specification</li> <li><code>.SetTitle()</code>, <code>.SetVersion()</code>, <code>.SetDescription()</code> - Metadata</li> <li><code>.AddServer()</code> - Server definitions</li> <li><code>.AddTag()</code> - Operation grouping</li> <li><code>.AddOperation()</code> - Define endpoints</li> <li><code>.AddAPIKeySecurityScheme()</code> - Security configuration</li> <li><code>.BuildOAS3()</code> - Type-safe build</li> </ul>"},{"location":"examples/programmatic-api/#operation-options","title":"Operation Options","text":"<ul> <li><code>WithPathParam()</code>, <code>WithQueryParam()</code> - Parameters</li> <li><code>WithRequestBody()</code> - Request body schemas</li> <li><code>WithResponse()</code> - Response definitions</li> <li><code>WithParamMinimum()</code>, <code>WithParamMaximum()</code> - Constraints</li> <li><code>WithParamEnum()</code> - Enumeration values</li> </ul>"},{"location":"examples/programmatic-api/#serverbuilder-package","title":"ServerBuilder Package","text":"<ul> <li><code>NewServerBuilder()</code> - Create server builder</li> <li><code>.Handle()</code> - Register handlers</li> <li><code>.Use()</code> - Add middleware</li> <li><code>.BuildServer()</code> - Build handler</li> <li><code>builder.JSON()</code>, <code>builder.Error()</code> - Response helpers</li> <li><code>NewServerTest()</code> - Testing utilities</li> </ul>"},{"location":"examples/programmatic-api/#next-steps","title":"Next Steps","text":"<ul> <li>Builder Deep Dive - Complete documentation</li> <li>Workflow Examples - Common API transformation patterns</li> <li>HTTP Validation - Validate requests against specs</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/programmatic-api/builder/","title":"Builder","text":"<p>Demonstrates programmatic OpenAPI specification construction using the builder package, including the new ServerBuilder for creating runnable HTTP servers.</p>"},{"location":"examples/programmatic-api/builder/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create an OpenAPI spec from scratch using the fluent API</li> <li>Defining operations with parameters, request bodies, and responses</li> <li>Using Go struct tags for automatic schema generation</li> <li>Configuring security schemes</li> <li>Building and serializing specifications</li> <li>Creating runnable HTTP servers with ServerBuilder</li> <li>Testing handlers with the built-in test helpers</li> </ul>"},{"location":"examples/programmatic-api/builder/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/programmatic-api/builder/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/programmatic-api/builder\ngo run main.go\n</code></pre>"},{"location":"examples/programmatic-api/builder/#expected-output","title":"Expected Output","text":"<pre><code>Builder Workflow\n================\n\n[1/6] Creating OpenAPI 3.2.0 spec builder...\n      Base spec created\n\n[2/6] Adding servers...\n      Added 2 servers (production + staging)\n\n[3/6] Adding tags...\n      Added 'books' tag\n\n[4/6] Configuring security...\n      Added API key security scheme (header: X-API-Key)\n\n[5/6] Adding operations...\n      \u2713 GET /books (listBooks)\n      \u2713 POST /books (createBook)\n      \u2713 GET /books/{bookId} (getBook)\n      \u2713 PUT /books/{bookId} (updateBook)\n      \u2713 DELETE /books/{bookId} (deleteBook)\n\n[6/6] Building specification...\n      Build successful!\n\n--- Specification Summary ---\nOpenAPI Version: 3.2.0\nTitle: Book Store API\nVersion: 1.0.0\nServers: 2\nTags: 1\nPaths: 2\nSchemas: 4\nSecurity Schemes: 1\nOperations: 5\n\nGenerated Schemas:\n  - main.Error\n  - main.Book\n  - main.CreateBookRequest\n  - main.UpdateBookRequest\n\nPaths defined:\n  - /books\n  - /books/{bookId}\n\n=================================\n\n[Bonus] ServerBuilder - Runnable HTTP Server\n\n[1/3] Creating ServerBuilder...\n      ServerBuilder created\n\n[2/3] Adding operations and handlers...\n      \u2713 GET /status with handler\n      \u2713 POST /messages with handler\n\n[3/3] Building server...\n      Server built successfully!\n\n--- Server Summary ---\nHandler Type: http.HandlerFunc\nHas Spec: true\nHas Validator: false\n\nTesting with ServerTest helper:\n  GET /status \u2192 200\n  Response: {status: \"ok\", version: \"1.0.0\"}\n\nServer is ready to run with http.ListenAndServe(\":8080\", result.Handler)\n\n---\nBuilder example complete\n</code></pre>"},{"location":"examples/programmatic-api/builder/#files","title":"Files","text":"File Purpose main.go Demonstrates the builder workflow for creating complete APIs"},{"location":"examples/programmatic-api/builder/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/programmatic-api/builder/#creating-a-builder","title":"Creating a Builder","text":"<pre><code>spec := builder.New(parser.OASVersion320).\n    SetTitle(\"My API\").\n    SetVersion(\"1.0.0\").\n    SetDescription(\"API description\")\n</code></pre>"},{"location":"examples/programmatic-api/builder/#adding-servers","title":"Adding Servers","text":"<pre><code>spec.AddServer(\"https://api.example.com/v1\",\n    builder.WithServerDescription(\"Production\"),\n)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#struct-tags-for-schema-generation","title":"Struct Tags for Schema Generation","text":"<pre><code>type Book struct {\n    ID    int64  `json:\"id\" oas:\"readOnly=true\"`\n    Title string `json:\"title\" oas:\"minLength=1,maxLength=200\"`\n    Genre string `json:\"genre\" oas:\"enum=fiction|non-fiction|sci-fi\"`\n}\n</code></pre> Tag Description <code>description=...</code> Field description <code>minLength=N</code> Minimum string length <code>maxLength=N</code> Maximum string length <code>minimum=N</code> Minimum numeric value <code>maximum=N</code> Maximum numeric value <code>pattern=...</code> Regex pattern <code>enum=a\\|b\\|c</code> Enumeration values (pipe-separated) <code>format=...</code> OpenAPI format (email, uri, date-time, etc.) <code>readOnly=true</code> Mark as read-only <code>writeOnly=true</code> Mark as write-only"},{"location":"examples/programmatic-api/builder/#adding-operations","title":"Adding Operations","text":"<pre><code>spec.AddOperation(http.MethodGet, \"/books/{bookId}\",\n    builder.WithOperationID(\"getBook\"),\n    builder.WithSummary(\"Get a book by ID\"),\n    builder.WithTags(\"books\"),\n    builder.WithPathParam(\"bookId\", int64(0),\n        builder.WithParamDescription(\"Book ID\"),\n    ),\n    builder.WithResponse(http.StatusOK, Book{}),\n    builder.WithResponse(http.StatusNotFound, Error{}),\n)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#request-bodies","title":"Request Bodies","text":"<pre><code>spec.AddOperation(http.MethodPost, \"/books\",\n    builder.WithRequestBody(\"application/json\", CreateBookRequest{},\n        builder.WithRequired(true),\n        builder.WithRequestDescription(\"Book to create\"),\n    ),\n    builder.WithResponse(http.StatusCreated, Book{}),\n)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#query-parameters-with-constraints","title":"Query Parameters with Constraints","text":"<pre><code>builder.WithQueryParam(\"limit\", int32(0),\n    builder.WithParamDescription(\"Maximum items\"),\n    builder.WithParamMinimum(1),\n    builder.WithParamMaximum(100),\n    builder.WithParamDefault(20),\n)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#security-configuration","title":"Security Configuration","text":"<pre><code>spec.AddAPIKeySecurityScheme(\n    \"api_key\",      // scheme name\n    \"header\",       // location: header, query, or cookie\n    \"X-API-Key\",    // header/parameter name\n    \"Description\",\n).SetSecurity(builder.SecurityRequirement(\"api_key\"))\n</code></pre>"},{"location":"examples/programmatic-api/builder/#building-the-spec","title":"Building the Spec","text":"<pre><code>// Type-safe build (OAS 3.x)\ndoc, err := spec.BuildOAS3()\nif err != nil {\n    log.Fatal(err)\n}\n\n// Generic build (any version) - returns *parser.ParseResult\nresult, err := spec.BuildResult()\n</code></pre>"},{"location":"examples/programmatic-api/builder/#advanced-features","title":"Advanced Features","text":"Feature Method OAuth2 schemes <code>AddOAuth2SecurityScheme()</code> Bearer auth <code>AddHTTPSecurityScheme(\"bearer\", \"bearer\", \"JWT\", \"desc\")</code> Schema naming <code>builder.WithSchemaNaming(builder.SchemaNamingPascalCase)</code> Custom templates <code>builder.WithSchemaNameTemplate(\"API{{pascal .Type}}\")</code> Deduplication <code>builder.WithSemanticDeduplication(true)</code> From existing doc <code>builder.FromDocument(existingDoc)</code>"},{"location":"examples/programmatic-api/builder/#serverbuilder-runnable-http-servers","title":"ServerBuilder - Runnable HTTP Servers","text":"<p>ServerBuilder extends Builder to create production-ready HTTP servers with automatic routing and optional request validation.</p>"},{"location":"examples/programmatic-api/builder/#creating-a-serverbuilder","title":"Creating a ServerBuilder","text":"<pre><code>srv := builder.NewServerBuilder(parser.OASVersion320, builder.WithoutValidation()).\n    SetTitle(\"My API\").\n    SetVersion(\"1.0.0\")\n</code></pre>"},{"location":"examples/programmatic-api/builder/#registering-handlers","title":"Registering Handlers","text":"<pre><code>// Add operation (same API as Builder)\nsrv.AddOperation(http.MethodGet, \"/status\",\n    builder.WithOperationID(\"getStatus\"),\n    builder.WithResponse(http.StatusOK, StatusResponse{}),\n)\n\n// Register handler for the operation\nsrv.Handle(http.MethodGet, \"/status\", func(ctx context.Context, req *builder.Request) builder.Response {\n    return builder.JSON(http.StatusOK, StatusResponse{Status: \"ok\"})\n})\n</code></pre>"},{"location":"examples/programmatic-api/builder/#response-helpers","title":"Response Helpers","text":"<pre><code>// JSON response\nreturn builder.JSON(http.StatusOK, data)\n\n// Error response\nreturn builder.Error(http.StatusBadRequest, \"invalid input\")\n\n// No content (204)\nreturn builder.NoContent()\n\n// Redirect\nreturn builder.Redirect(http.StatusFound, \"/new-location\")\n\n// Custom response with headers\nreturn builder.NewResponse(http.StatusOK).\n    Header(\"X-Custom\", \"value\").\n    JSON(data)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#building-and-running","title":"Building and Running","text":"<pre><code>result, err := srv.BuildServer()\nif err != nil {\n    log.Fatal(err)\n}\n\n// result.Handler is a standard http.Handler\nhttp.ListenAndServe(\":8080\", result.Handler)\n\n// result.Spec contains the generated OpenAPI document\n// result.Validator is present if validation is enabled\n</code></pre>"},{"location":"examples/programmatic-api/builder/#request-validation","title":"Request Validation","text":"<pre><code>// Enable request validation\nsrv := builder.NewServerBuilder(parser.OASVersion320,\n    builder.WithValidationConfig(builder.ValidationConfig{\n        IncludeRequestValidation: true,\n        StrictMode:               false,\n    }),\n)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#testing-handlers","title":"Testing Handlers","text":"<pre><code>result := srv.MustBuildServer()\ntest := builder.NewServerTest(result)\n\n// GET with JSON response\nvar status StatusResponse\nrec, err := test.GetJSON(\"/status\", &amp;status)\n\n// POST with JSON body\nvar created Book\nrec, err := test.PostJSON(\"/books\", CreateBookRequest{Title: \"Test\"}, &amp;created)\n</code></pre>"},{"location":"examples/programmatic-api/builder/#adding-middleware","title":"Adding Middleware","text":"<pre><code>srv.Use(func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"X-Request-ID\", uuid.New().String())\n        next.ServeHTTP(w, r)\n    })\n})\n</code></pre>"},{"location":"examples/programmatic-api/builder/#use-cases","title":"Use Cases","text":"<ul> <li>Code-first API development - Define your API in Go, generate the spec</li> <li>Dynamic spec generation - Build specs based on runtime configuration</li> <li>Test fixtures - Create synthetic specs for testing</li> <li>API composition - Programmatically combine API elements</li> <li>Rapid prototyping - Use ServerBuilder to create working APIs quickly</li> <li>Spec-validated servers - Enable request validation for contract-first development</li> </ul>"},{"location":"examples/programmatic-api/builder/#next-steps","title":"Next Steps","text":"<ul> <li>Builder Deep Dive - Complete documentation</li> <li>HTTPValidator - Validate requests against your spec</li> <li>Code Generation - Generate server code from specs</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/","title":"Walker Examples","text":"<p>This directory contains examples demonstrating document traversal capabilities using the walker package for analysis, mutation, validation, filtering, and reporting.</p>"},{"location":"examples/walker/#available-examples","title":"Available Examples","text":"Workflow Category Description Time api-statistics Analysis Collect API statistics in single traversal pass 3 min security-audit Validation Audit API for security issues and compliance 4 min vendor-extensions Mutation Add vendor extensions for downstream tooling 3 min public-api-filter Filtering Extract public API, filter internal endpoints 3 min api-documentation Reporting Generate Markdown documentation from spec 4 min reference-collector Integration Collect schema references and detect cycles 4 min"},{"location":"examples/walker/#quick-start","title":"Quick Start","text":"<p>Each example is a standalone Go module. To run any example:</p> <pre><code>cd examples/walker/&lt;example-name&gt;\ngo run main.go\n</code></pre>"},{"location":"examples/walker/#workflow-overview","title":"Workflow Overview","text":""},{"location":"examples/walker/#api-statistics","title":"API Statistics","text":"<p>The api-statistics example demonstrates collecting comprehensive API metrics in a single traversal:</p> <ol> <li>Register handlers for paths, operations, schemas, and parameters</li> <li>Walk the document once</li> <li>Aggregate counts, categorize endpoints, and compute statistics</li> </ol> <p>Use cases: API complexity analysis, documentation metrics, governance reports</p>"},{"location":"examples/walker/#security-audit","title":"Security Audit","text":"<p>The security-audit example shows how to audit APIs for security compliance:</p> <ol> <li>Register handlers for security schemes, operations, and parameters</li> <li>Detect missing authentication, sensitive data exposure, insecure patterns</li> <li>Generate compliance reports with severity levels</li> </ol> <p>Use cases: Security reviews, compliance checks, CI/CD security gates</p>"},{"location":"examples/walker/#vendor-extensions","title":"Vendor Extensions","text":"<p>The vendor-extensions example demonstrates adding custom metadata:</p> <ol> <li>Walk the document with mutation enabled</li> <li>Add vendor extensions (x-*) to operations, schemas, and paths</li> <li>Enrich specs for downstream tooling (code generators, gateways)</li> </ol> <p>Use cases: Gateway configuration, code generator hints, documentation metadata</p>"},{"location":"examples/walker/#public-api-filter","title":"Public API Filter","text":"<p>The public-api-filter example shows how to extract a subset of the API:</p> <ol> <li>Walk the document and identify internal vs public endpoints</li> <li>Use flow control to skip internal paths</li> <li>Collect only public operations and their dependencies</li> </ol> <p>Use cases: Public API documentation, partner API exports, SDK generation</p>"},{"location":"examples/walker/#api-documentation","title":"API Documentation","text":"<p>The api-documentation example generates human-readable documentation:</p> <ol> <li>Walk paths, operations, parameters, and response schemas</li> <li>Build structured documentation model during traversal</li> <li>Render to Markdown with proper formatting</li> </ol> <p>Use cases: Auto-generated docs, README generation, API portals</p>"},{"location":"examples/walker/#reference-collector","title":"Reference Collector","text":"<p>The reference-collector example demonstrates schema reference tracking:</p> <ol> <li>Walk schemas and track $ref usage</li> <li>Build dependency graphs between components</li> <li>Detect circular references and unused schemas</li> </ol> <p>Use cases: Dependency analysis, dead code detection, refactoring preparation</p>"},{"location":"examples/walker/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/walker/#handler-registration","title":"Handler Registration","text":"<p>The walker uses functional options to register typed handlers:</p> <pre><code>err := walker.Walk(parseResult,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pathItem *parser.PathItem) walker.Action {\n        fmt.Printf(\"Path: %s\\n\", wc.PathTemplate)\n        return walker.Continue\n    }),\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        fmt.Printf(\"  %s %s\\n\", wc.Method, wc.PathTemplate)\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"examples/walker/#flow-control","title":"Flow Control","text":"<p>Control traversal with return values:</p> <pre><code>walker.WithPathHandler(func(wc *walker.WalkContext, pathItem *parser.PathItem) walker.Action {\n    if strings.HasPrefix(wc.PathTemplate, \"/internal\") {\n        return walker.SkipChildren  // Skip operations under this path\n    }\n    if wc.PathTemplate == \"/admin\" {\n        return walker.Stop  // Stop entire traversal\n    }\n    return walker.Continue  // Process children normally\n})\n</code></pre> Return Value Behavior <code>walker.Continue</code> Process this node and its children <code>walker.SkipChildren</code> Process this node, skip its children <code>walker.Stop</code> Stop traversal immediately"},{"location":"examples/walker/#mutation-via-pointer-receivers","title":"Mutation via Pointer Receivers","text":"<p>Handlers receive pointers, enabling in-place modification:</p> <pre><code>walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n    if op.Extra == nil {\n        op.Extra = make(map[string]any)\n    }\n    op.Extra[\"x-generated\"] = time.Now().Format(time.RFC3339)\n    return walker.Continue\n})\n</code></pre>"},{"location":"examples/walker/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete package documentation</li> <li>Workflow Examples - Common OpenAPI transformation patterns</li> <li>Getting Started - Basic parser and validator usage</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/api-documentation/","title":"API Documentation Generator","text":"<p>Demonstrates generating Markdown API documentation from OpenAPI specifications using walker handlers.</p>"},{"location":"examples/walker/api-documentation/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Extracting documentation from multiple handler types in a single pass</li> <li>Maintaining state across nested handlers (path \u2192 operation \u2192 parameters/responses)</li> <li>Generating structured Markdown output from OpenAPI specifications</li> <li>Using walker for comprehensive documentation generation</li> </ul>"},{"location":"examples/walker/api-documentation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/api-documentation/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/api-documentation\ngo run main.go\n</code></pre>"},{"location":"examples/walker/api-documentation/#expected-output","title":"Expected Output","text":"<pre><code># Petstore API\n\n**Version:** 1.0.0\n\nA sample API for a pet store\n\n## Servers\n\n| Environment | URL |\n|-------------|-----|\n| Production server | https://petstore.example.com/v1 |\n| Staging server | https://staging.petstore.example.com/v1 |\n\n## Tags\n\n- **pets** - Pet operations\n\n## Endpoints\n\n### GET /pets\n\n**listPets**: List all pets\n\n**Parameters:**\n\n| Name | In | Required | Description |\n|------|-----|----------|-------------|\n| limit | query | No | How many items to return at one time |\n\n**Responses:**\n\n| Status | Description |\n|--------|-------------|\n| 200 | A paged array of pets |\n| default | unexpected error |\n\n---\n\n### POST /pets\n\n**createPet**: Create a pet\n\n...\n</code></pre>"},{"location":"examples/walker/api-documentation/#files","title":"Files","text":"File Purpose main.go Generates Markdown documentation using multiple walker handlers go.mod Module definition with local replace directive"},{"location":"examples/walker/api-documentation/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/api-documentation/#state-management-across-handlers","title":"State Management Across Handlers","text":"<p>The walker visits nodes in document order. To associate parameters and responses with their parent operation, we track the current context:</p> <pre><code>var currentEndpoint *EndpointDoc\n\nwalker.Walk(parseResult,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pathItem *parser.PathItem) walker.Action {\n        // wc.PathTemplate available in context\n        return walker.Continue\n    }),\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        endpoint := EndpointDoc{Path: wc.PathTemplate, Method: wc.Method, ...}\n        doc.Endpoints = append(doc.Endpoints, endpoint)\n        currentEndpoint = &amp;doc.Endpoints[len(doc.Endpoints)-1]  // Track current endpoint\n        return walker.Continue\n    }),\n    walker.WithParameterHandler(func(wc *walker.WalkContext, param *parser.Parameter) walker.Action {\n        currentEndpoint.Parameters = append(currentEndpoint.Parameters, ...)  // Add to current\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"examples/walker/api-documentation/#handler-ordering-and-nesting","title":"Handler Ordering and Nesting","text":"<p>The walker visits nodes in this order:</p> <ol> <li>Document root \u2192 Info \u2192 Servers \u2192 Tags</li> <li>For each path: PathHandler \u2192 OperationHandler \u2192 ParameterHandler \u2192 ResponseHandler</li> <li>Components (schemas, security schemes, etc.)</li> </ol> <p>Parameters and responses are visited as children of their parent operation, allowing context-aware collection.</p>"},{"location":"examples/walker/api-documentation/#structured-output-generation","title":"Structured Output Generation","text":"<p>After walking, the collected data is sorted and formatted into Markdown:</p> <pre><code>sort.Slice(doc.Endpoints, func(i, j int) bool {\n    if doc.Endpoints[i].Path != doc.Endpoints[j].Path {\n        return doc.Endpoints[i].Path &lt; doc.Endpoints[j].Path\n    }\n    return doc.Endpoints[i].Method &lt; doc.Endpoints[j].Method\n})\n\ngenerateMarkdown(doc)\n</code></pre>"},{"location":"examples/walker/api-documentation/#use-cases","title":"Use Cases","text":"<ul> <li>README Generation: Auto-generate API documentation for repositories</li> <li>API Guides: Create human-readable endpoint references</li> <li>Documentation Sites: Generate content for static site generators</li> <li>API Catalogs: Build searchable API inventories</li> </ul>"},{"location":"examples/walker/api-documentation/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>API Statistics - Collect statistics using multiple handlers</li> <li>Reference Collector - Track schema definitions and references</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/api-statistics/","title":"API Statistics","text":"<p>Demonstrates collecting API statistics in a single pass using multiple walker handlers.</p>"},{"location":"examples/walker/api-statistics/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Using multiple handlers to collect statistics in one traversal</li> <li>Type-safe access to Info, Operation, Schema, Parameter, and Tag nodes</li> <li>Building statistics using closure state that captures data across handlers</li> <li>Understanding walker traversal order (document root to nested children)</li> <li>Handling <code>schema.Type</code> as both string and array (OAS 3.1 compatibility)</li> </ul>"},{"location":"examples/walker/api-statistics/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/api-statistics/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/api-statistics\ngo run main.go\n</code></pre>"},{"location":"examples/walker/api-statistics/#expected-output","title":"Expected Output","text":"<pre><code>API Statistics Report\n=====================\n\nAPI: Petstore API v1.0.0\n\nOperations (3 total):\n  GET:     2\n  POST:    1\n\nSchemas by Type (20 total):\n  array:     1\n  integer:   3\n  object:    3\n  string:    6\n\nParameters by Location:\n  path:      1\n  query:     1\n\nTags:\n  - pets\n</code></pre>"},{"location":"examples/walker/api-statistics/#files","title":"Files","text":"File Purpose main.go Collects API statistics using multiple walker handlers go.mod Module definition with local replace directive"},{"location":"examples/walker/api-statistics/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/api-statistics/#handler-registration-pattern","title":"Handler Registration Pattern","text":"<p>The walker uses the functional options pattern for handler registration:</p> <pre><code>walker.Walk(parseResult,\n    walker.WithInfoHandler(func(wc *walker.WalkContext, info *parser.Info) walker.Action { ... }),\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action { ... }),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action { ... }),\n)\n</code></pre> <p>Each handler receives a <code>WalkContext</code> (with JSON path via <code>wc.JSONPath</code>) and the typed node.</p>"},{"location":"examples/walker/api-statistics/#traversal-order","title":"Traversal Order","text":"<p>The walker visits nodes in document order (OAS 3.x):</p> <ol> <li>Document root (OAS2Document or OAS3Document)</li> <li>Info object</li> <li>ExternalDocs (root level)</li> <li>Servers</li> <li>Paths and operations (parameters, request body, responses, callbacks)</li> <li>Webhooks (OAS 3.1+)</li> <li>Components (schemas, parameters, etc.)</li> <li>Tags</li> </ol> <p>This allows collecting statistics that depend on earlier nodes.</p>"},{"location":"examples/walker/api-statistics/#closure-state","title":"Closure State","text":"<p>Handlers share state through closures:</p> <pre><code>stats := &amp;APIStats{...}  // Shared state\n\nwalker.Walk(parseResult,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        stats.TotalOperations++  // Update shared state\n        return walker.Continue\n    }),\n)\n</code></pre> <p>This pattern enables collecting statistics from multiple node types in a single traversal.</p>"},{"location":"examples/walker/api-statistics/#use-cases","title":"Use Cases","text":"<ul> <li>API Governance: Verify endpoint naming conventions and coverage</li> <li>Documentation Generation: Extract API metadata for docs</li> <li>Complexity Analysis: Measure API size and schema complexity</li> <li>Migration Planning: Inventory operations before version upgrades</li> </ul>"},{"location":"examples/walker/api-statistics/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>Reference Collector - Track schema definitions and references</li> <li>API Documentation - Generate API documentation with endpoint details</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/public-api-filter/","title":"Public API Filter","text":"<p>Demonstrates extracting public-facing API endpoints by filtering out internal, admin, and deprecated paths using the walker's SkipChildren action.</p>"},{"location":"examples/walker/public-api-filter/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Using SkipChildren for subtree filtering to exclude entire path branches</li> <li>Maintaining context across handler calls (currentPath pattern)</li> <li>Building filtered subsets of API documents</li> <li>Combining multiple filtering criteria (path prefixes + deprecation status)</li> </ul>"},{"location":"examples/walker/public-api-filter/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/public-api-filter/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/public-api-filter\ngo run main.go\n</code></pre>"},{"location":"examples/walker/public-api-filter/#expected-output","title":"Expected Output","text":"<pre><code>Public API Extraction Report\n============================\n\nIncluded Paths (4):\n  /pets\n  /pets/{petId}\n  /users\n  /users/{userId}\n\nPublic Operations (5):\n  GET    /pets                - listPets: List all pets\n  POST   /pets                - createPet: Create a new pet\n  GET    /pets/{petId}        - getPetById: Get pet by ID\n  GET    /users               - listUsers: List users\n  GET    /users/{userId}      - getUserById: Get user by ID\n\nFiltered Out:\n  Internal/Admin paths skipped (5):\n    - /_admin/config\n    - /admin/users\n    - /admin/users/{userId}\n    - /internal/health\n    - /internal/metrics\n\n  Deprecated operations skipped (1):\n    - DELETE /pets/{petId}\n</code></pre>"},{"location":"examples/walker/public-api-filter/#files","title":"Files","text":"File Purpose main.go Filters API paths and operations using walker handlers go.mod Module definition with local replace directive specs/full-api.yaml Sample API with public, internal, admin, and deprecated endpoints"},{"location":"examples/walker/public-api-filter/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/public-api-filter/#skipchildren-vs-continue","title":"SkipChildren vs Continue","text":"<p>The walker provides flow control through returned actions:</p> <pre><code>// Continue - process this node and all its children\nreturn walker.Continue\n\n// SkipChildren - process this node but skip all descendants\nreturn walker.SkipChildren\n</code></pre> <p>When a PathHandler returns SkipChildren, none of the operations, parameters, or responses under that path are visited. This is more efficient than checking each operation individually.</p>"},{"location":"examples/walker/public-api-filter/#maintaining-state-between-handlers","title":"Maintaining State Between Handlers","text":"<p>Handlers use closure variables to share context:</p> <pre><code>var skipCurrentPath bool\n\nwalker.Walk(parseResult,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pathItem *parser.PathItem) walker.Action {\n        if isInternalPath(wc.PathTemplate) {\n            skipCurrentPath = true\n            return walker.SkipChildren\n        }\n        skipCurrentPath = false\n        return walker.Continue\n    }),\n\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        // Access wc.PathTemplate directly from context\n        if skipCurrentPath {\n            return walker.SkipChildren\n        }\n        // wc.PathTemplate contains the current path\n        ...\n    }),\n)\n</code></pre> <p>The <code>WalkContext</code> provides the path template directly via <code>wc.PathTemplate</code>.</p>"},{"location":"examples/walker/public-api-filter/#filter-criteria-composition","title":"Filter Criteria Composition","text":"<p>Multiple filtering rules can be combined:</p> <ol> <li>Path-based filtering: Skip entire path subtrees with SkipChildren</li> <li>Operation-level filtering: Check individual operations for deprecation</li> <li>Cascading filters: Path filter runs first, operation filter only sees non-filtered paths</li> </ol>"},{"location":"examples/walker/public-api-filter/#use-cases","title":"Use Cases","text":"<ul> <li>Public Documentation: Generate docs only for customer-facing endpoints</li> <li>Partner API Specs: Create filtered specs for external partners</li> <li>API Exposure Control: Audit which endpoints are publicly accessible</li> <li>SDK Generation: Generate client code only for public operations</li> <li>Security Review: Identify and verify internal-only endpoints</li> </ul>"},{"location":"examples/walker/public-api-filter/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>API Statistics - Collect statistics across the full API</li> <li>Reference Collector - Track schema definitions and references</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/reference-collector/","title":"Reference Collector","text":"<p>Demonstrates analyzing schema references and detecting circular references using the walker package.</p>"},{"location":"examples/walker/reference-collector/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Using SchemaSkippedHandler for cycle and depth notifications</li> <li>Building reference graphs with walker</li> <li>Identifying unused components in your API specification</li> <li>Configuring WithMaxSchemaDepth for controlled schema traversal</li> <li>Detecting self-referencing schemas (circular references)</li> </ul>"},{"location":"examples/walker/reference-collector/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/reference-collector/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/reference-collector\ngo run main.go\n</code></pre>"},{"location":"examples/walker/reference-collector/#expected-output","title":"Expected Output","text":"<pre><code>Reference Analysis Report\n=========================\n\nSchema References:\n  Category (1 reference):\n    - $.components.schemas['Pet'].properties['category']\n  DeepLevel1 (1 reference):\n    - $.components.schemas['DeepSchema'].allOf[0]\n  DeepLevel2 (1 reference):\n    - $.components.schemas['DeepLevel1'].allOf[0]\n  DeepLevel3 (1 reference):\n    - $.components.schemas['DeepLevel2'].allOf[0]\n  DeepLevel4 (1 reference):\n    - $.components.schemas['DeepLevel3'].allOf[0]\n  DeepLevel5 (1 reference):\n    - $.components.schemas['DeepLevel4'].allOf[0]\n  Error (4 references):\n    - $.paths['/nodes'].get.responses.default.content['application/json'].schema\n    - $.paths['/pets'].get.responses.default.content['application/json'].schema\n    - $.paths['/pets'].post.responses.default.content['application/json'].schema\n    - $.paths['/pets/{petId}'].get.responses.default.content['application/json'].schema\n  NewPet (1 reference):\n    - $.paths['/pets'].post.requestBody.content['application/json'].schema\n  Node (2 references):\n    - $.paths['/nodes'].get.responses['200'].content['application/json'].schema.items\n    - $.components.schemas['Node'].properties['children'].items\n  Pet (3 references):\n    - $.paths['/pets'].get.responses['200'].content['application/json'].schema.items\n    - $.paths['/pets'].post.responses['201'].content['application/json'].schema\n    - $.paths['/pets/{petId}'].get.responses['200'].content['application/json'].schema\n\nUnused Schemas (3):\n  - DeepSchema\n  - InternalConfig\n  - LegacyModel\n\nSelf-Referencing Schemas (1):\n  - $.components.schemas['Node'].properties['children'].items\n\nWalker Cycle Events (0):\n  (none)\n\nDepth-Limited Schemas: 0\n</code></pre>"},{"location":"examples/walker/reference-collector/#files","title":"Files","text":"File Purpose main.go Collects schema references and detects cycles using walker specs/complex-api.yaml Test specification with circular refs, deep nesting, and unused schemas go.mod Module definition with local replace directive"},{"location":"examples/walker/reference-collector/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/reference-collector/#schemaskippedhandler-reasons","title":"SchemaSkippedHandler Reasons","text":"<p>The <code>SchemaSkippedHandler</code> is called when the walker skips a schema for one of two reasons:</p> <pre><code>walker.WithSchemaSkippedHandler(func(wc *walker.WalkContext, reason string, schema *parser.Schema) {\n    switch reason {\n    case \"cycle\":\n        // Schema was already visited - circular reference detected\n        collector.Cycles = append(collector.Cycles, wc.JSONPath)\n    case \"depth\":\n        // Schema exceeds maxDepth - depth limit reached\n        collector.DepthLimited = append(collector.DepthLimited, wc.JSONPath)\n    }\n})\n</code></pre>"},{"location":"examples/walker/reference-collector/#reference-tracking-pattern","title":"Reference Tracking Pattern","text":"<p>Track where each schema is referenced by extracting the name from <code>$ref</code>:</p> <pre><code>walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n    if schema.Ref != \"\" {\n        schemaName := extractSchemaName(schema.Ref)\n        refs[schemaName] = append(refs[schemaName], wc.JSONPath)\n    }\n    return walker.Continue\n})\n</code></pre>"},{"location":"examples/walker/reference-collector/#handling-array-items-with-references","title":"Handling Array Items with References","text":"<p>When an array schema has items with a <code>$ref</code>, the parser stores it as <code>map[string]any</code>:</p> <pre><code>// Handle items that contain a $ref (stored as map[string]any)\nif items, ok := schema.Items.(map[string]any); ok {\n    if ref, ok := items[\"$ref\"].(string); ok {\n        schemaName := extractSchemaName(ref)\n        collector.SchemaRefs[schemaName] = append(collector.SchemaRefs[schemaName], wc.JSONPath+\".items\")\n    }\n}\n</code></pre>"},{"location":"examples/walker/reference-collector/#unused-component-detection","title":"Unused Component Detection","text":"<p>After walking, compare defined schemas against referenced ones:</p> <pre><code>for _, name := range allSchemaNames {\n    if _, hasRefs := collector.SchemaRefs[name]; !hasRefs {\n        unusedSchemas = append(unusedSchemas, name)\n    }\n}\n</code></pre>"},{"location":"examples/walker/reference-collector/#self-reference-detection","title":"Self-Reference Detection","text":"<p>Detect schemas that reference themselves by checking if any reference path starts with the schema's own component path:</p> <pre><code>for name, refs := range collector.SchemaRefs {\n    prefix := \"$.components.schemas['\" + name + \"']\"\n    for _, refPath := range refs {\n        if strings.HasPrefix(refPath, prefix) {\n            collector.SelfReferences = append(collector.SelfReferences, refPath)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/walker/reference-collector/#maxschemadepth-configuration","title":"MaxSchemaDepth Configuration","text":"<p>Use <code>WithMaxSchemaDepth</code> to prevent infinite traversal in deeply nested schemas:</p> <pre><code>walker.Walk(parseResult,\n    walker.WithMaxSchemaDepth(50),  // Limit schema traversal depth\n    // ... handlers\n)\n</code></pre>"},{"location":"examples/walker/reference-collector/#use-cases","title":"Use Cases","text":"<ul> <li>Dead Code Detection: Find unused schemas that can be safely removed</li> <li>Dependency Analysis: Build a reference graph of your API components</li> <li>API Cleanup: Identify legacy or orphaned schemas</li> <li>Circular Reference Auditing: Detect and document self-referential structures</li> <li>Refactoring Support: Understand schema dependencies before making changes</li> </ul>"},{"location":"examples/walker/reference-collector/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>API Statistics - Collect statistics about your API</li> <li>Security Audit - Audit security schemes and authentication</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/security-audit/","title":"Security Audit","text":"<p>Demonstrates auditing OpenAPI specifications for security issues using custom validation rules with the walker package.</p>"},{"location":"examples/walker/security-audit/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Implementing custom validation rules beyond schema validation</li> <li>Pattern matching on field names for sensitive data detection</li> <li>Categorizing issues by severity (ERROR, WARNING, INFO)</li> <li>Building security-focused linting tools for API specifications</li> </ul>"},{"location":"examples/walker/security-audit/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/security-audit/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/security-audit\ngo run main.go\n</code></pre>"},{"location":"examples/walker/security-audit/#expected-output","title":"Expected Output","text":"<pre><code>Security Audit Report\n=====================\n\nSecurity Schemes Available:\n  - apiKey (apiKey)\n  - bearerAuth (http)\n\nFindings by Severity:\n\n[ERROR] (5 findings)\n  $.components.schemas['Credentials']\n    Sensitive field 'password' found - ensure proper handling\n  $.components.schemas['Credentials']\n    Sensitive field 'secret' found - ensure proper handling\n  $.components.schemas['Credentials']\n    Sensitive field 'token' found - ensure proper handling\n  $.components.schemas['User']\n    Sensitive field 'apiKey' found - ensure proper handling\n  $.components.schemas['User']\n    Sensitive field 'password' found - ensure proper handling\n\n[WARNING] (3 findings)\n  $.paths['/users'].post\n    Operation has no security requirements\n  $.paths['/users/{userId}'].delete\n    Operation has no security requirements\n  $.paths['/users/{userId}'].put\n    Operation has no security requirements\n\n[INFO] (2 findings)\n  $.paths['/_system/health']\n    Internal endpoint detected - verify access controls\n  $.paths['/internal/debug']\n    Internal endpoint detected - verify access controls\n\nSummary: 5 errors, 3 warnings, 2 info\n</code></pre>"},{"location":"examples/walker/security-audit/#files","title":"Files","text":"File Purpose main.go Security audit logic using multiple walker handlers go.mod Module definition with local replace directive specs/api-to-audit.yaml Sample API with intentional security issues for demonstration"},{"location":"examples/walker/security-audit/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/security-audit/#custom-validation-beyond-schema-validation","title":"Custom Validation Beyond Schema Validation","text":"<p>The walker enables validation rules that go beyond structural schema validation:</p> <pre><code>// Check for operations missing security requirements\nwalker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n    if len(op.Security) == 0 &amp;&amp; !isInternalPath(currentPathTemplate) {\n        findings = append(findings, Finding{\n            Severity: \"WARNING\",\n            Path:     wc.JSONPath,\n            Message:  \"Operation has no security requirements\",\n        })\n    }\n    return walker.Continue\n}),\n</code></pre> <p>This catches security gaps that a schema validator would miss.</p>"},{"location":"examples/walker/security-audit/#severity-based-issue-categorization","title":"Severity-Based Issue Categorization","text":"<p>Organizing findings by severity helps prioritize remediation:</p> <ul> <li>ERROR: Critical issues requiring immediate attention (sensitive data exposure)</li> <li>WARNING: Security gaps that should be addressed (missing authentication)</li> <li>INFO: Items for review that may be intentional (internal endpoints)</li> </ul>"},{"location":"examples/walker/security-audit/#sensitive-data-detection-patterns","title":"Sensitive Data Detection Patterns","text":"<p>Pattern matching identifies potentially sensitive fields:</p> <pre><code>sensitivePatterns := []string{\"password\", \"secret\", \"token\", \"apikey\", \"credential\", \"key\"}\n\nwalker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n    for propName := range schema.Properties {\n        for _, pattern := range sensitivePatterns {\n            if strings.Contains(strings.ToLower(propName), pattern) {\n                // Found sensitive field\n            }\n        }\n    }\n    return walker.Continue\n}),\n</code></pre>"},{"location":"examples/walker/security-audit/#use-cases","title":"Use Cases","text":"<ul> <li>CI/CD Security Gates: Fail builds when security issues exceed thresholds</li> <li>Compliance Audits: Verify APIs meet security requirements</li> <li>API Review Automation: Pre-review checks before manual security review</li> <li>Security Policy Enforcement: Ensure all public endpoints require authentication</li> <li>Sensitive Data Inventory: Track which schemas contain sensitive fields</li> </ul>"},{"location":"examples/walker/security-audit/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>Public API Filter - Filter endpoints by visibility</li> <li>API Statistics - Collect API metrics in a single pass</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/walker/vendor-extensions/","title":"Vendor Extensions","text":"<p>Demonstrates adding vendor extensions (x-*) to an OpenAPI specification for downstream tooling integration.</p>"},{"location":"examples/walker/vendor-extensions/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>In-place mutation via pointer receivers (handlers receive <code>*parser.Schema</code>, <code>*parser.Operation</code>, etc.)</li> <li>Using the <code>Extra</code> map to add vendor extensions to any OAS node</li> <li>Conditional mutation based on node properties (HTTP method, path prefix, deprecation status)</li> <li>Using <code>SkipChildren</code> to exclude deprecated operations from enhancement</li> <li>Outputting the modified document as YAML</li> </ul>"},{"location":"examples/walker/vendor-extensions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/walker/vendor-extensions/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/walker/vendor-extensions\ngo run main.go\n</code></pre>"},{"location":"examples/walker/vendor-extensions/#expected-output","title":"Expected Output","text":"<p>The output shows the full modified YAML specification. Key excerpts demonstrating the added extensions:</p> <p>Schema with processing metadata:</p> <pre><code>Pet:\n  type: object\n  x-processed: true\n  x-processed-at: \"2024-01-15T10:30:00Z\"\n  properties:\n    id:\n      type: integer\n      x-processed: true\n      x-processed-at: \"2024-01-15T10:30:00Z\"\n</code></pre> <p>Operation with rate limiting:</p> <pre><code>get:\n  summary: List all pets\n  operationId: listPets\n  x-rate-limit: 100\n  x-cache-ttl: 60\n</code></pre> <p>Modification summary:</p> <pre><code>Modification Summary\n--------------------\nSchemas processed:     20\nOperations enhanced:   3 (with rate limits)\nOperations skipped:    0 (deprecated)\nPaths marked internal: 0\n</code></pre>"},{"location":"examples/walker/vendor-extensions/#files","title":"Files","text":"File Purpose main.go Adds vendor extensions using walker mutation handlers go.mod Module definition with local replace directive"},{"location":"examples/walker/vendor-extensions/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/walker/vendor-extensions/#mutation-support","title":"Mutation Support","text":"<p>Walker handlers receive pointers to nodes, enabling in-place mutation:</p> <pre><code>walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n    if schema.Extra == nil {\n        schema.Extra = make(map[string]any)\n    }\n    schema.Extra[\"x-processed\"] = true\n    return walker.Continue\n})\n</code></pre> <p>The original document is modified directly - no need to return a modified copy.</p>"},{"location":"examples/walker/vendor-extensions/#extra-map-for-vendor-extensions","title":"Extra Map for Vendor Extensions","text":"<p>All OAS nodes have an <code>Extra</code> field (<code>map[string]any</code>) that captures vendor extensions:</p> <pre><code>if op.Extra == nil {\n    op.Extra = make(map[string]any)\n}\nop.Extra[\"x-rate-limit\"] = 100\nop.Extra[\"x-cache-ttl\"] = 60\n</code></pre> <p>When marshaled, these become <code>x-rate-limit: 100</code> and <code>x-cache-ttl: 60</code> in the output.</p>"},{"location":"examples/walker/vendor-extensions/#skipchildren-for-conditional-processing","title":"SkipChildren for Conditional Processing","text":"<p>Use <code>SkipChildren</code> to exclude entire subtrees from processing:</p> <pre><code>walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n    if op.Deprecated {\n        return walker.SkipChildren  // Don't process children of deprecated operations\n    }\n    // ... enhance non-deprecated operations\n    return walker.Continue\n})\n</code></pre>"},{"location":"examples/walker/vendor-extensions/#use-cases","title":"Use Cases","text":"<ul> <li>API Gateway Configuration: Add rate limiting, caching, and routing extensions</li> <li>Documentation Generation: Mark internal/external APIs, add custom metadata</li> <li>Code Generation: Add generator hints (x-go-type, x-nullable, etc.)</li> <li>Validation Enhancement: Add custom validation rules (x-pattern, x-min-length)</li> <li>Deprecation Workflow: Tag deprecated operations with migration paths</li> </ul>"},{"location":"examples/walker/vendor-extensions/#next-steps","title":"Next Steps","text":"<ul> <li>Walker Deep Dive - Complete walker documentation</li> <li>API Statistics - Collect statistics using multiple handlers</li> <li>Reference Collector - Track schema definitions and references</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/","title":"Workflow Examples","text":"<p>This directory contains examples demonstrating common OpenAPI workflows using the oastools packages.</p>"},{"location":"examples/workflows/#available-workflows","title":"Available Workflows","text":"Workflow Package Description Time pipeline-compositions multiple Chain multiple oastools operations together 5 min fixer-showcase fixer Demonstrate all available fix types 5 min validate-and-fix fixer Parse, validate, auto-fix common errors 3 min version-conversion converter Convert OAS 2.0 (Swagger) \u2192 OAS 3.0.3 3 min version-migration converter OAS 3.1/3.2 upgrades and lossy downgrades 4 min multi-api-merge joiner Merge multiple specs with collision resolution 4 min collision-resolution joiner Handle schema collisions: fail, accept-left, accept-right 3 min schema-deduplication joiner Consolidate identical schemas across documents 3 min schema-renaming joiner Preserve both schemas with rename strategies 4 min breaking-change-detection differ Detect breaking changes between API versions 4 min overlay-transformations overlay Apply environment-specific customizations 3 min http-validation httpvalidator Runtime HTTP request/response validation 5 min"},{"location":"examples/workflows/#quick-start","title":"Quick Start","text":"<p>Each example is a standalone Go module. To run any example:</p> <pre><code>cd examples/workflows/&lt;workflow-name&gt;\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/#workflow-overview","title":"Workflow Overview","text":""},{"location":"examples/workflows/#pipeline-compositions","title":"Pipeline Compositions","text":"<p>The pipeline-compositions workflow demonstrates multi-step oastools operations:</p> <ol> <li>Convert Legacy \u2192 Validate \u2192 Generate (OAS 2.0 to Go code)</li> <li>Fix \u2192 Validate (repair and confirm)</li> <li>Fix All \u2192 Join \u2192 Validate \u2192 Generate (microservices consolidation)</li> </ol> <p>Use cases: CI/CD pipelines, legacy migration, microservice consolidation</p>"},{"location":"examples/workflows/#fixer-showcase","title":"Fixer Showcase","text":"<p>The fixer-showcase workflow demonstrates all available fix types:</p> <ol> <li>CSV enum expansion (go-restful-openapi pattern)</li> <li>Duplicate operationId renaming</li> <li>Empty path item removal</li> <li>Generic schema name sanitization</li> <li>Missing path parameter injection</li> <li>Unused schema pruning</li> </ol> <p>Use cases: Understanding all fixer capabilities, comparing fix types, learning the API</p>"},{"location":"examples/workflows/#validate-and-fix","title":"Validate and Fix","text":"<p>The validate-and-fix workflow shows how to automatically repair common OpenAPI spec issues:</p> <ol> <li>Parse the specification</li> <li>Validate and identify errors</li> <li>Preview fixes with dry-run mode</li> <li>Apply fixes automatically</li> <li>Re-validate to confirm resolution</li> </ol> <p>Use cases: CI/CD pre-commit hooks, spec cleanup automation</p>"},{"location":"examples/workflows/#version-conversion","title":"Version Conversion","text":"<p>The version-conversion workflow demonstrates OAS version migration:</p> <ol> <li>Parse OAS 2.0 (Swagger) specification</li> <li>Convert to OAS 3.0.3</li> <li>Track conversion issues and warnings</li> <li>Access the converted document</li> </ol> <p>Use cases: Legacy API migration, spec modernization</p>"},{"location":"examples/workflows/#version-migration","title":"Version Migration","text":"<p>The version-migration workflow demonstrates modern OAS version handling:</p> <ol> <li>Upgrade OAS 3.0 \u2192 3.1 (gains webhooks, type arrays)</li> <li>Upgrade OAS 3.0 \u2192 3.2 (latest features)</li> <li>Downgrade OAS 3.1 \u2192 3.0 (potential feature loss)</li> <li>Downgrade OAS 3.1 \u2192 2.0 (lossy - webhooks lost!)</li> </ol> <p>Use cases: Tool compatibility, spec modernization, understanding version differences</p>"},{"location":"examples/workflows/#multi-api-merge","title":"Multi-API Merge","text":"<p>The multi-api-merge workflow shows how to combine microservice specs:</p> <ol> <li>Parse multiple OpenAPI specs</li> <li>Configure collision resolution strategies</li> <li>Merge with semantic deduplication</li> <li>Handle path and schema conflicts</li> </ol> <p>Use cases: API gateway specs, unified documentation, monorepo builds</p>"},{"location":"examples/workflows/#collision-resolution","title":"Collision Resolution","text":"<p>The collision-resolution workflow demonstrates what happens when schemas collide:</p> <ol> <li>Load specs with same-named but different schemas</li> <li>See fail-on-collision behavior (default - safest)</li> <li>Use accept-left to keep first document's schema</li> <li>Use accept-right to keep second document's schema</li> </ol> <p>Use cases: Understanding merge conflicts, choosing resolution strategies</p>"},{"location":"examples/workflows/#schema-deduplication","title":"Schema Deduplication","text":"<p>The schema-deduplication workflow consolidates identical schemas:</p> <ol> <li>Identify structurally equivalent schemas across documents</li> <li>Use deduplicate-equivalent for same-named collisions</li> <li>Use semantic-deduplication for different-named equivalents</li> <li>Automatic $ref rewriting to canonical name</li> </ol> <p>Use cases: Reducing spec size, consolidating shared types like Error</p>"},{"location":"examples/workflows/#schema-renaming","title":"Schema Renaming","text":"<p>The schema-renaming workflow preserves both conflicting schemas:</p> <ol> <li>Use rename-right/rename-left strategies</li> <li>Customize names with RenameTemplate</li> <li>Apply namespace prefixes for consistent naming</li> <li>Automatic $ref rewriting throughout document</li> </ol> <p>Use cases: Merging APIs with legitimately different same-named types</p>"},{"location":"examples/workflows/#breaking-change-detection","title":"Breaking Change Detection","text":"<p>The breaking-change-detection workflow implements CI/CD quality gates:</p> <ol> <li>Parse base and target specifications</li> <li>Compare for breaking changes</li> <li>Categorize by severity (CRITICAL, ERROR, WARNING, INFO)</li> <li>Generate reports for PR reviews</li> </ol> <p>Use cases: CI/CD gates, release validation, API governance</p>"},{"location":"examples/workflows/#overlay-transformations","title":"Overlay Transformations","text":"<p>The overlay-transformations workflow applies environment-specific changes:</p> <ol> <li>Parse base specification</li> <li>Load overlay document with JSONPath actions</li> <li>Preview changes in dry-run mode</li> <li>Apply transformations</li> </ol> <p>Use cases: Multi-environment configs, security additions, filtering internal endpoints</p>"},{"location":"examples/workflows/#http-validation","title":"HTTP Validation","text":"<p>The http-validation workflow validates runtime HTTP traffic:</p> <ol> <li>Parse specification</li> <li>Create HTTP validator</li> <li>Validate requests (path, query, body)</li> <li>Extract typed path parameters</li> <li>Validate responses</li> </ol> <p>Use cases: Request validation middleware, API testing, contract compliance</p>"},{"location":"examples/workflows/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/workflows/#parse-once-optimization","title":"Parse-Once Optimization","text":"<p>All workflows demonstrate the parse-once pattern for maximum performance:</p> <pre><code>// Parse once\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"spec.yaml\"))\n\n// Reuse for multiple operations\nfixer.FixWithOptions(fixer.WithParsed(*parsed))\nvalidator.ValidateWithOptions(validator.WithParsed(*parsed))\n</code></pre> <p>This avoids re-parsing the same spec, providing 9-154x performance improvements.</p>"},{"location":"examples/workflows/#functional-options","title":"Functional Options","text":"<p>All packages use the functional options pattern for clean, extensible configuration:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n</code></pre>"},{"location":"examples/workflows/#error-handling","title":"Error Handling","text":"<p>All workflows include proper error handling with rich error types:</p> <pre><code>result, err := differ.DiffWithOptions(...)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Iterate over changes and filter by breaking status\nfor _, change := range result.Changes {\n    if result.HasBreakingChanges {\n        fmt.Printf(\"[%s] %s: %s\\n\",\n            change.Category,\n            change.Severity,\n            change.Message)\n    }\n}\n</code></pre>"},{"location":"examples/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Examples - Basic parser and validator usage</li> <li>Programmatic API - Build specs from Go code</li> <li>Code Generation - Generate client/server code</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/breaking-change-detection/","title":"Breaking Change Detection","text":"<p>Demonstrates comparing API versions and detecting breaking changes using the differ package.</p>"},{"location":"examples/workflows/breaking-change-detection/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to compare two API versions programmatically</li> <li>Understanding severity levels for API changes</li> <li>Using diff results for CI/CD pipeline gates</li> <li>Interpreting change categories (endpoint, parameter, schema)</li> </ul>"},{"location":"examples/workflows/breaking-change-detection/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/breaking-change-detection/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/breaking-change-detection\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/breaking-change-detection/#expected-output","title":"Expected Output","text":"<pre><code>Breaking Change Detection Workflow\n===================================\n\nComparing:\n  Source (old): v1.yaml\n  Target (new): v2.yaml\n\n[1/3] Analyzing changes...\n      Source Version: 3.0.3\n      Target Version: 3.0.3\n      Total Changes: 12\n\n[2/3] Change Summary:\n      Breaking (Error+Critical): 5\n      Warnings: 3\n      Info: 4\n\n[3/3] Detailed Changes:\n\n      parameter:\n        [ERROR] required changed from false to true\n             at document.paths./products.get.parameters[category:query].required\n\n      schema:\n        [ERROR] maximum constraint changed\n             at document.paths./products.get.parameters[limit:query].schema.maximum\n        [ERROR] schema type changed\n             at document.paths./products/{productId}.get.parameters[productId:path].schema.type\n        [ERROR] required field \"sku\" added\n             at document.components.schemas.Product.required[sku]\n        [WARNING] property \"inStock\" removed\n             at document.components.schemas.Product.properties.inStock\n        [WARNING] property \"sku\" added\n             at document.components.schemas.Product.properties.sku\n        [INFO] schema \"Review\" added\n             at document.components.schemas.Review\n\n      response:\n        [WARNING] response code 404 removed\n             at document.paths./products/{productId}.get.responses[404]\n\n      operation:\n        [ERROR] operation delete removed\n             at document.paths./products/{productId}.delete\n\n      endpoint:\n        [INFO] endpoint \"/products/{productId}/reviews\" added\n             at document.paths./products/{productId}/reviews\n\n      info:\n        [INFO] API version changed from \"1.0.0\" to \"2.0.0\"\n             at document.info.version\n        [INFO] description changed\n             at document.info.description\n\n---\nBREAKING CHANGES DETECTED: 5\n\nRecommendations:\n  - Consider incrementing major version\n  - Update API documentation\n  - Notify API consumers\n</code></pre>"},{"location":"examples/workflows/breaking-change-detection/#files","title":"Files","text":"File Purpose main.go Demonstrates the breaking change detection workflow specs/v1.yaml Original API version specs/v2.yaml Updated API version with breaking changes"},{"location":"examples/workflows/breaking-change-detection/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/breaking-change-detection/#severity-levels","title":"Severity Levels","text":"Level Meaning CI Action CRITICAL API consumers will break Block deployment ERROR API consumers likely to break Block deployment WARNING API consumers may be affected Review required INFO Non-breaking additions Safe to deploy"},{"location":"examples/workflows/breaking-change-detection/#breaking-changes-in-v2","title":"Breaking Changes in v2","text":"Change Category Severity DELETE endpoint removed endpoint CRITICAL Parameter made required parameter ERROR Parameter type changed parameter ERROR Required field added schema ERROR Field removed schema ERROR Maximum reduced parameter WARNING"},{"location":"examples/workflows/breaking-change-detection/#non-breaking-changes","title":"Non-Breaking Changes","text":"Change Category Severity New endpoint added endpoint INFO New schema added schema INFO"},{"location":"examples/workflows/breaking-change-detection/#cicd-integration","title":"CI/CD Integration","text":"<p>Use the exit code for pipeline gates:</p> <ul> <li>Exit 0: No breaking changes, safe to deploy</li> <li>Exit 1: Breaking changes detected, block deployment</li> </ul> <pre><code># Example GitHub Actions step\n- name: Check for breaking changes\n  run: |\n    go run examples/workflows/breaking-change-detection/main.go\n</code></pre>"},{"location":"examples/workflows/breaking-change-detection/#next-steps","title":"Next Steps","text":"<ul> <li>Differ Deep Dive - Complete differ documentation</li> <li>Breaking Changes Guide - Detailed explanation</li> <li>Multi-API Merge - Merge API versions</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/collision-resolution/","title":"Collision Resolution","text":"<p>Demonstrates how to handle schema collisions when merging OpenAPI specifications using the joiner package.</p>"},{"location":"examples/workflows/collision-resolution/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How schema collisions occur when merging APIs</li> <li>Using <code>fail-on-collision</code> to detect conflicts early</li> <li>Using <code>accept-left</code> to keep the first document's schema</li> <li>Using <code>accept-right</code> to keep the second document's schema</li> <li>Understanding the data loss implications of each strategy</li> </ul>"},{"location":"examples/workflows/collision-resolution/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/collision-resolution/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/collision-resolution\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/collision-resolution/#expected-output","title":"Expected Output","text":"<pre><code>Collision Resolution Strategies\n================================\n\nScenario: Both APIs define a 'Transaction' schema with different structures\n  - payments-api.yaml: Transaction for payments (amount, currency, paymentMethod)\n  - orders-api.yaml: Transaction for orders (orderId, items, total)\n\n[1/3] Strategy: fail-on-collision (default)\n---------------------------------------------\n  Result: Error (as expected)\n  Message: joiner: collision in components.schemas: 'Transaction'\n    First defined in:  .../payments-api.yaml at components.schemas.Transaction\n    Also defined in:   .../orders-api.yaml at components.schemas.Transaction\n    Strategy: fail (set --schema-strategy to 'accept-left' or 'accept-right' to resolve)\n\n  This is the safest default - it forces you to explicitly\n  choose how to handle the conflict.\n\n[2/3] Strategy: accept-left\n---------------------------------------------\n  Result: Success\n  Collisions resolved: 1\n  Transaction schema kept: payments-api (left)\n  Properties: [amount currency id paymentMethod processedAt]\n  Warnings:\n    - components.schemas 'Transaction' kept from first document: source .../orders-api.yaml\n\n  The orders-api Transaction schema was DROPPED.\n  Any code expecting orderId/items/total will break!\n\n[3/3] Strategy: accept-right\n---------------------------------------------\n  Result: Success\n  Collisions resolved: 1\n  Transaction schema kept: orders-api (right)\n  Properties: [createdAt id items orderId total]\n  Warnings:\n    - components.schemas 'Transaction' overwritten: source .../orders-api.yaml\n\n  The payments-api Transaction schema was DROPPED.\n  Any code expecting amount/currency/paymentMethod will break!\n\n===============================================\nKey Takeaway: accept-left/right silently drops one schema.\nIf you need BOTH schemas, use rename-left/right instead.\nSee: examples/workflows/schema-renaming/\n</code></pre>"},{"location":"examples/workflows/collision-resolution/#files","title":"Files","text":"File Purpose main.go Demonstrates the three collision resolution strategies specs/payments-api.yaml Payment processing API with Transaction schema specs/orders-api.yaml Order management API with a different Transaction schema"},{"location":"examples/workflows/collision-resolution/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/collision-resolution/#collision-strategies","title":"Collision Strategies","text":"Strategy Behavior Use Case <code>StrategyFailOnCollision</code> Returns an error when schemas collide CI pipelines, explicit conflict resolution <code>StrategyAcceptLeft</code> Keeps the first document's schema When the first API is authoritative <code>StrategyAcceptRight</code> Keeps the second document's schema When newer APIs should override older ones <code>StrategyRenameLeft</code> Keeps both, renames first schema Preserve all schemas (see schema-renaming example) <code>StrategyRenameRight</code> Keeps both, renames second schema Preserve all schemas (see schema-renaming example)"},{"location":"examples/workflows/collision-resolution/#when-to-use-each-strategy","title":"When to Use Each Strategy","text":"<p>fail-on-collision (Recommended Default)</p> <ul> <li>Best for CI/CD pipelines where collisions should block merges</li> <li>Forces explicit decisions about how to resolve conflicts</li> <li>Prevents accidental data loss</li> </ul> <p>accept-left</p> <ul> <li>When the first API is the \"source of truth\"</li> <li>Merging secondary/supplementary APIs into a primary API</li> <li>Legacy API takes precedence over newer additions</li> </ul> <p>accept-right</p> <ul> <li>When newer APIs should override older definitions</li> <li>Progressive migration scenarios</li> <li>Last-write-wins semantics</li> </ul>"},{"location":"examples/workflows/collision-resolution/#the-problem-with-accept-strategies","title":"The Problem with Accept Strategies","text":"<p>Both <code>accept-left</code> and <code>accept-right</code> silently drop one schema. This can cause:</p> <ol> <li>Runtime errors - Code generated against the dropped schema won't work</li> <li>Silent data loss - Requests/responses may fail validation</li> <li>Confusion - Different teams may have different expectations</li> </ol>"},{"location":"examples/workflows/collision-resolution/#better-alternative-rename-strategies","title":"Better Alternative: Rename Strategies","text":"<p>If you need BOTH schemas preserved, use <code>StrategyRenameLeft</code> or <code>StrategyRenameRight</code>:</p> <pre><code>config := joiner.DefaultConfig()\nconfig.SchemaStrategy = joiner.StrategyRenameRight  // Keeps both schemas\n</code></pre> <p>This produces:</p> <ul> <li><code>Transaction</code> (from payments-api)</li> <li><code>Transaction_orders-api</code> (renamed from orders-api)</li> </ul> <p>See the schema-renaming example for details.</p>"},{"location":"examples/workflows/collision-resolution/#next-steps","title":"Next Steps","text":"<ul> <li>Schema Renaming - Keep both schemas with automatic renaming</li> <li>Multi-API Merge - Complete merge workflow with semantic deduplication</li> <li>Breaking Change Detection - Detect when merges cause breaking changes</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/fixer-showcase/","title":"Fixer Showcase","text":"<p>Demonstrates all available fix types in the oastools fixer package with before/after comparison.</p>"},{"location":"examples/workflows/fixer-showcase/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>All available fix types and what each one does</li> <li>When to use each fix type</li> <li>Using dry-run mode to preview changes</li> <li>Applying multiple fixes at once</li> <li>Chaining fixes with validation using <code>ToParseResult()</code></li> </ul>"},{"location":"examples/workflows/fixer-showcase/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/fixer-showcase/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/fixer-showcase\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#fix-types","title":"Fix Types","text":"Fix Type What It Fixes Example <code>FixTypeEnumCSVExpanded</code> CSV enum values <code>enum: [\"1,2,3\"]</code> -&gt; <code>enum: [1, 2, 3]</code> <code>FixTypeDuplicateOperationId</code> Duplicate operation IDs <code>getPets</code> -&gt; <code>getPets</code>, <code>getPets2</code> <code>FixTypePrunedEmptyPath</code> Empty path items <code>/empty: {}</code> -&gt; removed <code>FixTypeRenamedGenericSchema</code> Generic schema names <code>Response[Pet]</code> -&gt; <code>Response_Pet_</code> <code>FixTypeMissingPathParameter</code> Missing path params <code>/{petId}</code> without param -&gt; param added <code>FixTypePrunedUnusedSchema</code> Unreferenced schemas Orphan schemas -&gt; removed"},{"location":"examples/workflows/fixer-showcase/#expected-output","title":"Expected Output","text":"<pre><code>Fixer Showcase: All Available Fix Types\n=======================================\n\nThis spec intentionally contains common issues:\n  - CSV enum values (should be array)\n  - Duplicate operationIds\n  - Empty path items\n  - Generic schema names like Response[Pet]\n  - Missing path parameter definitions\n  - Unused/unreferenced schemas\n\n[0/7] Initial Validation\n------------------------\n  [X] Found 4 validation errors:\n    - oas 3.0.3: duplicate operationId 'getPets' at 'paths./pet...\n    - Path template references parameter '{petId}' but it is no...\n    - Path template references parameter '{petId}' but it is no...\n    - Duplicate operationId 'getPets' (first seen at paths./pet...\n\n[1/7] Fix: CSV Enums\n------------------------\n  -&gt; CSV enum values -&gt; proper arrays\n  [OK] Applied 1 fix(es):\n    - expanded CSV enum string to 5 individual values\n\n[2/7] Fix: Duplicate OperationIds\n------------------------\n  -&gt; Duplicate IDs -&gt; unique suffixed IDs\n  [OK] Applied 1 fix(es):\n    - renamed duplicate operationId \"getPets\" to \"getPets2\"...\n\n...\n\n[7/7] Apply ALL Fixes\n------------------------\n  Dry-run preview:\n    Would apply 8 fixes\n    - pruned-unused-schema: 2\n    - pruned-empty-path: 1\n    - missing-path-parameter: 2\n    - duplicate-operation-id: 1\n    - renamed-generic-schema: 1\n    - enum-csv-expanded: 1\n\n  Applying all fixes:\n  [OK] Applied 8 total fixes\n\n  Validation after fixes:\n  [OK] Spec is now VALID!\n  -&gt; Final schema count: 2\n  -&gt; Schemas: Pet, Response_Pet_\n\n=======================================\nAvailable Fix Types:\n  fixer.FixTypeEnumCSVExpanded       - Convert CSV enums to arrays\n  fixer.FixTypeDuplicateOperationId  - Make operation IDs unique\n  fixer.FixTypePrunedEmptyPath       - Remove empty path items\n  fixer.FixTypeRenamedGenericSchema  - Sanitize generic names\n  fixer.FixTypeMissingPathParameter  - Add missing path params\n  fixer.FixTypePrunedUnusedSchema    - Remove unreferenced schemas\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#files","title":"Files","text":"File Purpose main.go Demonstrates all fix types individually and combined specs/problematic-api.yaml OpenAPI spec with all fixable issues"},{"location":"examples/workflows/fixer-showcase/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/fixer-showcase/#fixtype-constants","title":"FixType Constants","text":"<p>Each fix has a corresponding constant:</p> <pre><code>fixer.FixTypeEnumCSVExpanded       // \"enum-csv-expanded\"\nfixer.FixTypeDuplicateOperationId  // \"duplicate-operation-id\"\nfixer.FixTypePrunedEmptyPath       // \"pruned-empty-path\"\nfixer.FixTypeRenamedGenericSchema  // \"renamed-generic-schema\"\nfixer.FixTypeMissingPathParameter  // \"missing-path-parameter\"\nfixer.FixTypePrunedUnusedSchema    // \"pruned-unused-schema\"\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#enabling-specific-fixes","title":"Enabling Specific Fixes","text":"<p>By default, only <code>FixTypeMissingPathParameter</code> is enabled. To enable others:</p> <pre><code>f := fixer.New()\nf.EnabledFixes = []fixer.FixType{\n    fixer.FixTypeMissingPathParameter,\n    fixer.FixTypePrunedUnusedSchema,\n    fixer.FixTypeRenamedGenericSchema,\n}\nresult, err := f.FixParsed(*parsed)\n</code></pre> <p>Or using functional options:</p> <pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"spec.yaml\"),\n    fixer.WithEnabledFixes(\n        fixer.FixTypeMissingPathParameter,\n        fixer.FixTypePrunedUnusedSchema,\n    ),\n)\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#dry-run-mode","title":"Dry-Run Mode","text":"<p>Preview changes without modifying the document:</p> <pre><code>preview, err := fixer.FixWithOptions(\n    fixer.WithParsed(*parsed),\n    fixer.WithDryRun(true),\n)\nfmt.Printf(\"Would apply %d fixes\\n\", preview.FixCount)\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#chaining-with-toparseresult","title":"Chaining with ToParseResult()","text":"<p>Convert fix results for use with other packages:</p> <pre><code>// Fix\nfixResult, _ := fixer.FixWithOptions(\n    fixer.WithFilePath(\"api.yaml\"),\n    fixer.WithEnabledFixes(...),\n)\n\n// Validate the fixed result\nv := validator.New()\nvalidation, _ := v.ValidateParsed(*fixResult.ToParseResult())\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#use-cases","title":"Use Cases","text":""},{"location":"examples/workflows/fixer-showcase/#cicd-pre-commit","title":"CI/CD Pre-commit","text":"<p>Automatically fix specs before committing:</p> <pre><code>oastools fix --all spec.yaml -o spec.yaml\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#spec-cleanup","title":"Spec Cleanup","text":"<p>Remove unused schemas and fix naming issues:</p> <pre><code>f := fixer.New()\nf.EnabledFixes = []fixer.FixType{\n    fixer.FixTypePrunedUnusedSchema,\n    fixer.FixTypeRenamedGenericSchema,\n}\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#legacy-spec-migration","title":"Legacy Spec Migration","text":"<p>Fix issues from older generators (e.g., go-restful-openapi CSV enums):</p> <pre><code>f := fixer.New()\nf.EnabledFixes = []fixer.FixType{\n    fixer.FixTypeEnumCSVExpanded,\n    fixer.FixTypeDuplicateOperationId,\n}\n</code></pre>"},{"location":"examples/workflows/fixer-showcase/#next-steps","title":"Next Steps","text":"<ul> <li>Validate and Fix - Simpler validate-fix-validate workflow</li> <li>Version Conversion - Convert between OAS versions</li> <li>Fixer Package Docs - Complete API documentation</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/http-validation/","title":"HTTP Validation","text":"<p>Demonstrates runtime HTTP request/response validation using the httpvalidator package.</p>"},{"location":"examples/workflows/http-validation/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create an HTTP validator from an OpenAPI spec</li> <li>Validating request parameters (path, query, header)</li> <li>Validating request bodies against schema</li> <li>Extracting typed path parameters</li> <li>Validating responses for contract compliance</li> <li>Securely logging validation errors without exposing credentials</li> </ul>"},{"location":"examples/workflows/http-validation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/http-validation/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/http-validation\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/http-validation/#expected-output","title":"Expected Output","text":"<pre><code>HTTP Validation Workflow\n========================\n\n[1/6] Creating HTTP validator...\n      Validator created, strict mode: false\n\n[2/6] Validating GET /todos?status=pending&amp;limit=10...\n      Valid: true\n      Matched Path: /todos\n\n[3/6] Validating GET /todos?status=invalid...\n      Valid: false\n      Matched Path: /todos\n      Errors: 1 validation issue(s) found\n\n[4/6] Validating POST /todos with valid body...\n      Valid: true\n      Matched Path: /todos\n\n[5/6] Validating POST /todos with invalid body...\n      Valid: true\n      Matched Path: /todos\n\n[6/6] Path parameter extraction...\n      Matched Path: /todos/{todoId}\n      todoId: 42\n      Valid: true\n\n[Bonus] Response validation...\n      Response Valid: true\n      Status Code: 200\n\n---\nHTTP Validation examples complete\n</code></pre>"},{"location":"examples/workflows/http-validation/#files","title":"Files","text":"File Purpose main.go Demonstrates the HTTP validation workflow specs/api.yaml OpenAPI spec with validation constraints"},{"location":"examples/workflows/http-validation/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/http-validation/#creating-a-validator","title":"Creating a Validator","text":"<pre><code>parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nv, _ := httpvalidator.New(parsed)\nv.StrictMode = false  // Allow unknown headers\n</code></pre>"},{"location":"examples/workflows/http-validation/#request-validation","title":"Request Validation","text":"<pre><code>req := httptest.NewRequest(\"POST\", \"/todos\", body)\nreq.Header.Set(\"Content-Type\", \"application/json\")\n\nresult, _ := v.ValidateRequest(req)\nif !result.Valid {\n    for _, err := range result.Errors {\n        log.Printf(\"[%s] %s\", err.Path, err.Message)\n    }\n}\n</code></pre>"},{"location":"examples/workflows/http-validation/#path-parameter-extraction","title":"Path Parameter Extraction","text":"<pre><code>result, _ := v.ValidateRequest(req)\ntodoId := result.PathParams[\"todoId\"]  // Extracted from /todos/{todoId}\n</code></pre>"},{"location":"examples/workflows/http-validation/#response-validation","title":"Response Validation","text":"<pre><code>result, _ := v.ValidateResponseData(req, statusCode, headers, body)\nif !result.Valid {\n    // Response doesn't match spec\n}\n</code></pre>"},{"location":"examples/workflows/http-validation/#validation-types","title":"Validation Types","text":"Validation Description Path parameters Type, format, constraints (min/max) Query parameters Type, enum values, constraints Request body Required fields, schema validation Response body Schema compliance check"},{"location":"examples/workflows/http-validation/#secure-error-logging","title":"Secure Error Logging","text":"<p>The httpvalidator package automatically redacts values in error messages for potentially sensitive parameters (headers and cookies). This means validation error messages are safe to log:</p> <pre><code>result, _ := v.ValidateRequest(req)\nfor _, err := range result.Errors {\n    // Safe to log - sensitive header/cookie values are redacted at source\n    log.Printf(\"[%s] %s\", err.Path, err.Message)\n}\n</code></pre> <p>How it works:</p> <ul> <li>Query params, path params, body: Full values included (helpful for debugging)</li> <li>Headers, cookies: Values redacted (e.g., \"value is not one of the allowed values\" instead of \"value 'Bearer sk-xxx' is not...\")</li> </ul> <p>Note: This example prints only paths to satisfy static analysis tools, but in production you can safely log the full <code>err.Message</code>.</p>"},{"location":"examples/workflows/http-validation/#middleware-integration","title":"Middleware Integration","text":"<pre><code>func validationMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        result, _ := v.ValidateRequest(r)\n        if !result.Valid {\n            http.Error(w, \"Invalid request\", http.StatusBadRequest)\n            return\n        }\n        // Store extracted params in context\n        ctx := context.WithValue(r.Context(), \"pathParams\", result.PathParams)\n        next.ServeHTTP(w, r.WithContext(ctx))\n    })\n}\n</code></pre>"},{"location":"examples/workflows/http-validation/#next-steps","title":"Next Steps","text":"<ul> <li>HTTPValidator Deep Dive - Complete documentation</li> <li>Validate and Fix - Fix spec validation errors</li> <li>Builder - Build specs programmatically</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/multi-api-merge/","title":"Multi-API Merge","text":"<p>Demonstrates merging multiple OpenAPI specifications using the joiner package.</p>"},{"location":"examples/workflows/multi-api-merge/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to merge microservice specifications into a unified API</li> <li>Configuring collision resolution strategies</li> <li>Using semantic deduplication for shared schemas</li> <li>Understanding merge warnings and collisions</li> </ul>"},{"location":"examples/workflows/multi-api-merge/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/multi-api-merge/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/multi-api-merge\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/multi-api-merge/#expected-output","title":"Expected Output","text":"<pre><code>Multi-API Merge Workflow\n========================\n\nInputs:\n  1. users-api.yaml\n  2. orders-api.yaml\n\n[1/4] Configuration:\n      Path Strategy: fail-on-paths\n      Schema Strategy: accept-left\n      Semantic Deduplication: true\n      Deduplicate Tags: true\n      Merge Arrays: true\n\n[2/4] Joining specifications...\n      Result Version: 3.0.3\n      Collisions Resolved: 1\n\n[3/4] No warnings\n\n[4/4] Writing merged specification...\n      Output: /tmp/merged-api.yaml\n\n--- Merged API Summary ---\nTitle: Users API\nVersion: 1.0.0\n\nServers: 2\n  - https://users.example.com/v1\n  - https://orders.example.com/v1\n\nTags: 2\n  - users\n  - orders\n\nPaths: 4\n  - /users\n  - /users/{userId}\n  - /orders\n  - /orders/{orderId}\n\nSchemas: 4\n  - User\n  - Error\n  - Order\n  - CreateOrderRequest\n\n---\nMerge completed successfully\n</code></pre>"},{"location":"examples/workflows/multi-api-merge/#files","title":"Files","text":"File Purpose main.go Demonstrates the multi-spec merge workflow specs/users-api.yaml User management microservice spec specs/orders-api.yaml Order management microservice spec"},{"location":"examples/workflows/multi-api-merge/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/multi-api-merge/#collision-strategies","title":"Collision Strategies","text":"Strategy Behavior <code>StrategyFailOnPaths</code> Error if paths conflict <code>StrategyFailOnCollision</code> Error on any component collision <code>StrategyAcceptLeft</code> Keep the first document's version <code>StrategyAcceptRight</code> Keep the second document's version"},{"location":"examples/workflows/multi-api-merge/#semantic-deduplication","title":"Semantic Deduplication","text":"<p>When <code>SemanticDeduplication: true</code>, the joiner identifies structurally identical schemas across documents and consolidates them. In this example:</p> <ul> <li>Both APIs define an <code>Error</code> schema with identical structure</li> <li>The joiner recognizes this and keeps a single <code>Error</code> schema</li> </ul>"},{"location":"examples/workflows/multi-api-merge/#merge-arrays","title":"Merge Arrays","text":"<p>When <code>MergeArrays: true</code>:</p> <ul> <li><code>servers</code> arrays are concatenated</li> <li><code>tags</code> are combined (with deduplication if enabled)</li> <li><code>security</code> requirements are merged</li> </ul>"},{"location":"examples/workflows/multi-api-merge/#use-cases","title":"Use Cases","text":"<ul> <li>API Gateway composition - Combine microservice specs into a gateway API</li> <li>Modular documentation - Split large APIs into manageable parts</li> <li>Multi-team development - Each team maintains their own spec</li> </ul>"},{"location":"examples/workflows/multi-api-merge/#next-steps","title":"Next Steps","text":"<ul> <li>Joiner Deep Dive - Complete joiner documentation</li> <li>Breaking Change Detection - Compare merged versions</li> <li>Overlay Transformations - Apply post-merge customizations</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/overlay-transformations/","title":"Overlay Transformations","text":"<p>Demonstrates applying OpenAPI Overlay transformations using the overlay package.</p>"},{"location":"examples/workflows/overlay-transformations/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to parse and validate overlay documents</li> <li>Using JSONPath expressions to target specific nodes</li> <li>Preview changes with dry-run mode</li> <li>Apply environment-specific customizations</li> </ul>"},{"location":"examples/workflows/overlay-transformations/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/overlay-transformations/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/overlay-transformations\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/overlay-transformations/#expected-output","title":"Expected Output","text":"<pre><code>Overlay Transformations Workflow\n=================================\n\nBase Spec: base.yaml\nOverlay: production.yaml\n\n[1/4] Validating overlay document...\n      Overlay is valid\n      Title: Production Environment Overlay\n      Actions defined: 5\n\n[2/4] Parsing base specification...\n      Version: 3.0.3\n\n[3/4] Previewing changes (dry-run)...\n      Would apply: 5 action(s)\n      Would skip: 0 action(s)\n\n      Changes:\n        - update 1 node(s) at $.info\n        - update 1 node(s) at $.servers[0]\n        - remove 1 node(s) at $.paths['/internal/metrics']\n        - remove 1 node(s) at $.paths['/internal/health']\n        - update 4 node(s) at $.paths.*.get.responses.200\n\n[4/4] Applying overlay...\n      Actions applied: 5\n      Actions skipped: 0\n\n--- Transformation Results ---\nNew Title: Payment API (Production)\nEnvironment: production\nProduction URL: https://api.payments.example.com/v1\nPaths (after removing internal): 2\n\nRemaining paths:\n  - /payments\n  - /payments/{paymentId}\n\n---\nOverlay applied successfully\n</code></pre>"},{"location":"examples/workflows/overlay-transformations/#files","title":"Files","text":"File Purpose main.go Demonstrates the overlay transformation workflow specs/base.yaml Base OpenAPI specification with internal endpoints specs/production.yaml Overlay document for production customizations"},{"location":"examples/workflows/overlay-transformations/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/overlay-transformations/#overlay-document-structure","title":"Overlay Document Structure","text":"<pre><code>overlay: \"1.0.0\"\ninfo:\n  title: Production Environment Overlay\n  version: \"1.0.0\"\nactions:\n  - target: &lt;JSONPath expression&gt;\n    update: &lt;value&gt;  # or remove: true\n</code></pre>"},{"location":"examples/workflows/overlay-transformations/#jsonpath-expressions","title":"JSONPath Expressions","text":"Expression Matches <code>$.info</code> The info object <code>$.servers[0]</code> First server <code>$.paths.*</code> All path items <code>$.paths.*.get</code> All GET operations <code>$..description</code> All descriptions at any depth <code>$.paths['/internal/health']</code> Path with special characters (bracket notation) <code>$.paths[?@.x-internal==true]</code> Paths with x-internal: true <p>Note: Paths containing slashes or special characters must use bracket notation with quotes, e.g., <code>$.paths['/internal/health']</code>.</p>"},{"location":"examples/workflows/overlay-transformations/#action-types","title":"Action Types","text":"Action Purpose <code>update</code> Merge values into target nodes <code>remove: true</code> Delete target nodes"},{"location":"examples/workflows/overlay-transformations/#use-cases","title":"Use Cases","text":"<ul> <li>Environment customization - Different servers, rate limits, descriptions</li> <li>Internal filtering - Remove internal endpoints for public docs</li> <li>Security additions - Add authentication requirements</li> <li>Metadata injection - Add tracking, versioning, or governance info</li> </ul>"},{"location":"examples/workflows/overlay-transformations/#next-steps","title":"Next Steps","text":"<ul> <li>Overlay Deep Dive - Complete overlay documentation</li> <li>OpenAPI Overlay Spec - Official specification</li> <li>HTTP Validation - Validate requests against the spec</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/pipeline-compositions/","title":"Pipeline Compositions","text":"<p>Demonstrates multi-step oastools workflows by chaining parser, fixer, converter, validator, joiner, and generator operations.</p>"},{"location":"examples/workflows/pipeline-compositions/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Chaining multiple oastools operations together</li> <li>Reusing parsed documents for efficiency (parse once, use many times)</li> <li>Common pipeline patterns for real-world scenarios</li> <li>Using <code>ToParseResult()</code> for seamless package chaining</li> </ul>"},{"location":"examples/workflows/pipeline-compositions/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/pipeline-compositions/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/pipeline-compositions\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#expected-output","title":"Expected Output","text":"<pre><code>Pipeline Compositions\n=====================\n\nDemonstrating multi-step oastools workflows\n\n[1/3] Pipeline: Convert Legacy -&gt; Validate -&gt; Generate\n-------------------------------------------------------\n  Step 1: Parse OAS 2.0 spec\n    \u2713 Parsed: legacy-api.yaml (OAS 2.0)\n  Step 2: Convert to OAS 3.0.3\n    \u2713 Converted to OAS 3.0.3\n  Step 3: Validate converted spec\n    \u2713 Validation passed\n  Step 4: Generate Go types\n    \u2713 Generated 1 files\n\n  Result: Legacy OAS 2.0 -&gt; OAS 3.0.3 -&gt; Go types \u2713\n\n[2/3] Pipeline: Fix -&gt; Validate\n-------------------------------------------------------\n  Step 1: Parse and identify issues\n    \u2713 Parsed: service-a.yaml\n  Step 2: Validate (before fix)\n    \u2717 Found 2 validation errors\n      - oas 3.0.3: duplicate operationId 'getItems' at 'paths./items/{itemId}.get'...\n      - Duplicate operationId 'getItems' (first seen at paths./items.get)\n  Step 3: Apply fixes\n    \u2713 Applied 1 fixes\n      - renamed duplicate operationId \"getItems\" to \"getItems2\" (first occurrence at GET /items)\n  Step 4: Validate (after fix)\n    \u2713 Validation passed\n\n  Result: Spec with issues -&gt; Fixed -&gt; Valid \u2713\n\n[3/3] Pipeline: Fix All -&gt; Join -&gt; Validate -&gt; Generate\n-------------------------------------------------------\n  Step 1: Parse all specs\n    \u2713 Parsed: service-a.yaml, service-b.yaml\n  Step 2: Fix all specs\n    \u2713 Service A: 1 fixes applied\n    \u2713 Service B: 0 fixes applied\n  Step 3: Join fixed specs\n    \u2713 Joined: OAS 3.0.3\n  Step 4: Validate joined spec\n    \u2713 Validation passed\n  Step 5: Generate Go code\n    \u2713 Generated 1 files\n\n  Result: Multiple specs -&gt; Fixed -&gt; Joined -&gt; Validated -&gt; Generated \u2713\n\n=======================================================\nKey Takeaways:\n  - Chain operations for complex workflows\n  - Parse once, reuse for multiple operations\n  - Fix before join to ensure clean merge\n  - Convert legacy specs before code generation\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#files","title":"Files","text":"File Purpose main.go Demonstrates three pipeline patterns specs/legacy-api.yaml OAS 2.0 (Swagger) spec for conversion demo specs/service-a.yaml OAS 3.0.3 spec with duplicate operationId specs/service-b.yaml OAS 3.0.3 spec for joining demo"},{"location":"examples/workflows/pipeline-compositions/#pipeline-patterns","title":"Pipeline Patterns","text":""},{"location":"examples/workflows/pipeline-compositions/#pattern-1-convert-legacy-validate-generate","title":"Pattern 1: Convert Legacy -&gt; Validate -&gt; Generate","text":"<p>Upgrades a legacy Swagger 2.0 specification to OpenAPI 3.0.3, validates the converted result, and generates Go types.</p> <pre><code>// Parse OAS 2.0\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"swagger.yaml\"))\n\n// Convert to OAS 3.0.3\nc := converter.New()\nconverted, _ := c.ConvertParsed(*parsed, \"3.0.3\")\n\n// Validate converted spec\nv := validator.New()\nvalidation, _ := v.ValidateParsed(*converted.ToParseResult())\n\n// Generate Go types\ngenResult, _ := generator.GenerateWithOptions(\n    generator.WithParsed(*converted.ToParseResult()),\n    generator.WithPackageName(\"api\"),\n)\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#pattern-2-fix-validate","title":"Pattern 2: Fix -&gt; Validate","text":"<p>Identifies and automatically fixes issues in a specification, then validates the result.</p> <pre><code>// Parse spec\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"spec.yaml\"))\n\n// Fix issues\nfixResult, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*parsed),\n    fixer.WithEnabledFixes(fixer.FixTypeDuplicateOperationId),\n)\n\n// Validate fixed spec\nv := validator.New()\nvalidation, _ := v.ValidateParsed(*fixResult.ToParseResult())\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#pattern-3-fix-all-join-validate-generate","title":"Pattern 3: Fix All -&gt; Join -&gt; Validate -&gt; Generate","text":"<p>Fixes multiple specifications independently, joins them into a unified API, validates, and generates code.</p> <pre><code>// Parse all specs\nparsedA, _ := parser.ParseWithOptions(parser.WithFilePath(\"service-a.yaml\"))\nparsedB, _ := parser.ParseWithOptions(parser.WithFilePath(\"service-b.yaml\"))\n\n// Fix each spec\nfixedA, _ := fixer.FixWithOptions(fixer.WithParsed(*parsedA), ...)\nfixedB, _ := fixer.FixWithOptions(fixer.WithParsed(*parsedB), ...)\n\n// Join fixed specs\njoinResult, _ := joiner.JoinWithOptions(\n    joiner.WithParsed(*fixedA.ToParseResult(), *fixedB.ToParseResult()),\n    joiner.WithSchemaStrategy(joiner.StrategyAcceptLeft),\n)\n\n// Validate and generate\nv := validator.New()\nvalidation, _ := v.ValidateParsed(*joinResult.ToParseResult())\ngenResult, _ := generator.GenerateWithOptions(\n    generator.WithParsed(*joinResult.ToParseResult()),\n    generator.WithPackageName(\"unified\"),\n)\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/pipeline-compositions/#toparseresult-for-chaining","title":"ToParseResult() for Chaining","text":"<p>Each package result type provides a <code>ToParseResult()</code> method that converts the result to a <code>parser.ParseResult</code> for use with downstream packages:</p> Package Result Type ToParseResult() converter <code>*ConversionResult</code> \u2713 fixer <code>*FixResult</code> \u2713 joiner <code>*JoinResult</code> \u2713 <pre><code>// Chain converter -&gt; validator\nconverted, _ := c.ConvertParsed(*parsed, \"3.0.3\")\nvalidation, _ := v.ValidateParsed(*converted.ToParseResult())\n\n// Chain fixer -&gt; generator\nfixResult, _ := fixer.FixWithOptions(...)\ngenResult, _ := generator.GenerateWithOptions(\n    generator.WithParsed(*fixResult.ToParseResult()),\n    ...\n)\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#parse-once-optimization","title":"Parse-Once Optimization","text":"<p>Parsing is expensive. For pipelines that need the same spec multiple times, parse once and reuse:</p> <pre><code>// Parse once\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"spec.yaml\"))\n\n// Reuse for multiple operations\nv.ValidateParsed(*parsed)\nf.FixParsed(*parsed)\nc.ConvertParsed(*parsed, \"3.1.0\")\n</code></pre>"},{"location":"examples/workflows/pipeline-compositions/#use-cases","title":"Use Cases","text":"<ul> <li>CI/CD Pipelines: Validate -&gt; Fix -&gt; Generate in automated builds</li> <li>Legacy Migration: Convert OAS 2.0 -&gt; 3.x before generating modern clients</li> <li>Microservice Consolidation: Fix individual specs -&gt; Join -&gt; Generate unified SDK</li> <li>Pre-commit Hooks: Parse -&gt; Validate -&gt; Fix (dry-run) -&gt; Report</li> </ul>"},{"location":"examples/workflows/pipeline-compositions/#next-steps","title":"Next Steps","text":"<ul> <li>Validate and Fix - Deep dive into the fixer package</li> <li>Version Conversion - Converting between OAS versions</li> <li>Multi-API Merge - Advanced joining strategies</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/schema-deduplication/","title":"Schema Deduplication","text":"<p>Demonstrates schema deduplication strategies when merging OpenAPI specifications using the joiner package.</p>"},{"location":"examples/workflows/schema-deduplication/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to identify structurally identical schemas across documents</li> <li>Using <code>deduplicate-equivalent</code> strategy for same-named schema collisions</li> <li>Using <code>semantic-deduplication</code> for different-named equivalent schemas</li> <li>Understanding when each approach applies</li> </ul>"},{"location":"examples/workflows/schema-deduplication/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/schema-deduplication/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/schema-deduplication\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/schema-deduplication/#expected-output","title":"Expected Output","text":"<pre><code>Schema Deduplication Strategies\n================================\n\nScenario: Both APIs have error schemas with IDENTICAL structure\n  - users-api.yaml: UserError {code, message, details}\n  - products-api.yaml: ProductError {code, message, details}\n\nThese are structurally equivalent but have different names.\n\n[1/3] Baseline: No deduplication\n-----------------------------------------\n  Result: Success\n  Schemas in merged doc: [Product ProductError User UserError]\n\n  Note: Both UserError and ProductError exist in output.\n  This is wasteful since they're structurally identical!\n\n[2/3] Strategy: deduplicate-equivalent\n-----------------------------------------\n  This strategy handles SAME-named collisions.\n  When two schemas named 'Error' collide:\n    - If structurally equivalent -&gt; keep one\n    - If different -&gt; fail\n\n  Configuration:\n    SchemaStrategy: deduplicate\n    EquivalenceMode: deep\n\n  Use case: When teams independently define the same schema\n  with the same name - common with shared types like Error.\n\n[3/3] Strategy: semantic-deduplication\n-----------------------------------------\n  Result: Success\n  Schemas in merged doc: [Product ProductError User]\n\n  UserError was deduplicated to ProductError\n     (ProductError &lt; UserError alphabetically)\n\n  Warnings:\n    - semantic deduplication: consolidated 1 duplicate schema(s)\n\n  Configuration:\n    SemanticDeduplication: true\n\n  The joiner identified that UserError = ProductError\n  and consolidated them. All $refs are automatically rewritten.\n\n=========================================\nKey Takeaway:\n  - deduplicate-equivalent: Merges SAME-named schemas if equivalent\n  - semantic-deduplication: Finds DIFFERENT-named equivalent schemas\n                            and consolidates to canonical name\n</code></pre>"},{"location":"examples/workflows/schema-deduplication/#files","title":"Files","text":"File Purpose main.go Demonstrates the schema deduplication workflow specs/users-api.yaml User service spec with <code>User</code> and <code>UserError</code> schemas specs/products-api.yaml Product service spec with <code>Product</code> and <code>ProductError</code> schemas"},{"location":"examples/workflows/schema-deduplication/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/schema-deduplication/#deduplication-strategies","title":"Deduplication Strategies","text":"Strategy When to Use <code>deduplicate-equivalent</code> Same-named schemas colliding (e.g., both have <code>Error</code>) <code>semantic-deduplication</code> Different-named but identical schemas (e.g., <code>UserError</code> vs <code>ProductError</code>)"},{"location":"examples/workflows/schema-deduplication/#how-deduplicate-equivalent-works","title":"How <code>deduplicate-equivalent</code> Works","text":"<p>This is a collision strategy (<code>SchemaStrategy</code>) that triggers when two schemas have the same name:</p> <ol> <li>When <code>UserAPI</code> and <code>ProductAPI</code> both define <code>Error</code></li> <li>The joiner compares their structure using <code>EquivalenceMode</code> (shallow or deep)</li> <li>If equivalent -&gt; keeps one, discards the duplicate</li> <li>If different -&gt; fails with collision error</li> </ol> <pre><code>config.SchemaStrategy = joiner.StrategyDeduplicateEquivalent\nconfig.EquivalenceMode = \"deep\"\n</code></pre>"},{"location":"examples/workflows/schema-deduplication/#how-semantic-deduplication-works","title":"How Semantic Deduplication Works","text":"<p>This is a post-merge optimization that finds schemas with different names but identical structure:</p> <ol> <li>After merging, scans all schemas</li> <li>Groups schemas by structural equivalence</li> <li>Selects canonical name (alphabetically first)</li> <li>Removes duplicates and rewrites all <code>$ref</code> pointers</li> </ol> <pre><code>config.SemanticDeduplication = true\n</code></pre>"},{"location":"examples/workflows/schema-deduplication/#equivalence-modes","title":"Equivalence Modes","text":"Mode Comparison Depth <code>none</code> Disabled (no equivalence checking) <code>shallow</code> Top-level properties only <code>deep</code> Full recursive comparison including nested schemas"},{"location":"examples/workflows/schema-deduplication/#use-cases","title":"Use Cases","text":"<ul> <li>Shared error schemas - Multiple microservices define identical error responses</li> <li>Common data types - Teams independently define equivalent Address, Money, or Timestamp schemas</li> <li>API consolidation - Merging specs that evolved separately but converged on structure</li> <li>Spec cleanup - Reducing schema bloat in merged specifications</li> </ul>"},{"location":"examples/workflows/schema-deduplication/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-API Merge - Basic multi-spec merging workflow</li> <li>Breaking Change Detection - Compare merged versions</li> <li>Joiner Deep Dive - Complete joiner documentation</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/schema-renaming/","title":"Schema Renaming","text":"<p>Demonstrates schema renaming strategies for resolving component collisions while preserving both schemas.</p>"},{"location":"examples/workflows/schema-renaming/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to preserve both conflicting schemas using rename strategies</li> <li>Using <code>rename-left</code> vs <code>rename-right</code> strategies</li> <li>Customizing renamed schema names with Go templates</li> <li>Applying namespace prefixes for consistent naming conventions</li> </ul>"},{"location":"examples/workflows/schema-renaming/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/schema-renaming/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/schema-renaming\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/schema-renaming/#expected-output","title":"Expected Output","text":"<pre><code>Schema Renaming Strategies\n==========================\n\nScenario: Both APIs legitimately need different 'Account' schemas\n  - billing-api.yaml: Account {accountId, balance, creditLimit, paymentTerms}\n  - crm-api.yaml: Account {accountId, companyName, industry, employeeCount}\n\nUnlike accept-left/right, we need BOTH schemas preserved!\n\n[1/4] Strategy: rename-right\n---------------------------------------------\n  Result: Success\n  Schemas: [Account Account_crm_api Contact Invoice]\n\n  How it works:\n    - billing-api's Account -&gt; Account (kept original name)\n    - crm-api's Account -&gt; Account_crm_api (renamed)\n\n  All $refs in crm-api paths now point to Account_crm_api\n\n  Schema properties comparison:\n    Account_crm_api: [accountId annualRevenue companyName employeeCount industry]\n    Account: [accountId balance creditLimit lastPaymentDate paymentTerms]\n\n[2/4] Strategy: rename-left\n---------------------------------------------\n  Result: Success\n  Schemas: [Account Account_billing_api Contact Invoice]\n\n  How it works:\n    - billing-api's Account -&gt; Account_billing_api (renamed)\n    - crm-api's Account -&gt; Account (kept original name)\n\n  All $refs in billing-api paths now point to Account_billing_api\n\n[3/4] Custom rename template\n---------------------------------------------\n  Result: Success\n  Schemas: [Account Contact CrmApiAccount Invoice]\n\n  Template: {{.Source | pascalCase}}{{.Name}}\n\n[4/4] Namespace prefixes\n---------------------------------------------\n  Result: Success\n  Schemas: [Account CRM_Account Contact Invoice]\n\n  Configuration:\n    NamespacePrefix: billing-api.yaml -&gt; Billing\n                     crm-api.yaml -&gt; CRM\n    AlwaysApplyPrefix: false (only on collision)\n\n===============================================\nKey Takeaway: Rename strategies preserve BOTH schemas.\nThe joiner automatically rewrites all $ref pointers!\n</code></pre>"},{"location":"examples/workflows/schema-renaming/#files","title":"Files","text":"File Purpose main.go Demonstrates all schema renaming strategies specs/billing-api.yaml Billing API with Account schema (balance, creditLimit) specs/crm-api.yaml CRM API with Account schema (companyName, industry)"},{"location":"examples/workflows/schema-renaming/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/schema-renaming/#rename-left-vs-rename-right","title":"rename-left vs rename-right","text":"<p>Unlike <code>accept-left</code> and <code>accept-right</code> which discard one schema, the rename strategies preserve both schemas by renaming the colliding one:</p> Strategy Left Schema Right Schema <code>rename-right</code> Keeps original name Renamed using template <code>rename-left</code> Renamed using template Keeps original name <p>The joiner automatically rewrites all <code>$ref</code> pointers to use the new schema name.</p>"},{"location":"examples/workflows/schema-renaming/#renametemplate-syntax","title":"RenameTemplate Syntax","text":"<p>The <code>RenameTemplate</code> config option uses Go text/template syntax:</p> <pre><code>config.RenameTemplate = \"{{.Source | pascalCase}}{{.Name}}\"\n</code></pre> <p>Available Variables:</p> Variable Description Example <code>{{.Name}}</code> Original schema name <code>Account</code> <code>{{.Source}}</code> Source filename (no extension) <code>crm_api</code> <code>{{.Index}}</code> Document index (0-based) <code>1</code> <p>Available Functions:</p> Function Output Example Input -&gt; Output <code>pascalCase</code> PascalCase <code>crm_api</code> -&gt; <code>CrmApi</code> <code>camelCase</code> camelCase <code>crm_api</code> -&gt; <code>crmApi</code> <code>snakeCase</code> snake_case <code>CrmApi</code> -&gt; <code>crm_api</code> <code>kebabCase</code> kebab-case <code>CrmApi</code> -&gt; <code>crm-api</code> <p>Default Template: <code>{{.Name}}_{{.Source}}</code></p>"},{"location":"examples/workflows/schema-renaming/#namespaceprefix-configuration","title":"NamespacePrefix Configuration","text":"<p>For explicit control over renamed schema names, use <code>NamespacePrefix</code>:</p> <pre><code>config.NamespacePrefix = map[string]string{\n    \"/path/to/billing-api.yaml\": \"Billing\",\n    \"/path/to/crm-api.yaml\":     \"CRM\",\n}\n</code></pre> <p>When a collision occurs, the schema from the mapped source gets the prefix: <code>Account</code> -&gt; <code>CRM_Account</code>.</p> <p>Note: Keys must be the full file paths as passed to the joiner, not just basenames.</p>"},{"location":"examples/workflows/schema-renaming/#alwaysapplyprefix-option","title":"AlwaysApplyPrefix Option","text":"Value Behavior <code>false</code> (default) Only apply prefix on collision <code>true</code> Prefix ALL schemas from mapped sources <p>Setting <code>AlwaysApplyPrefix = true</code> is useful for:</p> <ul> <li>Consistent naming across large merges</li> <li>Avoiding future collisions when APIs evolve</li> <li>Clear provenance of schemas in the merged output</li> </ul>"},{"location":"examples/workflows/schema-renaming/#use-cases","title":"Use Cases","text":"<ul> <li>Merging domain APIs - When different domains legitimately use the same type name (e.g., billing Account vs CRM Account)</li> <li>API versioning - Preserving both v1 and v2 schemas in a unified spec</li> <li>Multi-tenant APIs - Combining tenant-specific schemas with unique prefixes</li> <li>Code generation - Ensuring generated types don't have name conflicts</li> </ul>"},{"location":"examples/workflows/schema-renaming/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-API Merge - Basic merge workflow with collision handling</li> <li>Collision Resolution - Compare accept vs rename strategies</li> <li>Schema Deduplication - Consolidate identical schemas</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/validate-and-fix/","title":"Validate and Fix","text":"<p>Demonstrates automatic fixing of common OpenAPI validation errors using the fixer package.</p>"},{"location":"examples/workflows/validate-and-fix/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to identify validation errors in an OpenAPI specification</li> <li>Using dry-run mode to preview fixes before applying</li> <li>Applying fixes with type inference from naming conventions</li> <li>Selective fix application with <code>WithEnabledFixes()</code></li> </ul>"},{"location":"examples/workflows/validate-and-fix/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/validate-and-fix/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/validate-and-fix\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/validate-and-fix/#expected-output","title":"Expected Output","text":"<pre><code>Validate-and-Fix Workflow\n=========================\n\n[1/5] Parsing specification...\n      Version: 3.0.3\n      Format: yaml\n\n[2/5] Validating (before fix)...\n      Valid: false\n      Errors: 3\n        - Path template references parameter '{taskId}' but it is not declared in parameters\n        - Path template references parameter '{projectId}' but it is not declared in parameters\n        - Path template references parameter '{taskId}' but it is not declared in parameters\n\n[3/5] Previewing fixes (dry-run)...\n      Would apply 3 fix(es):\n        - [missing-path-parameter] Added missing path parameter 'projectId' (type: integer)\n        - [missing-path-parameter] Added missing path parameter 'taskId' (type: integer)\n        - [missing-path-parameter] Added missing path parameter 'taskId' (type: integer)\n\n[4/5] Applying fixes...\n      Applied 4 fix(es)\n\n[5/5] Validating (after fix)...\n      Valid: true\n      Errors: 0\n\n---\nSummary: Applied 4 fixes\n  - [missing-path-parameter] Added missing path parameter 'projectId' (type: integer)\n  - [missing-path-parameter] Added missing path parameter 'taskId' (type: integer)\n  - [missing-path-parameter] Added missing path parameter 'taskId' (type: integer)\n  - [pruned-unused-schema] removed unreferenced schema 'UnusedModel'\n\nSpecification is now valid!\n</code></pre>"},{"location":"examples/workflows/validate-and-fix/#files","title":"Files","text":"File Purpose main.go Demonstrates the complete validate \u2192 fix \u2192 validate workflow specs/invalid.yaml OpenAPI spec with intentional validation issues"},{"location":"examples/workflows/validate-and-fix/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/validate-and-fix/#type-inference","title":"Type Inference","text":"<p>The fixer uses naming conventions to infer parameter types:</p> <ul> <li><code>*Id</code> suffix \u2192 <code>integer</code> type</li> <li><code>*Uuid</code> suffix \u2192 <code>string</code> with <code>uuid</code> format</li> <li>Other parameters \u2192 <code>string</code> type (default)</li> </ul>"},{"location":"examples/workflows/validate-and-fix/#fix-types","title":"Fix Types","text":"Fix Type Description <code>missing-path-parameter</code> Adds parameters declared in path but missing from operation <code>pruned-unused-schema</code> Removes schemas not referenced anywhere in the specification"},{"location":"examples/workflows/validate-and-fix/#dry-run-mode","title":"Dry-Run Mode","text":"<p>Use <code>WithDryRun(true)</code> to preview what fixes would be applied without modifying the document. This is useful for:</p> <ul> <li>CI/CD pipelines that need to report issues</li> <li>Interactive tools that want user confirmation</li> </ul>"},{"location":"examples/workflows/validate-and-fix/#next-steps","title":"Next Steps","text":"<ul> <li>Fixer Deep Dive - Complete fixer documentation</li> <li>Validation Pipeline - Validation with severity reporting</li> <li>Version Conversion - Convert between OAS versions</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/version-conversion/","title":"Version Conversion","text":"<p>Demonstrates converting between OpenAPI specification versions using the converter package.</p>"},{"location":"examples/workflows/version-conversion/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to convert Swagger 2.0 to OpenAPI 3.0.3</li> <li>Understanding conversion issues and their severity levels</li> <li>Key structural changes between OAS 2.0 and 3.x</li> </ul>"},{"location":"examples/workflows/version-conversion/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/version-conversion/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/version-conversion\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/version-conversion/#expected-output","title":"Expected Output","text":"<pre><code>Version Conversion Workflow\n===========================\n\nInput: specs/swagger-v2.yaml\n\n[1/3] Converting OAS 2.0 -&gt; OAS 3.0.3...\n      Source: 2.0\n      Target: 3.0.3\n\n[2/3] Conversion Issues:\n      Critical: 0\n      Warnings: 0\n      Info: 3\n\n      Details:\n        [INFO] (document): host/basePath/schemes converted to servers\n        [INFO] (document): definitions converted to components/schemas\n        [INFO] (document): securityDefinitions converted to components/securitySchemes\n\n[3/3] Key Conversions Applied:\n      - host/basePath/schemes -&gt; servers array\n      - definitions -&gt; components/schemas\n      - consumes/produces -&gt; requestBody/response content\n      - securityDefinitions -&gt; components/securitySchemes\n      - body parameters -&gt; requestBody objects\n\n--- Converted Specification (excerpt) ---\nopenapi: 3.0.3\ninfo:\n  title: Legacy User API\n  version: 1.0.0\n  description: A Swagger 2.0 API to convert to OpenAPI 3.x\nservers:\n  - url: https://api.example.com/v1\n...\n\n---\nConversion completed successfully\n</code></pre>"},{"location":"examples/workflows/version-conversion/#files","title":"Files","text":"File Purpose main.go Demonstrates OAS 2.0 to 3.x conversion workflow specs/swagger-v2.yaml Swagger 2.0 source specification"},{"location":"examples/workflows/version-conversion/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/version-conversion/#severity-levels","title":"Severity Levels","text":"Level Meaning CRITICAL Conversion may have lost essential functionality WARNING Some features may not work as expected INFO Informational note about transformation"},{"location":"examples/workflows/version-conversion/#major-structural-changes","title":"Major Structural Changes","text":"<p>OAS 2.0 \u2192 OAS 3.x:</p> OAS 2.0 OAS 3.x <code>host</code>, <code>basePath</code>, <code>schemes</code> <code>servers</code> array with URL templates <code>definitions</code> <code>components/schemas</code> <code>securityDefinitions</code> <code>components/securitySchemes</code> <code>consumes</code>, <code>produces</code> <code>requestBody.content</code>, <code>response.content</code> <code>body</code> parameter <code>requestBody</code> object"},{"location":"examples/workflows/version-conversion/#bidirectional-conversion","title":"Bidirectional Conversion","text":"<p>The converter supports both directions:</p> <ul> <li>OAS 2.0 \u2192 3.0.x, 3.1.x, 3.2.0</li> <li>OAS 3.x \u2192 2.0 (with potential information loss)</li> </ul>"},{"location":"examples/workflows/version-conversion/#next-steps","title":"Next Steps","text":"<ul> <li>Converter Deep Dive - Complete converter documentation</li> <li>Breaking Change Detection - Compare API versions</li> <li>Multi-API Merge - Merge multiple specifications</li> </ul> <p>Generated for oastools</p>"},{"location":"examples/workflows/version-migration/","title":"Version Migration","text":"<p>Demonstrates OAS 3.1/3.2 version conversions and handling lossy downgrades using the converter package.</p>"},{"location":"examples/workflows/version-migration/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>OAS version differences (3.0 vs 3.1 vs 3.2)</li> <li>Safe upgrades vs lossy downgrades</li> <li>How to detect and handle feature loss</li> <li>Validating converted specifications</li> </ul>"},{"location":"examples/workflows/version-migration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24+</li> </ul>"},{"location":"examples/workflows/version-migration/#quick-start","title":"Quick Start","text":"<pre><code>cd examples/workflows/version-migration\ngo run main.go\n</code></pre>"},{"location":"examples/workflows/version-migration/#expected-output","title":"Expected Output","text":"<pre><code>Version Migration: OAS 3.0, 3.1, and 3.2\n=========================================\n\nOAS Version Features:\n  - 3.0.x: Stable, widely supported\n  - 3.1.x: JSON Schema 2020-12, webhooks, type arrays\n  - 3.2.x: Latest features and refinements\n\n[1/4] Upgrade: OAS 3.0 -&gt; 3.1\n--------------------------------\n  Source: classic-api-30.yaml (OAS 3.0.3)\n  Target: OAS 3.1.0\n\n  [ok] Converted to OAS 3.1.0\n  Conversion issues: 0 critical, 1 warnings, 1 info\n\n  Validating converted spec:\n    [ok] Valid!\n\n[2/4] Upgrade: OAS 3.0 -&gt; 3.2 (latest)\n--------------------------------\n  Source: classic-api-30.yaml (OAS 3.0.3)\n  Target: OAS 3.2.0\n\n  [ok] Converted to OAS 3.2.0\n  ...\n\n[3/4] Downgrade: OAS 3.1 -&gt; 3.0 (potentially lossy)\n--------------------------------\n  Source: modern-api-31.yaml (OAS 3.1.0)\n  Target: OAS 3.0.3\n\n  Source has 1 webhook(s)\n  Source uses JSON Schema dialect: https://json-schema.org/draft/202...\n\n  [ok] Converted to OAS 3.0.3\n  [ok] Preserved: 1 webhook(s)\n  ...\n\n[4/4] Downgrade: OAS 3.1 -&gt; 2.0 (lossy!)\n--------------------------------\n  Source: modern-api-31.yaml (OAS 3.1.0)\n  Target: OAS 2.0\n\n  Source has 1 webhook(s)\n  Source uses JSON Schema dialect: https://json-schema.org/draft/2020-12...\n\n  [ok] Converted to OAS 2.0\n  Conversion issues: 1 critical, 0 warnings, 1 info\n  Critical issues (features lost):\n      [!] webhooks: Webhooks are OAS 3.1+ only and cannot be conver...\n  [!] LOST: 1 webhook(s) (not supported in OAS 2.0)\n  [!] LOST: components structure (converted to definitions)\n  ...\n</code></pre>"},{"location":"examples/workflows/version-migration/#files","title":"Files","text":"File Purpose main.go Demonstrates version upgrades and lossy downgrades specs/modern-api-31.yaml OAS 3.1 spec with webhooks, type arrays, JSON Schema 2020-12 specs/classic-api-30.yaml OAS 3.0.3 spec for upgrade demonstrations"},{"location":"examples/workflows/version-migration/#version-comparison","title":"Version Comparison","text":"Feature OAS 2.0 OAS 3.0 OAS 3.1 OAS 3.2 Webhooks - - Yes Yes Type arrays (<code>[\"string\", \"null\"]</code>) - - Yes Yes JSON Schema 2020-12 - - Yes Yes <code>nullable</code> keyword - Yes Deprecated Deprecated <code>jsonSchemaDialect</code> - - Yes Yes <code>info.summary</code> - - Yes Yes <code>license.identifier</code> - - Yes Yes <code>prefixItems</code> - - Yes Yes <code>contains</code> - - Yes Yes <code>unevaluatedProperties</code> - - Yes Yes <code>contentMediaType</code> - - Yes Yes Links &amp; Callbacks - Yes Yes Yes Components structure - Yes Yes Yes <code>$self</code> document identity - - - Yes"},{"location":"examples/workflows/version-migration/#conversion-paths","title":"Conversion Paths","text":""},{"location":"examples/workflows/version-migration/#safe-upgrades","title":"Safe Upgrades","text":"<p>Upgrades preserve all features and may enable new capabilities:</p> <pre><code>3.0.x -&gt; 3.1.x  (gains webhooks, type arrays, JSON Schema keywords)\n3.0.x -&gt; 3.2.x  (gains all 3.1 features plus 3.2 additions)\n3.1.x -&gt; 3.2.x  (minor refinements)\n2.0   -&gt; 3.x    (restructures document, enables modern features)\n</code></pre>"},{"location":"examples/workflows/version-migration/#lossy-downgrades","title":"Lossy Downgrades","text":"<p>Downgrades may lose features that don't exist in older versions:</p> Conversion Features Lost 3.1 -&gt; 3.0 Type arrays become single types, some JSON Schema keywords 3.1 -&gt; 2.0 Webhooks, components structure, links, callbacks 3.0 -&gt; 2.0 Links, callbacks, components structure, servers array"},{"location":"examples/workflows/version-migration/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/workflows/version-migration/#conversionresultissues","title":"ConversionResult.Issues","text":"<p>The converter tracks all issues by severity:</p> Severity Meaning Example <code>Critical</code> Feature cannot be converted (data loss) Webhooks dropped in 2.0 downgrade <code>Warning</code> Best-effort transformation applied Multiple servers reduced to one <code>Info</code> Informational note Version string updated"},{"location":"examples/workflows/version-migration/#checking-for-feature-loss","title":"Checking for Feature Loss","text":"<pre><code>result, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"modern-api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n)\n\n// Check for critical issues (lossy conversions)\nif result.HasCriticalIssues() {\n    for _, issue := range result.Issues {\n        if issue.Severity == converter.SeverityCritical {\n            fmt.Printf(\"Feature lost: %s - %s\\n\", issue.Path, issue.Message)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/workflows/version-migration/#always-validate-after-conversion","title":"Always Validate After Conversion","text":"<pre><code>// Convert\nconvResult, _ := converter.ConvertWithOptions(...)\n\n// Validate the result\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*convResult.ToParseResult())\n\nif !valResult.Valid {\n    // Handle validation errors\n}\n</code></pre>"},{"location":"examples/workflows/version-migration/#use-cases","title":"Use Cases","text":""},{"location":"examples/workflows/version-migration/#tool-compatibility","title":"Tool Compatibility","text":"<p>Convert modern specs to older versions for tools that don't support 3.1+:</p> <pre><code>// Convert 3.1 to 3.0 for older code generators\nresult, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"modern-api.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n</code></pre>"},{"location":"examples/workflows/version-migration/#legacy-system-support","title":"Legacy System Support","text":"<p>Generate OAS 2.0 for systems that only support Swagger:</p> <pre><code>// Note: Check for critical issues - webhooks will be lost!\nresult, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n)\n\nif result.HasCriticalIssues() {\n    log.Println(\"Warning: Some features were lost in conversion\")\n}\n</code></pre>"},{"location":"examples/workflows/version-migration/#spec-modernization","title":"Spec Modernization","text":"<p>Upgrade older specs to gain new features:</p> <pre><code>// Upgrade to 3.1 for webhooks and JSON Schema 2020-12\nresult, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"legacy-api.yaml\"),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\n</code></pre>"},{"location":"examples/workflows/version-migration/#next-steps","title":"Next Steps","text":"<ul> <li>Version Conversion - OAS 2.0 to 3.0 conversion basics</li> <li>Breaking Change Detection - Compare API versions</li> <li>Validate and Fix - Auto-fix validation errors</li> </ul> <p>Generated for oastools</p>"},{"location":"packages/builder/","title":"Builder","text":""},{"location":"packages/builder/#builder-package-deep-dive","title":"Builder Package Deep Dive","text":""},{"location":"packages/builder/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Building Runnable HTTP Servers</li> <li>Configuration Reference</li> <li>Best Practices</li> </ul> <p>The <code>builder</code> package enables programmatic construction of OpenAPI Specification documents using a fluent Go API. Instead of writing YAML or JSON by hand, you define your API specification in Go code with automatic reflection-based schema generation from your Go types.</p>"},{"location":"packages/builder/#overview","title":"Overview","text":"<p>The builder transforms Go types into OpenAPI schemas automatically. When you pass a Go struct to define a response body or parameter, the builder inspects the type via reflection and generates the appropriate JSON Schema representation. This approach keeps your API specification synchronized with your actual data types, reducing drift between documentation and implementation.</p> <p>The builder supports both OAS 2.0 (Swagger) and OAS 3.x (3.0.0 through 3.2.0), with automatic adjustment of <code>$ref</code> paths and component locations based on the target version.</p>"},{"location":"packages/builder/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/builder/#reflection-based-schema-generation","title":"Reflection-Based Schema Generation","text":"<p>The core feature of the builder is automatic schema generation from Go types. Rather than manually defining JSON Schema, you pass Go values and the builder introspects their structure.</p> <p>Type Mappings:</p> Go Type OpenAPI Type Format <code>string</code> string - <code>int</code>, <code>int32</code> integer int32 <code>int64</code> integer int64 <code>float32</code> number float <code>float64</code> number double <code>bool</code> boolean - <code>[]T</code> array items from T <code>map[string]T</code> object additionalProperties from T <code>struct</code> object properties from fields <code>*T</code> schema of T nullable <code>time.Time</code> string date-time <p>Nested structures are recursively processed, and named types are registered as reusable schemas in <code>components/schemas</code> (OAS 3.x) or <code>definitions</code> (OAS 2.0).</p>"},{"location":"packages/builder/#schema-naming","title":"Schema Naming","text":"<p>By default, schemas are named using the Go convention of <code>package.TypeName</code>. For example, a <code>User</code> struct in the <code>models</code> package becomes the schema <code>models.User</code>. This naming ensures uniqueness when multiple packages define types with the same name.</p> <p>The builder provides extensible naming strategies for cases where you need different conventions, such as PascalCase for JSON Schema compatibility or custom templates for specific naming requirements.</p>"},{"location":"packages/builder/#version-aware-reference-paths","title":"Version-Aware Reference Paths","text":"<p>The builder automatically adjusts <code>$ref</code> paths based on the OAS version. When you register a type, references are generated correctly for the target version.</p> <p>OAS 3.x references:</p> <pre><code>$ref: \"#/components/schemas/models.User\"\n$ref: \"#/components/parameters/LimitParam\"\n$ref: \"#/components/responses/ErrorResponse\"\n</code></pre> <p>OAS 2.0 references:</p> <pre><code>$ref: \"#/definitions/models.User\"\n$ref: \"#/parameters/LimitParam\"\n$ref: \"#/responses/ErrorResponse\"\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/builder/#api-styles","title":"API Styles","text":""},{"location":"packages/builder/#fluent-builder-api","title":"Fluent Builder API","text":"<p>The builder uses method chaining for a fluent construction experience:</p> <pre><code>spec := builder.New(parser.OASVersion320).\n    SetTitle(\"My API\").\n    SetVersion(\"1.0.0\").\n    SetDescription(\"A comprehensive API example\")\n\nspec.AddOperation(http.MethodGet, \"/users\",\n    builder.WithOperationID(\"listUsers\"),\n    builder.WithResponse(http.StatusOK, []User{}),\n)\n\ndoc, err := spec.BuildOAS3()\n</code></pre>"},{"location":"packages/builder/#functional-options-for-operations","title":"Functional Options for Operations","text":"<p>Operations accept functional options that configure various aspects:</p> <pre><code>spec.AddOperation(http.MethodPost, \"/users\",\n    builder.WithOperationID(\"createUser\"),\n    builder.WithSummary(\"Create a new user\"),\n    builder.WithDescription(\"Creates a user with the provided details\"),\n    builder.WithTags(\"users\", \"admin\"),\n    builder.WithRequestBody(\"application/json\", CreateUserRequest{}),\n    builder.WithResponse(http.StatusCreated, User{}),\n    builder.WithResponse(http.StatusBadRequest, ErrorResponse{}),\n)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/builder/#practical-examples","title":"Practical Examples","text":""},{"location":"packages/builder/#building-a-simple-api-specification","title":"Building a Simple API Specification","text":"<p>See also: Complete API example on pkg.go.dev</p> <p>The most straightforward use case constructs an API from Go types:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// Define your domain types\ntype User struct {\n    ID        int64  `json:\"id\"`\n    Name      string `json:\"name\"`\n    Email     string `json:\"email\" oas:\"format=email\"`\n    CreatedAt string `json:\"created_at\" oas:\"format=date-time\"`\n}\n\ntype CreateUserRequest struct {\n    Name  string `json:\"name\"`\n    Email string `json:\"email\" oas:\"format=email\"`\n}\n\ntype ErrorResponse struct {\n    Code    int    `json:\"code\"`\n    Message string `json:\"message\"`\n}\n\nfunc main() {\n    // Create a new builder for OAS 3.2.0\n    spec := builder.New(parser.OASVersion320).\n        SetTitle(\"User Management API\").\n        SetVersion(\"1.0.0\").\n        SetDescription(\"API for managing user accounts\")\n\n    // Add a server\n    spec.AddServer(\"https://api.example.com/v1\",\n        builder.WithServerDescription(\"Production server\"))\n    spec.AddServer(\"https://staging-api.example.com/v1\",\n        builder.WithServerDescription(\"Staging server\"))\n\n    // Define operations using Go types\n    spec.AddOperation(http.MethodGet, \"/users\",\n        builder.WithOperationID(\"listUsers\"),\n        builder.WithSummary(\"List all users\"),\n        builder.WithTags(\"users\"),\n        builder.WithQueryParam(\"limit\", int(0), builder.WithParamDescription(\"Maximum results\")),\n        builder.WithQueryParam(\"offset\", int(0), builder.WithParamDescription(\"Pagination offset\")),\n        builder.WithResponse(http.StatusOK, []User{}),\n    )\n\n    spec.AddOperation(http.MethodPost, \"/users\",\n        builder.WithOperationID(\"createUser\"),\n        builder.WithSummary(\"Create a new user\"),\n        builder.WithTags(\"users\"),\n        builder.WithRequestBody(\"application/json\", CreateUserRequest{}),\n        builder.WithResponse(http.StatusCreated, User{}),\n        builder.WithResponse(http.StatusBadRequest, ErrorResponse{}),\n    )\n\n    spec.AddOperation(http.MethodGet, \"/users/{userId}\",\n        builder.WithOperationID(\"getUser\"),\n        builder.WithSummary(\"Get user by ID\"),\n        builder.WithTags(\"users\"),\n        builder.WithPathParam(\"userId\", int64(0)),\n        builder.WithResponse(http.StatusOK, User{}),\n        builder.WithResponse(http.StatusNotFound, ErrorResponse{}),\n    )\n\n    // Build the OAS 3 document\n    doc, err := spec.BuildOAS3()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Write to file\n    if err := spec.WriteFile(\"openapi.yaml\"); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Generated API spec with %d paths\\n\", len(doc.Paths))\n    fmt.Printf(\"Registered schemas: %d\\n\", len(doc.Components.Schemas))\n}\n</code></pre> <p>Generated Output (openapi.yaml):</p> <pre><code>openapi: 3.2.0\ninfo:\n  title: User Management API\n  version: 1.0.0\n  description: API for managing user accounts\nservers:\n  - url: https://api.example.com/v1\n    description: Production server\n  - url: https://staging-api.example.com/v1\n    description: Staging server\npaths:\n  /users:\n    get:\n      operationId: listUsers\n      summary: List all users\n      tags:\n        - users\n      parameters:\n        - name: limit\n          in: query\n          description: Maximum results\n          schema:\n            type: integer\n            format: int32\n        - name: offset\n          in: query\n          description: Pagination offset\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/main.User'\n    post:\n      operationId: createUser\n      summary: Create a new user\n      tags:\n        - users\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/main.CreateUserRequest'\n      responses:\n        '201':\n          description: Created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/main.User'\n        '400':\n          description: Bad Request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/main.ErrorResponse'\n  /users/{userId}:\n    get:\n      operationId: getUser\n      summary: Get user by ID\n      tags:\n        - users\n      parameters:\n        - name: userId\n          in: path\n          required: true\n          schema:\n            type: integer\n            format: int64\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/main.User'\n        '404':\n          description: Not Found\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/main.ErrorResponse'\ncomponents:\n  schemas:\n    main.User:\n      type: object\n      required:\n        - id\n        - name\n        - email\n        - created_at\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n        created_at:\n          type: string\n          format: date-time\n    main.CreateUserRequest:\n      type: object\n      required:\n        - name\n        - email\n      properties:\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n    main.ErrorResponse:\n      type: object\n      required:\n        - code\n        - message\n      properties:\n        code:\n          type: integer\n          format: int32\n        message:\n          type: string\n</code></pre>"},{"location":"packages/builder/#using-oas-tags-for-schema-customization","title":"Using OAS Tags for Schema Customization","text":"<p>The <code>oas</code> struct tag provides fine-grained control over generated schemas:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype Product struct {\n    // Basic field with format\n    ID int64 `json:\"id\" oas:\"format=int64\"`\n\n    // String with constraints\n    Name string `json:\"name\" oas:\"minLength=1,maxLength=100\"`\n\n    // String with pattern validation\n    SKU string `json:\"sku\" oas:\"pattern=^[A-Z]{3}-[0-9]{6}$\"`\n\n    // Number with range constraints\n    Price float64 `json:\"price\" oas:\"minimum=0,maximum=999999.99\"`\n\n    // Integer with constraints\n    Quantity int `json:\"quantity\" oas:\"minimum=0,maximum=10000\"`\n\n    // Enum field\n    Status string `json:\"status\" oas:\"enum=draft|active|archived\"`\n\n    // Deprecated field\n    LegacyCode string `json:\"legacy_code,omitempty\" oas:\"deprecated=true\"`\n\n    // Field with example\n    Description string `json:\"description\" oas:\"example=A high-quality product\"`\n\n    // Field with custom title\n    Category string `json:\"category\" oas:\"title=Product Category\"`\n\n    // Read-only field (not accepted in requests)\n    CreatedAt string `json:\"created_at\" oas:\"readOnly=true,format=date-time\"`\n\n    // Write-only field (not included in responses)\n    AdminNotes string `json:\"admin_notes,omitempty\" oas:\"writeOnly=true\"`\n}\n\nfunc main() {\n    spec := builder.New(parser.OASVersion320).\n        SetTitle(\"Product API\").\n        SetVersion(\"1.0.0\")\n\n    spec.AddOperation(http.MethodPost, \"/products\",\n        builder.WithOperationID(\"createProduct\"),\n        builder.WithRequestBody(\"application/json\", Product{}),\n        builder.WithResponse(http.StatusCreated, Product{}),\n    )\n\n    doc, _ := spec.BuildOAS3()\n    // Schema will include all OAS tag constraints\n}\n</code></pre> <p>Supported OAS Tag Options:</p> Tag Description Example <code>format</code> String/number format <code>format=email</code>, <code>format=int64</code> <code>minimum</code> Minimum numeric value <code>minimum=0</code> <code>maximum</code> Maximum numeric value <code>maximum=100</code> <code>exclusiveMinimum</code> Exclusive minimum <code>exclusiveMinimum=0</code> <code>exclusiveMaximum</code> Exclusive maximum <code>exclusiveMaximum=100</code> <code>minLength</code> Minimum string length <code>minLength=1</code> <code>maxLength</code> Maximum string length <code>maxLength=255</code> <code>pattern</code> Regex pattern <code>pattern=^[A-Z]+$</code> <code>minItems</code> Minimum array items <code>minItems=1</code> <code>maxItems</code> Maximum array items <code>maxItems=100</code> <code>uniqueItems</code> Array uniqueness <code>uniqueItems=true</code> <code>enum</code> Enumeration values <code>enum=a\\|b\\|c</code> <code>deprecated</code> Mark as deprecated <code>deprecated=true</code> <code>readOnly</code> Read-only field <code>readOnly=true</code> <code>writeOnly</code> Write-only field <code>writeOnly=true</code> <code>nullable</code> Nullable field <code>nullable=true</code> <code>title</code> Schema title <code>title=User Name</code> <code>example</code> Example value <code>example=john@example.com</code> <p>\u2191 Back to top</p>"},{"location":"packages/builder/#custom-schema-naming-strategies","title":"Custom Schema Naming Strategies","text":"<p>See also: PascalCase example, Template example, Custom function example on pkg.go.dev</p> <p>When the default <code>package.TypeName</code> naming doesn't fit your needs, use custom naming strategies:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype User struct {\n    ID   int64  `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nfunc main() {\n    // PascalCase naming: \"ModelsUser\" instead of \"models.User\"\n    spec := builder.New(parser.OASVersion320,\n        builder.WithSchemaNaming(builder.SchemaNamingPascalCase),\n    ).SetTitle(\"API\").SetVersion(\"1.0.0\")\n\n    spec.AddOperation(http.MethodGet, \"/users\",\n        builder.WithOperationID(\"listUsers\"),\n        builder.WithResponse(http.StatusOK, []User{}),\n    )\n\n    // Schema will be named \"MainUser\" instead of \"main.User\"\n    doc, _ := spec.BuildOAS3()\n}\n</code></pre> <p>Available Naming Strategies:</p> Strategy Example Use Case <code>SchemaNamingDefault</code> <code>models.User</code> Standard Go-style naming <code>SchemaNamingPascalCase</code> <code>ModelsUser</code> JSON Schema compatibility <code>SchemaNamingCamelCase</code> <code>modelsUser</code> JavaScript conventions <code>SchemaNamingSnakeCase</code> <code>models_user</code> Database-style naming <code>SchemaNamingKebabCase</code> <code>models-user</code> URL-friendly naming <code>SchemaNamingTypeOnly</code> <code>User</code> When package uniqueness isn't needed <code>SchemaNamingFullPath</code> <code>github.com_org_models_User</code> Full disambiguation <p>Custom Templates:</p> <p>For complete control, use Go text templates:</p> <pre><code>// Custom separator\nspec := builder.New(parser.OASVersion320,\n    builder.WithSchemaNameTemplate(`{{.Package}}+{{.Type}}`),\n)\n// Result: \"models+User\"\n\n// Uppercase with underscore\nspec = builder.New(parser.OASVersion320,\n    builder.WithSchemaNameTemplate(`{{upper .Package}}_{{upper .Type}}`),\n)\n// Result: \"MODELS_USER\"\n</code></pre> <p>Available Template Functions: <code>pascal</code>, <code>camel</code>, <code>snake</code>, <code>kebab</code>, <code>upper</code>, <code>lower</code>, <code>title</code>, <code>sanitize</code>, <code>trimPrefix</code>, <code>trimSuffix</code>, <code>replace</code>, <code>join</code></p> <p>Custom Naming Function:</p> <p>For maximum flexibility, provide a custom function:</p> <pre><code>spec := builder.New(parser.OASVersion320,\n    builder.WithSchemaNameFunc(func(ctx builder.SchemaNameContext) string {\n        // Custom logic based on package, type, or other metadata\n        if ctx.Package == \"internal\" {\n            return \"Internal\" + ctx.Type\n        }\n        return ctx.Type\n    }),\n)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/builder/#modifying-existing-documents","title":"Modifying Existing Documents","text":"<p>See also: FromDocument example on pkg.go.dev</p> <p>The builder can extend existing OAS documents rather than creating from scratch:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype HealthResponse struct {\n    Status string `json:\"status\"`\n}\n\nfunc main() {\n    // Parse existing document\n    parseResult, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"existing-api.yaml\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    existingDoc, ok := parseResult.OAS3Document()\n    if !ok {\n        log.Fatal(\"Expected OAS 3 document\")\n    }\n\n    // Create builder from existing document\n    spec := builder.FromDocument(existingDoc)\n\n    // Add new endpoints\n    spec.AddOperation(http.MethodGet, \"/health\",\n        builder.WithOperationID(\"healthCheck\"),\n        builder.WithResponse(http.StatusOK, HealthResponse{}),\n    )\n\n    spec.AddOperation(http.MethodGet, \"/ready\",\n        builder.WithOperationID(\"readinessCheck\"),\n        builder.WithResponse(http.StatusOK, HealthResponse{}),\n    )\n\n    // Build updated document\n    doc, err := spec.BuildOAS3()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Original paths are preserved, new paths added\n    log.Printf(\"Total paths: %d\", len(doc.Paths))\n}\n</code></pre>"},{"location":"packages/builder/#building-oas-20-swagger-documents","title":"Building OAS 2.0 (Swagger) Documents","text":"<p>The same API works for Swagger 2.0 with automatic schema placement:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype Pet struct {\n    ID   int64  `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nfunc main() {\n    // Specify OAS 2.0\n    spec := builder.New(parser.OASVersion20).\n        SetTitle(\"Pet Store\").\n        SetVersion(\"1.0.0\")\n\n    spec.AddOperation(http.MethodGet, \"/pets\",\n        builder.WithOperationID(\"listPets\"),\n        builder.WithResponse(http.StatusOK, []Pet{}),\n    )\n\n    // BuildOAS2 returns *parser.OAS2Document\n    doc, err := spec.BuildOAS2()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Schemas are in definitions for OAS 2.0\n    log.Printf(\"Definitions: %d\", len(doc.Definitions))\n\n    // Refs use #/definitions/ path\n    // $ref: \"#/definitions/main.Pet\"\n}\n</code></pre>"},{"location":"packages/builder/#adding-security-schemes","title":"Adding Security Schemes","text":"<p>See also: Security example on pkg.go.dev</p> <p>Define authentication methods for your API:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    spec := builder.New(parser.OASVersion320).\n        SetTitle(\"Secure API\").\n        SetVersion(\"1.0.0\")\n\n    // Add API key security scheme\n    spec.AddSecurityScheme(\"apiKey\", &amp;parser.SecurityScheme{\n        Type: \"apiKey\",\n        In:   \"header\",\n        Name: \"X-API-Key\",\n    })\n\n    // Add Bearer token security scheme\n    spec.AddSecurityScheme(\"bearerAuth\", &amp;parser.SecurityScheme{\n        Type:   \"http\",\n        Scheme: \"bearer\",\n    })\n\n    // Add OAuth2 security scheme\n    spec.AddSecurityScheme(\"oauth2\", &amp;parser.SecurityScheme{\n        Type: \"oauth2\",\n        Flows: &amp;parser.OAuthFlows{\n            ClientCredentials: &amp;parser.OAuthFlow{\n                TokenURL: \"https://auth.example.com/token\",\n                Scopes: map[string]string{\n                    \"read\":  \"Read access\",\n                    \"write\": \"Write access\",\n                },\n            },\n        },\n    })\n\n    // Apply security to specific operation\n    spec.AddOperation(http.MethodGet, \"/protected\",\n        builder.WithOperationID(\"protectedEndpoint\"),\n        builder.WithSecurity([]string{\"bearerAuth\"}),\n        builder.WithResponse(http.StatusOK, struct{}{}),\n    )\n\n    // Or apply global security\n    spec.SetSecurity(\n        parser.SecurityRequirement{\"apiKey\": []string{}},\n    )\n\n    doc, _ := spec.BuildOAS3()\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/builder/#webhooks-oas-31","title":"Webhooks (OAS 3.1+)","text":"<p>For OAS 3.1 and later, add webhook definitions:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype UserEvent struct {\n    EventType string `json:\"event_type\"`\n    UserID    int64  `json:\"user_id\"`\n    Timestamp string `json:\"timestamp\" oas:\"format=date-time\"`\n}\n\nfunc main() {\n    // Use OAS 3.1.0 for webhook support\n    spec := builder.New(parser.OASVersion310).\n        SetTitle(\"Webhook API\").\n        SetVersion(\"1.0.0\")\n\n    // Add webhook\n    spec.AddWebhook(\"userCreated\", http.MethodPost,\n        builder.WithRequestBody(\"application/json\", UserEvent{}),\n        builder.WithResponse(http.StatusOK, struct{}{}),\n    )\n\n    spec.AddWebhook(\"userDeleted\", http.MethodPost,\n        builder.WithRequestBody(\"application/json\", UserEvent{}),\n        builder.WithResponse(http.StatusOK, struct{}{}),\n    )\n\n    doc, _ := spec.BuildOAS3()\n    // doc.Webhooks will contain the webhook definitions\n}\n</code></pre>"},{"location":"packages/builder/#semantic-schema-deduplication","title":"Semantic Schema Deduplication","text":"<p>See also: Deduplication example on pkg.go.dev</p> <p>When building complex APIs, you might create equivalent schemas through different paths. Enable deduplication to consolidate them:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// These two types are structurally identical\ntype Address struct {\n    Street string `json:\"street\"`\n    City   string `json:\"city\"`\n    Zip    string `json:\"zip\"`\n}\n\ntype ShippingAddress struct {\n    Street string `json:\"street\"`\n    City   string `json:\"city\"`\n    Zip    string `json:\"zip\"`\n}\n\nfunc main() {\n    spec := builder.New(parser.OASVersion320,\n        builder.WithSemanticDeduplication(true),\n    ).SetTitle(\"API\").SetVersion(\"1.0.0\")\n\n    // Both types get registered\n    spec.AddOperation(http.MethodPost, \"/users\",\n        builder.WithOperationID(\"createUser\"),\n        builder.WithRequestBody(\"application/json\", struct {\n            HomeAddress Address `json:\"home_address\"`\n        }{}),\n        builder.WithResponse(http.StatusOK, struct{}{}),\n    )\n\n    spec.AddOperation(http.MethodPost, \"/orders\",\n        builder.WithOperationID(\"createOrder\"),\n        builder.WithRequestBody(\"application/json\", struct {\n            ShipTo ShippingAddress `json:\"ship_to\"`\n        }{}),\n        builder.WithResponse(http.StatusOK, struct{}{}),\n    )\n\n    doc, _ := spec.BuildOAS3()\n\n    // With deduplication enabled, Address and ShippingAddress\n    // are consolidated into a single schema (Address, alphabetically first)\n    // All references are rewritten automatically\n}\n</code></pre>"},{"location":"packages/builder/#registering-types-explicitly","title":"Registering Types Explicitly","text":"<p>When you need to register a schema without using it in an operation:</p> <pre><code>package main\n\nimport (\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype Pagination struct {\n    Page     int `json:\"page\"`\n    PageSize int `json:\"page_size\"`\n    Total    int `json:\"total\"`\n}\n\nfunc main() {\n    spec := builder.New(parser.OASVersion320).\n        SetTitle(\"API\").\n        SetVersion(\"1.0.0\")\n\n    // Register type explicitly\n    spec.RegisterType(Pagination{})\n\n    // Or register with a custom name\n    spec.RegisterTypeAs(\"PaginationInfo\", Pagination{})\n\n    doc, _ := spec.BuildOAS3()\n    // Both schemas are available in components/schemas\n}\n</code></pre>"},{"location":"packages/builder/#integration-with-validator","title":"Integration with Validator","text":"<p>Validate built documents before using them:</p> <pre><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/validator\"\n)\n\ntype User struct {\n    ID   int64  `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nfunc main() {\n    spec := builder.New(parser.OASVersion320).\n        SetTitle(\"API\").\n        SetVersion(\"1.0.0\")\n\n    spec.AddOperation(http.MethodGet, \"/users\",\n        builder.WithOperationID(\"listUsers\"),\n        builder.WithResponse(http.StatusOK, []User{}),\n    )\n\n    // Build a ParseResult for validation\n    parseResult, err := spec.BuildResult()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Validate the built document\n    valResult, err := validator.ValidateWithOptions(\n        validator.WithParsed(*parseResult),\n        validator.WithIncludeWarnings(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if !valResult.Valid {\n        log.Printf(\"Validation errors: %d\", valResult.ErrorCount)\n        for _, e := range valResult.Errors {\n            log.Printf(\"  %s: %s\", e.Path, e.Message)\n        }\n    } else {\n        log.Println(\"Document is valid\")\n    }\n}\n</code></pre>"},{"location":"packages/builder/#building-runnable-http-servers","title":"Building Runnable HTTP Servers","text":"<p>See also: ServerBuilder example, CRUD example, Testing example on pkg.go.dev</p> <p>The <code>ServerBuilder</code> extends <code>Builder</code> to create a complete HTTP server from your OpenAPI specification. Instead of just generating the spec, you can define handlers and build a production-ready <code>http.Handler</code>:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/builder\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\ntype Pet struct {\n    ID   int64  `json:\"id\"`\n    Name string `json:\"name\"`\n}\n\nfunc main() {\n    // Create a ServerBuilder (extends Builder with server capabilities)\n    srv := builder.NewServerBuilder(parser.OASVersion320).\n        SetTitle(\"Pet Store API\").\n        SetVersion(\"1.0.0\")\n\n    // Define operations (same API as Builder)\n    srv.AddOperation(http.MethodGet, \"/pets\",\n        builder.WithOperationID(\"listPets\"),\n        builder.WithResponse(http.StatusOK, []Pet{}),\n    )\n\n    srv.AddOperation(http.MethodPost, \"/pets\",\n        builder.WithOperationID(\"createPet\"),\n        builder.WithRequestBody(\"application/json\", Pet{}),\n        builder.WithResponse(http.StatusCreated, Pet{}),\n    )\n\n    srv.AddOperation(http.MethodGet, \"/pets/{petId}\",\n        builder.WithOperationID(\"getPet\"),\n        builder.WithPathParam(\"petId\", int64(0)),\n        builder.WithResponse(http.StatusOK, Pet{}),\n    )\n\n    // Register handlers for each operation using method + path\n    srv.Handle(http.MethodGet, \"/pets\", func(_ context.Context, _ *builder.Request) builder.Response {\n        pets := []Pet{{ID: 1, Name: \"Fluffy\"}, {ID: 2, Name: \"Buddy\"}}\n        return builder.JSON(http.StatusOK, pets)\n    })\n\n    srv.Handle(http.MethodPost, \"/pets\", func(_ context.Context, req *builder.Request) builder.Response {\n        // req.Body contains the parsed request body\n        return builder.JSON(http.StatusCreated, req.Body)\n    })\n\n    srv.Handle(http.MethodGet, \"/pets/{petId}\", func(_ context.Context, req *builder.Request) builder.Response {\n        // req.PathParams contains typed path parameters\n        petID := req.PathParams[\"petId\"]\n        return builder.JSON(http.StatusOK, Pet{ID: petID.(int64), Name: \"Fluffy\"})\n    })\n\n    // Build the server\n    result, err := srv.BuildServer()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // result.Handler is a standard http.Handler\n    // result.Spec contains the generated OpenAPI document\n    // result.Validator is available if validation was enabled\n\n    log.Println(\"Starting server on :8080\")\n    log.Fatal(http.ListenAndServe(\":8080\", result.Handler))\n}\n</code></pre> <p>Response Helpers:</p> <p>The ServerBuilder provides convenience functions for common response patterns:</p> <pre><code>// JSON response\nbuilder.JSON(http.StatusOK, data)\n\n// Error response with message\nbuilder.Error(http.StatusBadRequest, \"invalid request\")\n\n// Error with additional details\nbuilder.ErrorWithDetails(http.StatusBadRequest, \"validation failed\", map[string]any{\n    \"field\": \"email\",\n    \"error\": \"invalid format\",\n})\n\n// 204 No Content\nbuilder.NoContent()\n\n// Redirect\nbuilder.Redirect(http.StatusFound, \"/new-location\")\n\n// Stream binary data\nbuilder.Stream(http.StatusOK, \"application/octet-stream\", reader)\n\n// Complex responses with ResponseBuilder\nbuilder.NewResponse(http.StatusOK).\n    Header(\"X-Request-ID\", \"12345\").\n    Header(\"Cache-Control\", \"no-store\").\n    JSON(data)\n</code></pre> <p>Middleware:</p> <p>Add middleware for cross-cutting concerns:</p> <pre><code>srv := builder.NewServerBuilder(parser.OASVersion320)\n\n// Add logging middleware\nsrv.Use(func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"%s %s\", r.Method, r.URL.Path)\n        next.ServeHTTP(w, r)\n    })\n})\n\n// Add CORS middleware\nsrv.Use(func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n        next.ServeHTTP(w, r)\n    })\n})\n</code></pre> <p>Middleware is applied in order: first added = outermost (executes first on request).</p> <p>Request Validation:</p> <p>Enable automatic request validation against the OpenAPI specification:</p> <pre><code>srv := builder.NewServerBuilder(parser.OASVersion320,\n    builder.WithValidationConfig(builder.ValidationConfig{\n        IncludeRequestValidation: true,  // Validate incoming requests\n        StrictMode:               false, // Treat warnings as errors\n    }),\n)\n</code></pre> <p>Invalid requests are rejected before reaching your handlers, ensuring your handlers receive only valid data.</p> <p>Testing Utilities:</p> <p>The package provides testing helpers for writing handler tests without starting a real server:</p> <pre><code>func TestListPets(t *testing.T) {\n    srv := builder.NewServerBuilder(parser.OASVersion320, builder.WithoutValidation())\n\n    srv.AddOperation(http.MethodGet, \"/pets\",\n        builder.WithOperationID(\"listPets\"),\n        builder.WithResponse(http.StatusOK, []Pet{}),\n    )\n\n    srv.Handle(http.MethodGet, \"/pets\", listPetsHandler)\n\n    result := srv.MustBuildServer()\n    test := builder.NewServerTest(result)\n\n    // GetJSON makes a GET request and decodes the JSON response\n    var pets []Pet\n    rec, err := test.GetJSON(\"/pets\", &amp;pets)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    if rec.Code != http.StatusOK {\n        t.Errorf(\"Expected 200, got %d\", rec.Code)\n    }\n\n    if len(pets) == 0 {\n        t.Error(\"Expected pets\")\n    }\n}\n</code></pre> <p>Available test methods:</p> <ul> <li><code>GetJSON(path, target)</code> - GET with JSON response</li> <li><code>PostJSON(path, body, target)</code> - POST JSON with response</li> <li><code>PutJSON(path, body, target)</code> - PUT JSON with response</li> <li><code>Delete(path)</code> - DELETE request</li> <li><code>Request(method, path)</code> - Create a TestRequest for custom requests</li> </ul> <p>Converting Builder to ServerBuilder:</p> <p>If you have an existing <code>Builder</code>, convert it to a <code>ServerBuilder</code>:</p> <pre><code>// Create specification with Builder\nspec := builder.New(parser.OASVersion320).\n    SetTitle(\"My API\").\n    SetVersion(\"1.0.0\")\n\nspec.AddOperation(http.MethodGet, \"/status\",\n    builder.WithOperationID(\"getStatus\"),\n    builder.WithResponse(http.StatusOK, StatusResponse{}),\n)\n\n// Convert to ServerBuilder to add handlers\nsrv := builder.FromBuilder(spec, builder.WithoutValidation())\n\nsrv.Handle(http.MethodGet, \"/status\", statusHandler)\n\nresult := srv.MustBuildServer()\n</code></pre> <p>Configuration Options:</p> Option Description <code>WithoutValidation()</code> Disable request validation <code>WithValidationConfig(cfg)</code> Configure validation behavior <code>WithRecovery()</code> Enable panic recovery middleware <code>WithRequestLogging(fn)</code> Enable request logging with a logger function <code>WithErrorHandler(fn)</code> Custom error handler <code>WithNotFoundHandler(h)</code> Custom 404 handler <code>WithMethodNotAllowedHandler(h)</code> Custom 405 handler <code>WithRouter(strategy)</code> Set the routing strategy <code>WithStdlibRouter()</code> Use net/http with PathMatcherSet for routing (default) <p>\u2191 Back to top</p>"},{"location":"packages/builder/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/builder/#builder-options","title":"Builder Options","text":"Option Description <code>WithSchemaNaming(strategy)</code> Set built-in naming strategy <code>WithSchemaNameTemplate(string)</code> Custom Go template for naming <code>WithSchemaNameFunc(func)</code> Custom naming function <code>WithSemanticDeduplication(bool)</code> Enable schema consolidation"},{"location":"packages/builder/#operation-options","title":"Operation Options","text":"Option Description <code>WithOperationID(string)</code> Set operation identifier <code>WithSummary(string)</code> Brief operation description <code>WithDescription(string)</code> Detailed description <code>WithTags(...string)</code> Categorization tags <code>WithDeprecated(bool)</code> Mark as deprecated"},{"location":"packages/builder/#parameter-options","title":"Parameter Options","text":"Option Description <code>WithPathParam(name, type)</code> Path parameter <code>WithQueryParam(name, type, ...opts)</code> Query parameter <code>WithHeaderParam(name, type, ...opts)</code> Header parameter <code>WithCookieParam(name, type, ...opts)</code> Cookie parameter <code>WithParamDescription(string)</code> Parameter description <code>WithParamRequired(bool)</code> Required flag <code>WithParamExtension(key, value)</code> Add vendor extension (x-*) <code>WithParamAllowEmptyValue(bool)</code> Allow empty values (OAS 2.0) <code>WithParamCollectionFormat(string)</code> Array serialization: csv, ssv, tsv, pipes, multi (OAS 2.0) <code>WithParamType(string)</code> Override inferred OpenAPI type <code>WithParamFormat(string)</code> Override inferred OpenAPI format <code>WithParamSchema(*parser.Schema)</code> Full schema override (highest precedence)"},{"location":"packages/builder/#body-and-response-options","title":"Body and Response Options","text":"Option Description <code>WithRequestBody(mediaType, type)</code> Request body with schema <code>WithRequestBodyContentTypes([]string, type)</code> Request body with multiple content types <code>WithRequestBodyExtension(key, value)</code> Add vendor extension (x-*) <code>WithResponse(status, type)</code> Response with schema <code>WithResponseContentTypes(status, []string, type)</code> Response with multiple content types <code>WithResponseDescription(string)</code> Response description <code>WithResponseExtension(key, value)</code> Add vendor extension (x-*)"},{"location":"packages/builder/#operation-options_1","title":"Operation Options","text":"Option Description <code>WithOperationExtension(key, value)</code> Add vendor extension (x-*) <code>WithConsumes(...string)</code> Operation consumes MIME types (OAS 2.0) <code>WithProduces(...string)</code> Operation produces MIME types (OAS 2.0)"},{"location":"packages/builder/#security-options","title":"Security Options","text":"Option Description <code>WithSecurity([]string)</code> Operation-level security <code>AddSecurityScheme(name, scheme)</code> Register security scheme <code>SetSecurity(requirements...)</code> Document-level security"},{"location":"packages/builder/#tag-options","title":"Tag Options","text":"Option Description <code>WithTagDescription(desc)</code> Set tag description <code>WithTagExternalDocs(url, desc)</code> Set external documentation URL and description for a tag"},{"location":"packages/builder/#server-options","title":"Server Options","text":"Option Description <code>WithServerDescription(desc)</code> Set server description <code>WithServerVariable(name, default, ...opts)</code> Add a variable to the server"},{"location":"packages/builder/#server-variable-options","title":"Server Variable Options","text":"Option Description <code>WithServerVariableEnum(values...)</code> Set allowed values for a server variable <code>WithServerVariableDescription(desc)</code> Set description for a server variable"},{"location":"packages/builder/#response-detail-options","title":"Response Detail Options","text":"<p>These <code>ResponseOption</code> values configure individual responses when passed to <code>WithResponse</code> or <code>WithResponseRawSchema</code>:</p> Option Description <code>WithResponseContentType(contentType)</code> Set response content type (default: application/json) <code>WithResponseExample(example)</code> Set response example value <code>WithResponseHeader(name, header)</code> Add a header to the response"},{"location":"packages/builder/#response-level-operation-options","title":"Response-Level Operation Options","text":"<p>These <code>OperationOption</code> values add or configure responses at the operation level:</p> Option Description <code>WithResponseRawSchema(statusCode, contentType, schema, ...opts)</code> Add response with pre-built schema <code>WithResponseRef(statusCode, ref)</code> Add a response <code>$ref</code> reference <code>WithDefaultResponse(responseType, ...opts)</code> Set the default response for the operation"},{"location":"packages/builder/#request-body-detail-options","title":"Request Body Detail Options","text":"<p>These options configure request bodies at a finer level than <code>WithRequestBody</code>.</p> Option Description <code>WithRequestBodyRawSchema(contentType, schema, ...opts)</code> Request body with pre-built schema <code>WithRequestDescription(desc)</code> Set request body description <code>WithRequestExample(example)</code> Set request body example value <code>WithRequired(required)</code> Set whether request body is required"},{"location":"packages/builder/#advanced-operation-options","title":"Advanced Operation Options","text":"<p>These options provide lower-level control over operations, including pre-built parameters and handler registration.</p> Option Description <code>WithHandler(handler)</code> Register a typed handler for the operation (ServerBuilder only) <code>WithHandlerFunc(handler)</code> Register an <code>http.HandlerFunc</code> handler (ServerBuilder only) <code>WithNoSecurity()</code> Explicitly mark operation as requiring no security <code>WithParameter(param)</code> Add a pre-built <code>*parser.Parameter</code> to the operation <code>WithParameterRef(ref)</code> Add a parameter <code>$ref</code> reference <code>WithFileParam(name, ...opts)</code> Add a file upload parameter (OAS 2.0: formData; OAS 3.x: multipart) <code>WithFormParam(name, type, ...opts)</code> Add a form parameter (OAS 2.0: formData; OAS 3.x: request body)"},{"location":"packages/builder/#parameter-validation-options","title":"Parameter Validation Options","text":"<p>These <code>ParamOption</code> values set JSON Schema validation constraints on parameters.</p> Option Description <code>WithParamDefault(value)</code> Set default value <code>WithParamDeprecated(bool)</code> Mark parameter as deprecated <code>WithParamEnum(values...)</code> Set allowed values <code>WithParamExample(example)</code> Set example value <code>WithParamMinimum(min)</code> Minimum numeric value <code>WithParamMaximum(max)</code> Maximum numeric value <code>WithParamExclusiveMinimum(bool)</code> Exclusive minimum bound <code>WithParamExclusiveMaximum(bool)</code> Exclusive maximum bound <code>WithParamMinLength(min)</code> Minimum string length <code>WithParamMaxLength(max)</code> Maximum string length <code>WithParamPattern(pattern)</code> Regex pattern for string validation <code>WithParamMinItems(min)</code> Minimum array items <code>WithParamMaxItems(max)</code> Maximum array items <code>WithParamMultipleOf(value)</code> Numeric multiple-of constraint <code>WithParamUniqueItems(bool)</code> Require unique array items"},{"location":"packages/builder/#schema-field-processing","title":"Schema Field Processing","text":"Option Description <code>WithSchemaFieldProcessor(fn)</code> Custom <code>BuilderOption</code> for processing struct field tags during schema generation"},{"location":"packages/builder/#generic-naming-options","title":"Generic Naming Options","text":"<p>These <code>BuilderOption</code> values configure how Go generic types are represented in schema names.</p> Option Description <code>WithGenericNaming(strategy)</code> Set generic type naming strategy <code>WithGenericNamingConfig(config)</code> Fine-grained control over generic naming <code>WithGenericSeparator(sep)</code> Separator for generic type parameters (default: <code>_</code>) <code>WithGenericParamSeparator(sep)</code> Separator between multiple type parameters <code>WithGenericIncludePackage(bool)</code> Include package names in generic type parameters <code>WithGenericApplyBaseCasing(bool)</code> Apply base naming strategy to type parameters <p>\u2191 Back to top</p>"},{"location":"packages/builder/#best-practices","title":"Best Practices","text":"<p>Use Go types as your source of truth. When your API types are Go structs, the builder keeps your specification synchronized with your implementation.</p> <p>Leverage OAS tags for constraints. The <code>oas</code> struct tag lets you express validation rules directly on your types, keeping schema details close to the data definition.</p> <p>Choose a consistent naming strategy and stick with it across your API. This makes the generated specification predictable and easier to consume.</p> <p>Validate built documents before publishing or using them. The validator catches issues that might not be apparent during construction.</p> <p>Use semantic deduplication when building from multiple modules that might define equivalent types independently.</p> <p>Consider OAS 3.1+ for new APIs to take advantage of features like webhooks and full JSON Schema compatibility.</p> <p>Use <code>BuildResult()</code> for integration with other oastools packages, providing a bridge from the builder to validation, conversion, or code generation workflows.</p>"},{"location":"packages/builder/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd27 Parameters example - Path, query, and header parameters</li> <li>\ud83d\udce4 File upload example - Multipart file uploads</li> <li>\ud83d\udcdd Form parameters example - Form data handling</li> <li>\ud83d\udd12 Parameter constraints example - Validation rules</li> <li>\ud83d\udda5\ufe0f ServerBuilder example - Building HTTP servers</li> <li>\ud83e\uddea Server testing example - Testing server handlers</li> </ul>"},{"location":"packages/converter/","title":"Converter","text":""},{"location":"packages/converter/#converter-package-deep-dive","title":"Converter Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the converter in your browser \u2192</p> <p>The <code>converter</code> package provides version conversion for OpenAPI Specification documents, supporting bidirectional conversion between OAS 2.0 and OAS 3.x.</p>"},{"location":"packages/converter/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Conversion Details</li> <li>Version-Specific Considerations</li> <li>Common Pitfalls and Solutions</li> <li>Loss of Fidelity</li> <li>Overlay Integration</li> <li>Configuration Reference</li> <li>Package Chaining</li> <li>Best Practices</li> </ul>"},{"location":"packages/converter/#overview","title":"Overview","text":"<p>The converter performs best-effort conversion with detailed issue tracking. Features converted include servers, schemas, parameters, security schemes, and request/response bodies. It preserves the input file format (JSON or YAML) for output consistency.</p> <p>Supported conversions:</p> <ul> <li>OAS 2.0 (Swagger) -&gt; OAS 3.0.x / 3.1.x</li> <li>OAS 3.0.x / 3.1.x -&gt; OAS 2.0 (Swagger)</li> <li>OAS 3.0.x &lt;-&gt; OAS 3.1.x</li> </ul> <p>Back to top</p>"},{"location":"packages/converter/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/converter/#issue-severity-levels","title":"Issue Severity Levels","text":"Severity Description Info Conversion choices and decisions made Warning Lossy conversions where data may be simplified Critical Features that cannot be converted"},{"location":"packages/converter/#conversion-philosophy","title":"Conversion Philosophy","text":"<p>The converter follows these principles:</p> <ol> <li>Best-effort conversion: Convert as much as possible, track what cannot be converted</li> <li>Transparency: Every conversion decision is recorded as an issue</li> <li>Reversibility awareness: Some conversions are lossy and cannot be reversed</li> <li>Version detection: Automatically detect source version and validate target version</li> </ol>"},{"location":"packages/converter/#what-cannot-convert","title":"What Cannot Convert","text":"<p>OAS 3.x -&gt; OAS 2.0:</p> <ul> <li>Webhooks (3.1+ only)</li> <li>Callbacks</li> <li>Links</li> <li>TRACE HTTP method</li> <li>Cookie parameters</li> <li>Multiple servers (only first is used)</li> <li>Content negotiation complexity</li> <li>Schema keywords: <code>writeOnly</code>, <code>deprecated</code>, <code>if</code>/<code>then</code>/<code>else</code>, <code>prefixItems</code>, <code>contains</code>, <code>propertyNames</code> (warnings emitted)</li> </ul> <p>OAS 2.0 -&gt; OAS 3.x:</p> <ul> <li><code>collectionFormat</code> (may not map perfectly to <code>style</code>/<code>explode</code>)</li> <li><code>allowEmptyValue</code> (deprecated in 3.x)</li> <li>File upload patterns differ significantly</li> </ul> <p>Back to top</p>"},{"location":"packages/converter/#api-styles","title":"API Styles","text":"<p>See also: Basic example, Handling issues example, Complex conversion example on pkg.go.dev</p>"},{"location":"packages/converter/#functional-options-recommended","title":"Functional Options (Recommended)","text":"<pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"packages/converter/#struct-based-reusable","title":"Struct-Based (Reusable)","text":"<pre><code>c := converter.New()\nc.StrictMode = false\n\nresult1, _ := c.Convert(\"api1.yaml\", \"3.0.3\")\nresult2, _ := c.Convert(\"api2.yaml\", \"3.0.3\")\n</code></pre>"},{"location":"packages/converter/#pre-parsed-documents","title":"Pre-Parsed Documents","text":"<pre><code>parseResult, _ := parser.ParseWithOptions(parser.WithFilePath(\"swagger.yaml\"))\n\nresult, _ := converter.ConvertWithOptions(\n    converter.WithParsed(*parseResult),\n    converter.WithTargetVersion(\"3.0.3\"),\n)\n</code></pre> <p>Back to top</p>"},{"location":"packages/converter/#practical-examples","title":"Practical Examples","text":""},{"location":"packages/converter/#oas-20-to-oas-30-conversion","title":"OAS 2.0 to OAS 3.0 Conversion","text":"<p>This is the most common conversion scenario - upgrading legacy Swagger specs:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/erraggy/oastools/converter\"\n)\n\nfunc main() {\n    // Convert Swagger 2.0 to OpenAPI 3.0.3\n    result, err := converter.ConvertWithOptions(\n        converter.WithFilePath(\"swagger.yaml\"),\n        converter.WithTargetVersion(\"3.0.3\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Check for issues\n    fmt.Printf(\"Conversion complete: %d info, %d warnings, %d critical\\n\",\n        result.InfoCount, result.WarningCount, result.CriticalCount)\n\n    // Review any warnings or critical issues\n    for _, issue := range result.Issues {\n        if issue.Severity != converter.SeverityInfo {\n            fmt.Printf(\"[%s] %s: %s\\n\", issue.Severity, issue.Path, issue.Message)\n        }\n    }\n\n    // Write the result using the converted document\n    data, _ := json.MarshalIndent(result.Document, \"\", \"  \")\n    os.WriteFile(\"openapi.yaml\", data, 0644)\n}\n</code></pre> <p>Example Input (swagger.yaml):</p> <pre><code>swagger: \"2.0\"\ninfo:\n  title: Pet Store API\n  version: \"1.0.0\"\nhost: api.petstore.io\nbasePath: /v1\nschemes:\n  - https\nconsumes:\n  - application/json\nproduces:\n  - application/json\npaths:\n  /pets:\n    get:\n      operationId: listPets\n      parameters:\n        - name: limit\n          in: query\n          type: integer\n          format: int32\n      responses:\n        200:\n          description: A list of pets\n          schema:\n            type: array\n            items:\n              $ref: '#/definitions/Pet'\n    post:\n      operationId: createPet\n      parameters:\n        - name: body\n          in: body\n          required: true\n          schema:\n            $ref: '#/definitions/NewPet'\n      responses:\n        201:\n          description: Pet created\n          schema:\n            $ref: '#/definitions/Pet'\ndefinitions:\n  Pet:\n    type: object\n    required:\n      - id\n      - name\n    properties:\n      id:\n        type: integer\n        format: int64\n      name:\n        type: string\n      tag:\n        type: string\n  NewPet:\n    type: object\n    required:\n      - name\n    properties:\n      name:\n        type: string\n      tag:\n        type: string\n</code></pre> <p>Generated Output (openapi.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Pet Store API\n  version: \"1.0.0\"\nservers:\n  - url: https://api.petstore.io/v1\npaths:\n  /pets:\n    get:\n      operationId: listPets\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n            format: int32\n      responses:\n        '200':\n          description: A list of pets\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Pet'\n    post:\n      operationId: createPet\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/NewPet'\n      responses:\n        '201':\n          description: Pet created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Pet'\ncomponents:\n  schemas:\n    Pet:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    NewPet:\n      type: object\n      required:\n        - name\n      properties:\n        name:\n          type: string\n        tag:\n          type: string\n</code></pre>"},{"location":"packages/converter/#oas-30-to-oas-31-conversion","title":"OAS 3.0 to OAS 3.1 Conversion","text":"<p>Upgrading to take advantage of JSON Schema alignment:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"openapi-3.0.yaml\"),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// 3.1 enables nullable via type arrays\n// nullable: true becomes type: [\"string\", \"null\"]\nfmt.Printf(\"Converted to %s\\n\", result.TargetVersion)\n</code></pre> <p>Key Changes in 3.0 -&gt; 3.1:</p> <ul> <li><code>nullable: true</code> is converted to type arrays: <code>type: [\"string\", \"null\"]</code></li> <li>JSON Schema keywords like <code>unevaluatedProperties</code> become available</li> <li>Webhooks support is added</li> </ul>"},{"location":"packages/converter/#oas-3x-to-oas-20-downgrade","title":"OAS 3.x to OAS 2.0 Downgrade","text":"<p>When you need to support older tooling:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"openapi.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n    converter.WithStrictMode(false), // Allow conversion despite critical issues\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// IMPORTANT: Check for critical issues - features that couldn't convert\nif result.HasCriticalIssues() {\n    fmt.Println(\"WARNING: Some features could not be converted:\")\n    for _, issue := range result.Issues {\n        if issue.Severity == converter.SeverityCritical {\n            fmt.Printf(\"  - %s: %s\\n\", issue.Path, issue.Message)\n        }\n    }\n}\n\ndata, _ := yaml.Marshal(result.Document)\nos.WriteFile(\"swagger.yaml\", data, 0644)\n</code></pre>"},{"location":"packages/converter/#handling-conversion-issues","title":"Handling Conversion Issues","text":"<pre><code>result, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"api.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n    converter.WithIncludeInfo(true), // Include info-level issues for full visibility\n)\n\n// Categorize issues by type\nvar schemaIssues, pathIssues, securityIssues []converter.ConversionIssue\n\nfor _, issue := range result.Issues {\n    switch {\n    case strings.Contains(issue.Path, \"schemas\"):\n        schemaIssues = append(schemaIssues, issue)\n    case strings.Contains(issue.Path, \"paths\"):\n        pathIssues = append(pathIssues, issue)\n    case strings.Contains(issue.Path, \"security\"):\n        securityIssues = append(securityIssues, issue)\n    }\n}\n\nfmt.Printf(\"Schema issues: %d\\n\", len(schemaIssues))\nfmt.Printf(\"Path issues: %d\\n\", len(pathIssues))\nfmt.Printf(\"Security issues: %d\\n\", len(securityIssues))\n</code></pre>"},{"location":"packages/converter/#batch-conversion","title":"Batch Conversion","text":"<p>Converting multiple files with consistent settings:</p> <pre><code>c := converter.New()\nc.StrictMode = false\nc.IncludeInfo = false // Only warnings and critical\n\nfiles := []string{\"api1.yaml\", \"api2.yaml\", \"api3.yaml\"}\nvar totalCritical int\n\nfor _, file := range files {\n    result, err := c.Convert(file, \"3.0.3\")\n    if err != nil {\n        log.Printf(\"Failed to convert %s: %v\", file, err)\n        continue\n    }\n\n    totalCritical += result.CriticalCount\n\n    // Write output with matching extension\n    outFile := strings.TrimSuffix(file, \".yaml\") + \"-v3.yaml\"\n    data, _ := yaml.Marshal(result.Document)\n    os.WriteFile(outFile, data, 0644)\n\n    fmt.Printf(\"Converted %s: %d warnings, %d critical\\n\",\n        file, result.WarningCount, result.CriticalCount)\n}\n\nfmt.Printf(\"\\nTotal critical issues across all files: %d\\n\", totalCritical)\n</code></pre> <p>Back to top</p>"},{"location":"packages/converter/#conversion-details","title":"Conversion Details","text":""},{"location":"packages/converter/#oas-20-oas-30","title":"OAS 2.0 -&gt; OAS 3.0","text":"OAS 2.0 OAS 3.0 Notes <code>host</code>, <code>basePath</code>, <code>schemes</code> <code>servers</code> array Combined into URL template <code>definitions</code> <code>components.schemas</code> Reference paths updated <code>parameters</code> <code>components.parameters</code> Reference paths updated <code>responses</code> <code>components.responses</code> Reference paths updated <code>securityDefinitions</code> <code>components.securitySchemes</code> OAuth flows restructured <code>consumes</code> + body param <code>requestBody.content</code> Media types explicit <code>produces</code> + schema <code>response.content</code> Media types explicit <code>type: file</code> Binary string + format <code>type: string, format: binary</code> <code>collectionFormat</code> <code>style</code> + <code>explode</code> Mapping varies by format <p>Server URL Construction:</p> <p>The converter combines OAS 2.0's separate fields into OAS 3.0's servers array:</p> <pre><code># OAS 2.0\nhost: api.example.com\nbasePath: /v1\nschemes:\n  - https\n  - http\n\n# Converts to OAS 3.0\nservers:\n  - url: https://api.example.com/v1\n  - url: http://api.example.com/v1\n</code></pre> <p>Request Body Extraction:</p> <p>Body parameters are extracted and converted to requestBody:</p> <pre><code># OAS 2.0\nparameters:\n  - name: body\n    in: body\n    required: true\n    schema:\n      $ref: '#/definitions/Pet'\n\n# Converts to OAS 3.0\nrequestBody:\n  required: true\n  content:\n    application/json:  # From consumes\n      schema:\n        $ref: '#/components/schemas/Pet'\n</code></pre>"},{"location":"packages/converter/#oas-30-oas-20","title":"OAS 3.0 -&gt; OAS 2.0","text":"OAS 3.0 OAS 2.0 Notes <code>servers[0]</code> <code>host</code>, <code>basePath</code>, <code>schemes</code> Only first server used <code>components.schemas</code> <code>definitions</code> Reference paths updated <code>requestBody</code> <code>consumes</code> + body parameter Single media type selected <code>webhooks</code> Dropped Critical issue logged <code>callbacks</code> Dropped Critical issue logged <code>links</code> Dropped Critical issue logged <code>cookie</code> parameters Dropped Critical issue logged TRACE method Dropped Critical issue logged <code>writeOnly</code>, <code>deprecated</code> Detected Warning issued (no OAS 2.0 equivalent) <code>if</code>/<code>then</code>/<code>else</code> Detected Warning issued (JSON Schema 2020-12) <code>prefixItems</code>, <code>contains</code>, <code>propertyNames</code> Detected Warning issued (JSON Schema 2020-12) <p>Server URL Decomposition:</p> <pre><code># OAS 3.0\nservers:\n  - url: https://api.example.com/v1\n  - url: http://staging.example.com/v2  # Ignored with warning\n\n# Converts to OAS 2.0\nhost: api.example.com\nbasePath: /v1\nschemes:\n  - https\n</code></pre>"},{"location":"packages/converter/#oas-30-oas-31","title":"OAS 3.0 -&gt; OAS 3.1","text":"OAS 3.0 OAS 3.1 Notes <code>nullable: true</code> <code>type: [\"string\", \"null\"]</code> Type becomes array <code>example</code> <code>examples</code> (preferred) Can use either N/A <code>webhooks</code> Now available <code>exclusiveMinimum: true</code> <code>exclusiveMinimum: &lt;value&gt;</code> JSON Schema alignment"},{"location":"packages/converter/#oas-31-oas-30","title":"OAS 3.1 -&gt; OAS 3.0","text":"OAS 3.1 OAS 3.0 Notes <code>type: [\"string\", \"null\"]</code> <code>type: string</code> + <code>nullable: true</code> Array to boolean <code>webhooks</code> Dropped Critical issue logged <code>$comment</code> Dropped JSON Schema keyword <code>unevaluatedProperties</code> Dropped JSON Schema keyword <p>Back to top</p>"},{"location":"packages/converter/#version-specific-considerations","title":"Version-Specific Considerations","text":""},{"location":"packages/converter/#converting-to-oas-30x","title":"Converting to OAS 3.0.x","text":"<p>Choose Your Patch Version:</p> <ul> <li><code>3.0.0</code> - Initial release, use for maximum compatibility</li> <li><code>3.0.1</code> - Clarifications only</li> <li><code>3.0.2</code> - More clarifications</li> <li><code>3.0.3</code> - Recommended - Most stable and widely supported</li> </ul> <p>Watch For:</p> <ul> <li>Security schemes with OAuth2 flows need careful mapping</li> <li>Form data and file uploads have different patterns than 2.0</li> <li>Global consumes/produces become per-operation content types</li> </ul>"},{"location":"packages/converter/#converting-to-oas-31x","title":"Converting to OAS 3.1.x","text":"<p>JSON Schema Alignment: OAS 3.1 fully aligns with JSON Schema Draft 2020-12. This means:</p> <ul> <li><code>type</code> can be an array: <code>type: [\"string\", \"null\"]</code></li> <li><code>nullable</code> is deprecated in favor of type arrays</li> <li>New keywords available: <code>unevaluatedProperties</code>, <code>prefixItems</code>, etc.</li> </ul> <p>Webhooks: OAS 3.1+ introduces webhooks:</p> <pre><code>webhooks:\n  newPet:\n    post:\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Pet'\n      responses:\n        '200':\n          description: Webhook processed\n</code></pre> <p>Choose Your Patch Version:</p> <ul> <li><code>3.1.0</code> - Initial JSON Schema alignment</li> <li><code>3.1.1</code> - Bug fixes and clarifications</li> </ul>"},{"location":"packages/converter/#downgrading-to-oas-20","title":"Downgrading to OAS 2.0","text":"<p>Feature Loss: Expect to lose these OAS 3.x features:</p> <ul> <li>Webhooks (cannot be represented)</li> <li>Callbacks (cannot be represented)</li> <li>Links (cannot be represented)</li> <li>Cookie parameters (not supported)</li> <li>Multiple content types per request/response (simplified)</li> <li>Schema keywords without OAS 2.0 equivalents: <code>writeOnly</code>, <code>deprecated</code>, <code>if</code>/<code>then</code>/<code>else</code>, <code>prefixItems</code>, <code>contains</code>, <code>propertyNames</code> (warnings emitted)</li> </ul> <p>Best Practices:</p> <ol> <li>Always check <code>HasCriticalIssues()</code> after conversion</li> <li>Review all critical issues to understand what was lost</li> <li>Consider if the target tooling truly requires 2.0</li> <li>Document the conversion limitations for API consumers</li> </ol> <p>Back to top</p>"},{"location":"packages/converter/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"packages/converter/#pitfall-1-ignoring-conversion-issues","title":"Pitfall 1: Ignoring Conversion Issues","text":"<p>Problem: Converting without checking the result for issues.</p> <pre><code>// WRONG: Ignoring issues\nresult, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n)\ndata, _ := yaml.Marshal(result.Document)\nos.WriteFile(\"swagger.yaml\", data, 0644)\n// Webhooks, callbacks, links silently dropped!\n</code></pre> <p>Solution: Always check for issues, especially critical ones:</p> <pre><code>// CORRECT: Check issues\nresult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nif result.HasCriticalIssues() {\n    log.Printf(\"WARNING: %d features could not be converted\", result.CriticalCount)\n    for _, issue := range result.Issues {\n        if issue.Severity == converter.SeverityCritical {\n            log.Printf(\"  %s: %s\", issue.Path, issue.Message)\n        }\n    }\n}\n</code></pre>"},{"location":"packages/converter/#pitfall-2-strict-mode-for-downgrades","title":"Pitfall 2: Strict Mode for Downgrades","text":"<p>Problem: Using strict mode when downgrading from 3.x to 2.0.</p> <pre><code>// WRONG: Strict mode fails on any critical issue\nresult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"modern-api.yaml\"), // Has webhooks\n    converter.WithTargetVersion(\"2.0\"),\n    converter.WithStrictMode(true),\n)\n// Error: conversion has critical issues\n</code></pre> <p>Solution: Disable strict mode for downgrades, handle issues manually:</p> <pre><code>// CORRECT: Allow conversion, check issues\nresult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"modern-api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n    converter.WithStrictMode(false),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Now check what was lost\nfor _, issue := range result.Issues {\n    if issue.Severity == converter.SeverityCritical {\n        log.Printf(\"Feature lost: %s\", issue.Message)\n    }\n}\n</code></pre>"},{"location":"packages/converter/#pitfall-3-assuming-reference-paths-are-updated","title":"Pitfall 3: Assuming Reference Paths Are Updated","text":"<p>Problem: Assuming only schema refs are updated.</p> <p>All component references are updated during conversion:</p> <pre><code># OAS 2.0 refs\n$ref: '#/definitions/Pet'\n$ref: '#/parameters/LimitParam'\n$ref: '#/responses/NotFound'\n\n# After conversion to OAS 3.0\n$ref: '#/components/schemas/Pet'\n$ref: '#/components/parameters/LimitParam'\n$ref: '#/components/responses/NotFound'\n</code></pre> <p>The converter handles this automatically, but be aware when processing results.</p>"},{"location":"packages/converter/#pitfall-4-multiple-content-types","title":"Pitfall 4: Multiple Content Types","text":"<p>Problem: OAS 3.x allows multiple content types per operation; OAS 2.0 doesn't.</p> <pre><code># OAS 3.0\nrequestBody:\n  content:\n    application/json:\n      schema: {...}\n    application/xml:\n      schema: {...}\n    text/plain:\n      schema: {...}\n</code></pre> <p>When downgrading to 2.0, only one content type is preserved (typically <code>application/json</code>). A warning issue is logged.</p> <p>Solution: Review warnings and ensure the selected content type is appropriate:</p> <pre><code>for _, issue := range result.Issues {\n    if strings.Contains(issue.Message, \"content type\") {\n        log.Printf(\"Content type selection: %s\", issue.Message)\n    }\n}\n</code></pre>"},{"location":"packages/converter/#pitfall-5-oauth-flow-differences","title":"Pitfall 5: OAuth Flow Differences","text":"<p>Problem: OAuth2 flows have different structures in 2.0 vs 3.0.</p> <pre><code># OAS 2.0\nsecurityDefinitions:\n  oauth2:\n    type: oauth2\n    flow: accessCode  # Single flow\n    authorizationUrl: https://auth.example.com/authorize\n    tokenUrl: https://auth.example.com/token\n    scopes:\n      read: Read access\n\n# OAS 3.0\ncomponents:\n  securitySchemes:\n    oauth2:\n      type: oauth2\n      flows:  # Multiple flows possible\n        authorizationCode:  # Renamed from 'accessCode'\n          authorizationUrl: https://auth.example.com/authorize\n          tokenUrl: https://auth.example.com/token\n          scopes:\n            read: Read access\n</code></pre> <p>The converter handles the flow name mapping (<code>accessCode</code> &lt;-&gt; <code>authorizationCode</code>, etc.).</p> <p>Back to top</p>"},{"location":"packages/converter/#loss-of-fidelity","title":"Loss of Fidelity","text":"<p>Understanding what information is lost during conversion is crucial for making informed decisions.</p>"},{"location":"packages/converter/#oas-3x-oas-20-significant-loss","title":"OAS 3.x -&gt; OAS 2.0 (Significant Loss)","text":"Feature Impact Mitigation Webhooks Complete loss Document externally or use extensions Callbacks Complete loss Document externally Links Complete loss Document relationships externally Cookie params Complete loss Use header params if possible Multiple servers Only first used Document others externally Multiple content types First used Ensure JSON is first if preferred TRACE method Dropped Use custom extension if needed Schema keywords (<code>writeOnly</code>, <code>deprecated</code>, <code>if</code>/<code>then</code>/<code>else</code>, <code>prefixItems</code>, <code>contains</code>, <code>propertyNames</code>) No equivalent Warning issued; document constraints externally"},{"location":"packages/converter/#oas-20-oas-30-minimal-loss","title":"OAS 2.0 -&gt; OAS 3.0 (Minimal Loss)","text":"Feature Impact Mitigation <code>collectionFormat</code> Mapped to style/explode Verify serialization behavior <code>allowEmptyValue</code> Deprecated in 3.x Behavior preserved if set File type Becomes binary string Functionally equivalent"},{"location":"packages/converter/#oas-30-oas-31-semantic-only","title":"OAS 3.0 &lt;-&gt; OAS 3.1 (Semantic Only)","text":"Feature Impact Mitigation <code>nullable</code> vs type array Semantic equivalence Both work in most tools JSON Schema keywords Available in 3.1 only Document requirements"},{"location":"packages/converter/#measuring-fidelity-loss","title":"Measuring Fidelity Loss","text":"<pre><code>result, _ := converter.ConvertWithOptions(\n    converter.WithFilePath(\"api.yaml\"),\n    converter.WithTargetVersion(\"2.0\"),\n    converter.WithIncludeInfo(true),\n)\n\n// Calculate fidelity score\ntotalFeatures := result.InfoCount + result.WarningCount + result.CriticalCount\nif totalFeatures &gt; 0 {\n    fidelity := 1.0 - (float64(result.CriticalCount) / float64(totalFeatures))\n    fmt.Printf(\"Conversion fidelity: %.1f%%\\n\", fidelity*100)\n}\n\n// Categorize losses\nvar losses = map[string]int{}\nfor _, issue := range result.Issues {\n    if issue.Severity == converter.SeverityCritical {\n        losses[issue.Path]++\n    }\n}\nfmt.Printf(\"Features lost by location: %v\\n\", losses)\n</code></pre> <p>Back to top</p>"},{"location":"packages/converter/#overlay-integration","title":"Overlay Integration","text":"<p>Apply transformations before or after conversion:</p> <pre><code>result, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.0.3\"),\n    converter.WithPreConversionOverlayFile(\"fix-v2.yaml\"),   // Fix v2-specific issues\n    converter.WithPostConversionOverlayFile(\"enhance.yaml\"), // Add v3 extensions\n)\n</code></pre> <p>Use Cases:</p>"},{"location":"packages/converter/#pre-conversion-overlays","title":"Pre-Conversion Overlays","text":"<p>Fix issues in the source document before conversion:</p> <pre><code># fix-v2.yaml\noverlay: 1.0.0\ninfo:\n  title: Fix OAS 2.0 Issues\nactions:\n  - target: $.info\n    update:\n      contact:\n        email: api@example.com\n  - target: $.paths./legacy-endpoint\n    remove: true  # Remove deprecated endpoint before conversion\n</code></pre>"},{"location":"packages/converter/#post-conversion-overlays","title":"Post-Conversion Overlays","text":"<p>Add OAS 3.x specific enhancements:</p> <pre><code># enhance.yaml\noverlay: 1.0.0\ninfo:\n  title: Add OAS 3.0 Enhancements\nactions:\n  - target: $.servers\n    update:\n      - url: https://api.example.com/v3\n        description: Production\n      - url: https://staging.example.com/v3\n        description: Staging\n  - target: $.components.schemas.Pet\n    update:\n      x-oai-display-name: Pet Object\n</code></pre> <p>Back to top</p>"},{"location":"packages/converter/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/converter/#functional-options","title":"Functional Options","text":"Option Description <code>WithFilePath(path)</code> Path to specification file <code>WithParsed(result)</code> Pre-parsed ParseResult <code>WithTargetVersion(v)</code> Target OAS version (e.g., \"3.0.3\", \"2.0\") <code>WithStrictMode(bool)</code> Fail on critical issues <code>WithIncludeInfo(bool)</code> Include info-level issues <code>WithPreConversionOverlayFile(path)</code> Overlay to apply before conversion <code>WithPostConversionOverlayFile(path)</code> Overlay to apply after conversion"},{"location":"packages/converter/#converter-fields","title":"Converter Fields","text":"Field Type Default Description <code>StrictMode</code> <code>bool</code> <code>false</code> Return error on critical issues <code>IncludeInfo</code> <code>bool</code> <code>true</code> Include info-level issues in result"},{"location":"packages/converter/#conversionresult-fields","title":"ConversionResult Fields","text":"Field Type Description <code>Document</code> <code>any</code> Converted document (<code>OAS2Document</code> or <code>OAS3Document</code>) <code>TargetVersion</code> <code>string</code> Target OAS version string <code>Issues</code> <code>[]ConversionIssue</code> All conversion issues <code>CriticalCount</code> <code>int</code> Number of critical issues <code>WarningCount</code> <code>int</code> Number of warnings <code>InfoCount</code> <code>int</code> Number of info items <code>SourceFormat</code> <code>SourceFormat</code> Original format (JSON/YAML) <code>ToParseResult()</code> <code>*parser.ParseResult</code> Converts result for package chaining"},{"location":"packages/converter/#conversionissue-fields","title":"ConversionIssue Fields","text":"Field Type Description <code>Severity</code> <code>Severity</code> Severity level (use <code>SeverityInfo</code>, <code>SeverityWarning</code>, <code>SeverityCritical</code> constants) <code>Path</code> <code>string</code> JSON path to affected element <code>Message</code> <code>string</code> Human-readable description <p>Note: <code>Location()</code> is available as a method that returns the path with line/column info when source maps are enabled.</p> <p>Back to top</p>"},{"location":"packages/converter/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>ConversionResult</code> to a <code>parser.ParseResult</code>:</p> <pre><code>// Convert then validate\nconvResult, err := converter.ConvertWithOptions(\n    converter.WithFilePath(\"swagger.yaml\"),\n    converter.WithTargetVersion(\"3.1.0\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*convResult.ToParseResult())\nfmt.Printf(\"Valid: %v\\n\", valResult.Valid)\n\n// Or chain to joiner with other specs\nj := joiner.New(joiner.DefaultConfig())\njoinResult, _ := j.JoinParsed([]parser.ParseResult{\n    *convResult.ToParseResult(),\n    otherSpec,\n})\n\n// Or chain to differ\ndiffResult, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(baseSpec),\n    differ.WithTargetParsed(*convResult.ToParseResult()),\n)\n</code></pre> <p>This enables workflows like: <code>parse -&gt; convert -&gt; validate -&gt; join -&gt; diff</code></p> <p>Note: Conversion issues are converted to string warnings in the resulting ParseResult.</p> <p>Back to top</p>"},{"location":"packages/converter/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always check issues - Use <code>HasCriticalIssues()</code> and review warnings before using converted documents in production.</p> </li> <li> <p>Validate after conversion - The converted document may have structural issues that the converter cannot detect. Run through the validator:</p> </li> </ol> <pre><code>result, _ := converter.ConvertWithOptions(...)\nparseResult := &amp;parser.ParseResult{Document: result.Document, ...}\nvalResult, _ := validator.ValidateWithOptions(validator.WithParsed(*parseResult))\n</code></pre> <ol> <li> <p>Review critical issues - Critical issues indicate features that couldn't be converted. Document these for API consumers.</p> </li> <li> <p>Use overlays for fixes - Pre/post conversion overlays can address gaps that the converter cannot handle automatically.</p> </li> <li> <p>Preserve format - Use <code>result.ToParseResult()</code> to chain with other packages, or marshal <code>result.Document</code> directly to maintain output consistency.</p> </li> <li> <p>Test round-trip conversions - If you need bidirectional compatibility, test converting A-&gt;B-&gt;A and verify the result.</p> </li> <li> <p>Document version requirements - If your API requires 3.1+ features (webhooks, JSON Schema keywords), document this for consumers.</p> </li> <li> <p>Use appropriate target versions:</p> </li> <li>For maximum compatibility: <code>3.0.3</code> or <code>2.0</code></li> <li>For latest features: <code>3.1.0</code> or <code>3.2.0</code></li> <li> <p>For JSON Schema alignment: <code>3.1.0+</code></p> </li> <li> <p>Handle nullable correctly - When converting 3.1 -&gt; 3.0, verify that <code>nullable: true</code> is set where expected.</p> </li> <li> <p>Consider tooling compatibility - Some tools don't support 3.1+ yet. Check your toolchain before upgrading.</p> </li> </ol> <p>Back to top</p>"},{"location":"packages/converter/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>Basic example - Convert OAS 2.0 to OAS 3.x</li> <li>Handling issues example - Process conversion issues by severity</li> <li>Complex conversion example - Advanced conversion scenarios</li> </ul>"},{"location":"packages/differ/","title":"Differ","text":""},{"location":"packages/differ/#differ-package-deep-dive","title":"Differ Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the differ in your browser \u2192</p>"},{"location":"packages/differ/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Schema Comparison Details</li> <li>Extension Field Coverage</li> <li>Source Map Integration</li> <li>Integration with Other Packages</li> <li>Best Practices</li> <li>Configurable Breaking Change Rules</li> <li>DiffResult Structure</li> <li>Package Chaining</li> </ul> <p>The <code>differ</code> package provides OpenAPI specification comparison and breaking change detection. It enables you to identify differences between API versions, categorize changes by severity, and detect backward-incompatible modifications that could break existing clients.</p>"},{"location":"packages/differ/#overview","title":"Overview","text":"<p>The differ supports comparing OAS 2.0 and OAS 3.x documents, offering two operational modes: simple semantic diffing and breaking change detection with severity classification. It integrates seamlessly with the parse-once pattern, delivering 81x faster performance when working with pre-parsed documents.</p>"},{"location":"packages/differ/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/differ/#diff-modes","title":"Diff Modes","text":"<p>The differ operates in two modes that determine how changes are analyzed and reported:</p> <p>ModeSimple reports all semantic differences between documents without categorization. Use this mode when you need a comprehensive list of what changed without severity assessment. See also: Simple diff example on pkg.go.dev</p> <p>ModeBreaking categorizes every change by both category (what part of the spec changed) and severity (how impactful the change is). This mode is essential for CI/CD pipelines that need to gate releases based on API compatibility. See also: Breaking change detection example on pkg.go.dev</p>"},{"location":"packages/differ/#change-categories","title":"Change Categories","text":"<p>Changes are organized by the specification element that was modified:</p> Category Description <code>CategoryEndpoint</code> Path/endpoint additions, removals, or modifications <code>CategoryOperation</code> HTTP method changes (GET, POST, etc.) <code>CategoryParameter</code> Query, path, header, or cookie parameter changes <code>CategoryRequestBody</code> Request body schema or content type changes <code>CategoryResponse</code> Response schema, status code, or header changes <code>CategorySchema</code> Component schema/definition changes <code>CategorySecurity</code> Security scheme modifications <code>CategoryServer</code> Server URL or variable changes <code>CategoryInfo</code> Metadata changes (title, version, description) <code>CategoryExtension</code> Specification extension (x-*) changes"},{"location":"packages/differ/#severity-levels","title":"Severity Levels","text":"<p>In <code>ModeBreaking</code>, each change receives a severity level indicating its impact on API consumers:</p> Severity Impact Examples <code>SeverityCritical</code> Breaking - immediate client failure Removed endpoint, removed operation <code>SeverityError</code> Breaking - client code changes required Removed required parameter, type changes <code>SeverityWarning</code> Potentially problematic Deprecated operations, new required fields <code>SeverityInfo</code> Non-breaking Additions, relaxed constraints <p>\u2191 Back to top</p>"},{"location":"packages/differ/#api-styles","title":"API Styles","text":"<p>The differ provides two complementary API patterns:</p>"},{"location":"packages/differ/#functional-options-api","title":"Functional Options API","text":"<p>Best for one-off comparisons with inline configuration:</p> <pre><code>result, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n    differ.WithIncludeInfo(true),\n)\n</code></pre>"},{"location":"packages/differ/#struct-based-api","title":"Struct-Based API","text":"<p>Best for comparing multiple document pairs with consistent configuration:</p> <pre><code>d := differ.New()\nd.Mode = differ.ModeBreaking\nd.IncludeInfo = false\n\n// Compare multiple API versions\nresult1, _ := d.Diff(\"api-v1.yaml\", \"api-v2.yaml\")\nresult2, _ := d.Diff(\"api-v2.yaml\", \"api-v3.yaml\")\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#practical-examples","title":"Practical Examples","text":"<p>See also: Basic example, Breaking changes on pkg.go.dev</p>"},{"location":"packages/differ/#basic-difference-detection","title":"Basic Difference Detection","text":"<p>The simplest use case compares two specifications and reports all changes:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/differ\"\n)\n\nfunc main() {\n    result, err := differ.DiffWithOptions(\n        differ.WithSourceFilePath(\"api-v1.yaml\"),\n        differ.WithTargetFilePath(\"api-v2.yaml\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Found %d changes between versions\\n\", len(result.Changes))\n    fmt.Printf(\"Source version: %s\\n\", result.SourceVersion)\n    fmt.Printf(\"Target version: %s\\n\", result.TargetVersion)\n\n    for _, change := range result.Changes {\n        fmt.Println(change.String())\n    }\n}\n</code></pre> <p>Example Input (api-v1.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Pet Store API\n  version: 1.0.0\npaths:\n  /pets:\n    get:\n      operationId: listPets\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n</code></pre> <p>Example Input (api-v2.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Pet Store API\n  version: 2.0.0\npaths:\n  /pets:\n    get:\n      operationId: listPets\n      parameters:\n        - name: limit\n          in: query\n          required: true\n          schema:\n            type: integer\n        - name: offset\n          in: query\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n</code></pre> <p>Example Output:</p> <pre><code>Found 2 changes between versions\nSource version: 3.0.3\nTarget version: 3.0.3\npaths./pets.get.parameters.limit: required changed from false to true\npaths./pets.get.parameters: added parameter 'offset'\n</code></pre>"},{"location":"packages/differ/#breaking-change-detection-for-cicd","title":"Breaking Change Detection for CI/CD","text":"<p>Use breaking change detection to gate deployments:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/erraggy/oastools/differ\"\n)\n\nfunc main() {\n    result, err := differ.DiffWithOptions(\n        differ.WithSourceFilePath(\"current-api.yaml\"),\n        differ.WithTargetFilePath(\"proposed-api.yaml\"),\n        differ.WithMode(differ.ModeBreaking),\n        differ.WithIncludeInfo(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Summary: %d breaking, %d warnings, %d info\\n\",\n        result.BreakingCount, result.WarningCount, result.InfoCount)\n\n    if result.HasBreakingChanges {\n        fmt.Println(\"\\n\u26a0\ufe0f  Breaking changes detected!\")\n        for _, change := range result.Changes {\n            if change.Severity == differ.SeverityCritical || \n               change.Severity == differ.SeverityError {\n                fmt.Printf(\"  [%s] %s: %s\\n\",\n                    change.Severity, change.Path, change.Message)\n            }\n        }\n        os.Exit(1)\n    }\n\n    fmt.Println(\"\u2713 No breaking changes detected\")\n}\n</code></pre> <p>Example Output (with breaking changes):</p> <pre><code>Summary: 2 breaking, 1 warnings, 3 info\n\n\u26a0\ufe0f  Breaking changes detected!\n  [critical] paths./users/{id}: endpoint removed\n  [error] paths./pets.get.parameters.limit: changed from optional to required\n</code></pre>"},{"location":"packages/differ/#high-performance-diffing-with-pre-parsed-documents","title":"High-Performance Diffing with Pre-Parsed Documents","text":"<p>See also: Parsed documents example on pkg.go.dev</p> <p>When processing multiple comparisons or integrating with other oastools packages, use pre-parsed documents for 81x faster performance:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/erraggy/oastools/differ\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    // Parse documents once\n    source, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"api-v1.yaml\"),\n        parser.WithValidateStructure(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    target, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"api-v2.yaml\"),\n        parser.WithValidateStructure(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Compare using parsed documents (skips parsing overhead)\n    start := time.Now()\n    result, err := differ.DiffWithOptions(\n        differ.WithSourceParsed(*source),\n        differ.WithTargetParsed(*target),\n        differ.WithMode(differ.ModeBreaking),\n    )\n    elapsed := time.Since(start)\n\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Diff completed in %v\\n\", elapsed)\n    fmt.Printf(\"Changes: %d\\n\", len(result.Changes))\n}\n</code></pre>"},{"location":"packages/differ/#grouping-changes-by-category","title":"Grouping Changes by Category","text":"<p>See also: Change analysis example on pkg.go.dev</p> <p>Organize diff results for better reporting:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/differ\"\n)\n\nfunc main() {\n    result, err := differ.DiffWithOptions(\n        differ.WithSourceFilePath(\"api-v1.yaml\"),\n        differ.WithTargetFilePath(\"api-v2.yaml\"),\n        differ.WithMode(differ.ModeBreaking),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Group changes by category\n    categories := make(map[differ.ChangeCategory][]differ.Change)\n    for _, change := range result.Changes {\n        categories[change.Category] = append(\n            categories[change.Category], change)\n    }\n\n    // Report in logical order\n    categoryOrder := []differ.ChangeCategory{\n        differ.CategoryEndpoint,\n        differ.CategoryOperation,\n        differ.CategoryParameter,\n        differ.CategoryRequestBody,\n        differ.CategoryResponse,\n        differ.CategorySchema,\n        differ.CategorySecurity,\n        differ.CategoryServer,\n        differ.CategoryInfo,\n        differ.CategoryExtension,\n    }\n\n    for _, category := range categoryOrder {\n        changes := categories[category]\n        if len(changes) &gt; 0 {\n            fmt.Printf(\"\\n%s Changes (%d):\\n\", category, len(changes))\n            for _, change := range changes {\n                fmt.Printf(\"  [%s] %s\\n\", change.Severity, change.String())\n            }\n        }\n    }\n}\n</code></pre> <p>Example Output:</p> <pre><code>parameter Changes (2):\n  [error] paths./pets.get.parameters.limit: required changed from false to true\n  [info] paths./pets.get.parameters: added parameter 'offset'\n\nschema Changes (1):\n  [warning] components.schemas.Pet.properties.status: deprecated\n</code></pre>"},{"location":"packages/differ/#filtering-changes-by-severity","title":"Filtering Changes by Severity","text":"<p>See also: Filter by severity example on pkg.go.dev</p> <p>Focus on specific severity levels:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/differ\"\n)\n\nfunc main() {\n    result, err := differ.DiffWithOptions(\n        differ.WithSourceFilePath(\"api-v1.yaml\"),\n        differ.WithTargetFilePath(\"api-v2.yaml\"),\n        differ.WithMode(differ.ModeBreaking),\n        differ.WithIncludeInfo(false), // Exclude informational changes\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Only process breaking changes (Critical + Error)\n    var breaking []differ.Change\n    for _, change := range result.Changes {\n        switch change.Severity {\n        case differ.SeverityCritical, differ.SeverityError:\n            breaking = append(breaking, change)\n        }\n    }\n\n    if len(breaking) == 0 {\n        fmt.Println(\"No breaking changes found\")\n        return\n    }\n\n    fmt.Printf(\"Found %d breaking changes:\\n\", len(breaking))\n    for _, change := range breaking {\n        fmt.Printf(\"  %s\\n\", change.String())\n    }\n}\n</code></pre>"},{"location":"packages/differ/#comparing-multiple-api-version-pairs","title":"Comparing Multiple API Version Pairs","text":"<p>See also: Reusable differ example on pkg.go.dev</p> <p>When you need to analyze an API's evolution across multiple versions:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/differ\"\n)\n\nfunc main() {\n    // Create a reusable differ instance\n    d := differ.New()\n    d.Mode = differ.ModeBreaking\n    d.IncludeInfo = false\n\n    // Compare multiple version pairs\n    pairs := []struct{ old, new string }{\n        {\"api-v1.yaml\", \"api-v2.yaml\"},\n        {\"api-v2.yaml\", \"api-v3.yaml\"},\n        {\"api-v3.yaml\", \"api-v4.yaml\"},\n    }\n\n    for _, pair := range pairs {\n        result, err := d.Diff(pair.old, pair.new)\n        if err != nil {\n            log.Printf(\"Error comparing %s to %s: %v\", pair.old, pair.new, err)\n            continue\n        }\n\n        fmt.Printf(\"\\n%s \u2192 %s:\\n\", pair.old, pair.new)\n        if result.HasBreakingChanges {\n            fmt.Printf(\"  \u26a0\ufe0f  %d breaking changes\\n\", result.BreakingCount)\n            fmt.Printf(\"  \u26a0\ufe0f  %d warnings\\n\", result.WarningCount)\n        } else {\n            fmt.Printf(\"  \u2713 No breaking changes\\n\")\n            if result.WarningCount &gt; 0 {\n                fmt.Printf(\"  \u2139\ufe0f  %d warnings\\n\", result.WarningCount)\n            }\n        }\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#schema-comparison-details","title":"Schema Comparison Details","text":"<p>The differ performs comprehensive schema comparison including:</p> <p>Type Information: type, format</p> <p>Numeric Constraints: multipleOf, maximum, exclusiveMaximum, minimum, exclusiveMinimum</p> <p>String Constraints: maxLength, minLength, pattern</p> <p>Array Constraints: maxItems, minItems, uniqueItems</p> <p>Object Constraints: maxProperties, minProperties, required fields</p> <p>OAS-specific Fields: nullable, readOnly, writeOnly, deprecated</p>"},{"location":"packages/differ/#smart-severity-assignment-for-schema-changes","title":"Smart Severity Assignment for Schema Changes","text":"<p>The differ uses intelligent severity assignment for constraint changes:</p> <pre><code>ERROR severity (stricter = breaking):\n  - Adding required fields\n  - Lowering maximum values\n  - Raising minimum values\n  - Reducing maxLength/maxItems/maxProperties\n\nWARNING severity (potentially problematic):\n  - Type changes\n  - Format changes\n  - Pattern modifications\n\nINFO severity (relaxations = non-breaking):\n  - Removing required fields\n  - Raising maximum values\n  - Lowering minimum values\n  - Increasing maxLength/maxItems/maxProperties\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#extension-field-coverage","title":"Extension Field Coverage","text":"<p>The differ tracks changes to custom extension fields at commonly-used locations:</p> <p>Diffed Locations: Document level, Info, Server, PathItem, Operation, Parameter, RequestBody, Response, Header, Link, MediaType, Schema, SecurityScheme, Tag, Components</p> <p>Not Diffed: Contact, License, ExternalDocs, ServerVariable, Reference, Items, Example, Encoding, Discriminator, XML, OAuthFlows</p> <p>All extension changes are reported with <code>SeverityInfo</code> since extensions are non-normative.</p> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#source-map-integration","title":"Source Map Integration","text":"<p>Source maps enable precise change locations by tracking line and column numbers from your YAML/JSON source files. Without source maps, changes only show JSON paths. With source maps, changes include file:line:column positions that IDEs can click to jump directly to the modification.</p> <p>Without source maps:</p> <pre><code>paths./pets.get.parameters.limit: required changed from false to true\n</code></pre> <p>With source maps:</p> <pre><code>api-v2.yaml:45:11: required changed from false to true\n</code></pre> <p>The differ compares two documents, so it accepts both <code>WithSourceMap</code> (for the source/old document) and <code>WithTargetMap</code> (for the target/new document):</p> <pre><code>source, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"api-v1.yaml\"),\n    parser.WithSourceMap(true),  // Enable line tracking during parse\n)\ntarget, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"api-v2.yaml\"),\n    parser.WithSourceMap(true),  // Enable line tracking during parse\n)\n\nresult, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(*source),\n    differ.WithTargetParsed(*target),\n    differ.WithSourceMap(source.SourceMap),   // Source document locations\n    differ.WithTargetMap(target.SourceMap),   // Target document locations\n    differ.WithMode(differ.ModeBreaking),\n)\n\n// Changes now include line/column/file info\nfor _, change := range result.Changes {\n    if change.HasLocation() {\n        // IDE-friendly format: file:line:column\n        fmt.Printf(\"%s: %s\\n\", change.Location(), change.Message)\n    } else {\n        // Fallback to JSON path\n        fmt.Printf(\"%s: %s\\n\", change.Path, change.Message)\n    }\n}\n</code></pre> <p>The <code>Location()</code> method returns the IDE-friendly <code>file:line:column</code> format pointing to where the change occurred in the target document. The <code>HasLocation()</code> method checks if line info is available (returns <code>true</code> when <code>Line &gt; 0</code>).</p> <p>Back to top</p>"},{"location":"packages/differ/#integration-with-other-packages","title":"Integration with Other Packages","text":"<p>The differ integrates naturally with the oastools ecosystem:</p> <pre><code>// Parse \u2192 Validate \u2192 Diff workflow\nsource, _ := parser.ParseWithOptions(parser.WithFilePath(\"api-v1.yaml\"))\ntarget, _ := parser.ParseWithOptions(parser.WithFilePath(\"api-v2.yaml\"))\n\n// Validate both documents\nsourceVal, _ := validator.ValidateWithOptions(validator.WithParsed(*source))\ntargetVal, _ := validator.ValidateWithOptions(validator.WithParsed(*target))\n\nif !sourceVal.Valid || !targetVal.Valid {\n    log.Fatal(\"Documents must be valid before comparison\")\n}\n\n// Compare validated documents\nresult, _ := differ.DiffWithOptions(\n    differ.WithSourceParsed(*source),\n    differ.WithTargetParsed(*target),\n    differ.WithMode(differ.ModeBreaking),\n)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#best-practices","title":"Best Practices","text":"<p>Always use ModeBreaking for production workflows to get severity classifications that enable automated decision-making.</p> <p>Document all breaking changes in release notes with migration guides for each Critical or Error severity change.</p> <p>Consider deprecation first before removing features. Deprecation appears as Warning severity, giving consumers time to adapt.</p> <p>Pin to specific major versions based on severity levels\u2014Critical and Error changes warrant major version bumps.</p> <p>Use the parse-once pattern when comparing multiple documents or integrating with other packages for 81x performance improvement.</p> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#configurable-breaking-change-rules","title":"Configurable Breaking Change Rules","text":"<p>Organizations often have custom policies for what constitutes a breaking change. The differ supports configurable rules that let you override default severity levels or completely ignore certain change types.</p>"},{"location":"packages/differ/#rule-configuration","title":"Rule Configuration","text":"<p>Use <code>BreakingRulesConfig</code> to customize breaking change detection:</p> <pre><code>rules := &amp;differ.BreakingRulesConfig{\n    Operation: &amp;differ.OperationRules{\n        // Downgrade operationId changes to Info (not breaking for us)\n        OperationIDModified: &amp;differ.BreakingChangeRule{\n            Severity: differ.SeverityPtr(differ.SeverityInfo),\n        },\n    },\n    Schema: &amp;differ.SchemaRules{\n        // Completely ignore property removal (we handle this differently)\n        PropertyRemoved: &amp;differ.BreakingChangeRule{Ignore: true},\n    },\n}\n\nresult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n    differ.WithBreakingRules(rules),\n)\n</code></pre>"},{"location":"packages/differ/#preset-rule-configurations","title":"Preset Rule Configurations","text":"<p>Three preset configurations are available for common use cases:</p> <pre><code>// DefaultRules - uses built-in severity defaults\nrules := differ.DefaultRules()\n\n// StrictRules - elevates warnings to errors (stricter)\nrules := differ.StrictRules()\n\n// LenientRules - downgrades some errors to warnings (more permissive)\nrules := differ.LenientRules()\n</code></pre>"},{"location":"packages/differ/#available-rule-categories","title":"Available Rule Categories","text":"Category Description Key Rules <code>OperationRules</code> Operation-level changes <code>Removed</code>, <code>OperationIDModified</code>, <code>DeprecatedChanged</code>, <code>SummaryModified</code>, <code>DescriptionModified</code> <code>ParameterRules</code> Parameter changes <code>Added</code>, <code>Removed</code>, <code>RequiredChanged</code>, <code>TypeChanged</code>, <code>LocationChanged</code>, <code>DescriptionModified</code> <code>RequestBodyRules</code> Request body changes <code>Added</code>, <code>Removed</code>, <code>RequiredChanged</code>, <code>ContentTypeAdded</code>, <code>ContentTypeRemoved</code>, <code>DescriptionModified</code> <code>ResponseRules</code> Response changes <code>Added</code>, <code>Removed</code>, <code>StatusCodeAdded</code>, <code>StatusCodeRemoved</code>, <code>ContentTypeAdded</code>, <code>ContentTypeRemoved</code>, <code>DescriptionModified</code> <code>SchemaRules</code> Schema changes <code>TypeChanged</code>, <code>PropertyAdded</code>, <code>PropertyRemoved</code>, <code>RequiredAdded</code>, <code>RequiredRemoved</code>, <code>EnumValueAdded</code>, <code>EnumValueRemoved</code>, <code>DescriptionModified</code> <code>SecurityRules</code> Security scheme changes <code>Added</code>, <code>Removed</code>, <code>TypeChanged</code>, <code>DescriptionModified</code> <code>ServerRules</code> Server changes <code>Added</code>, <code>Removed</code>, <code>URLChanged</code>, <code>DescriptionModified</code> <code>EndpointRules</code> Endpoint changes <code>Added</code>, <code>Removed</code>, <code>DescriptionModified</code> <code>InfoRules</code> Info object changes <code>TitleChanged</code>, <code>VersionChanged</code>, <code>DescriptionModified</code> <code>ExtensionRules</code> Extension field changes <code>Added</code>, <code>Removed</code>, <code>Modified</code>"},{"location":"packages/differ/#struct-based-configuration","title":"Struct-Based Configuration","text":"<p>For reusable differ instances:</p> <pre><code>d := differ.New()\nd.Mode = differ.ModeBreaking\nd.BreakingRules = &amp;differ.BreakingRulesConfig{\n    Operation: &amp;differ.OperationRules{\n        OperationIDModified: &amp;differ.BreakingChangeRule{\n            Severity: differ.SeverityPtr(differ.SeverityError), // Upgrade to error\n        },\n    },\n}\n\nresult1, _ := d.Diff(\"api-v1.yaml\", \"api-v2.yaml\")\nresult2, _ := d.Diff(\"api-v2.yaml\", \"api-v3.yaml\")\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#diffresult-structure","title":"DiffResult Structure","text":"<pre><code>type DiffResult struct {\n    // SourceVersion is the OAS version of the source document\n    SourceVersion string\n    // SourceOASVersion is the enumerated source OAS version\n    SourceOASVersion parser.OASVersion\n    // SourceStats contains statistical information about the source document\n    SourceStats parser.DocumentStats\n    // SourceSize is the size of the source document in bytes\n    SourceSize int64\n    // TargetVersion is the OAS version of the target document\n    TargetVersion string\n    // TargetOASVersion is the enumerated target OAS version\n    TargetOASVersion parser.OASVersion\n    // TargetStats contains statistical information about the target document\n    TargetStats parser.DocumentStats\n    // TargetSize is the size of the target document in bytes\n    TargetSize int64\n    // Changes contains all detected changes\n    Changes []Change\n    // BreakingCount is the number of breaking changes (Critical + Error)\n    BreakingCount int\n    // WarningCount is the number of warnings\n    WarningCount int\n    // InfoCount is the number of informational changes\n    InfoCount int\n    // HasBreakingChanges is true if any breaking changes were detected\n    HasBreakingChanges bool\n\n    // TargetDocument is the target/right document for ToParseResult() chaining\n    TargetDocument any\n    // TargetSourcePath is the path of the target document\n    TargetSourcePath string\n    // TargetSourceFormat is the format of the target document\n    TargetSourceFormat parser.SourceFormat\n}\n\n// ToParseResult() converts the DiffResult to a ParseResult representing\n// the target document, enabling pipeline workflows.\n\ntype Change struct {\n    Type        ChangeType     // added, removed, modified\n    Category    ChangeCategory // endpoint, operation, parameter, etc.\n    Severity    Severity       // critical, error, warning, info\n    Path        string         // JSON path to changed element\n    Message     string         // Human-readable description\n    OldValue    any            // Previous value (for modifications)\n    NewValue    any            // New value (for modifications)\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>DiffResult</code> to a <code>parser.ParseResult</code>. The method returns the target (right) document, which fits the pipeline model where you compare old vs new, then continue processing the newer version:</p> <pre><code>// Diff then validate the new version\ndiffResult, err := differ.DiffWithOptions(\n    differ.WithSourceFilePath(\"api-v1.yaml\"),\n    differ.WithTargetFilePath(\"api-v2.yaml\"),\n    differ.WithMode(differ.ModeBreaking),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Report breaking changes\nif diffResult.HasBreakingChanges {\n    fmt.Printf(\"\u26a0\ufe0f  %d breaking changes detected\\n\", diffResult.BreakingCount)\n}\n\n// Chain the target (new version) to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*diffResult.ToParseResult())\n\n// Or chain to converter for version upgrade\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*diffResult.ToParseResult(), \"3.1.0\")\n</code></pre> <p>This enables workflows like: <code>diff(v1, v2) \u2192 validate(v2) \u2192 convert(v2) \u2192 publish</code></p> <p>Note: Diff changes are converted to string warnings in the resulting ParseResult, preserving severity and path information in the format <code>[severity] path: message</code>.</p> <p>\u2191 Back to top</p>"},{"location":"packages/differ/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd0d Simple diff example - Basic semantic diffing</li> <li>\u26a0\ufe0f Breaking changes example - Comprehensive breaking change detection</li> <li>\ud83d\udcca Change analysis example - Grouping changes by category</li> <li>\ud83d\udd27 Reusable differ example - Comparing multiple API versions</li> </ul>"},{"location":"packages/fixer/","title":"Fixer","text":""},{"location":"packages/fixer/#fixer-package-deep-dive","title":"Fixer Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the fixer in your browser \u2192</p> <p>The <code>fixer</code> package provides automatic fixes for common OpenAPI Specification validation errors, supporting both OAS 2.0 and OAS 3.x documents.</p>"},{"location":"packages/fixer/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Fix Types</li> <li>API Styles</li> <li>Practical Examples</li> <li>Generic Naming Strategies</li> <li>Configuration Reference</li> <li>Package Chaining</li> <li>Best Practices</li> </ul>"},{"location":"packages/fixer/#overview","title":"Overview","text":"<p>The fixer analyzes OAS documents and applies fixes for issues that would cause validation failures. It preserves the input file format (JSON or YAML) for output consistency.</p> <p>Common use cases:</p> <ul> <li>Add missing path parameters automatically</li> <li>Rename schemas with invalid characters (e.g., <code>Response[User]</code>)</li> <li>Remove unused schema definitions</li> <li>Clean up empty path items</li> </ul> <p>Back to top</p>"},{"location":"packages/fixer/#fix-types","title":"Fix Types","text":"Fix Type Default Description <code>FixTypeMissingPathParameter</code> \u2705 Enabled Adds Parameter objects for undeclared path template variables <code>FixTypeRenamedGenericSchema</code> \u274c Disabled Renames schemas containing URL-unsafe characters <code>FixTypePrunedUnusedSchema</code> \u274c Disabled Removes unreferenced schema definitions <code>FixTypePrunedEmptyPath</code> \u274c Disabled Removes paths with no HTTP operations <code>FixTypeEnumCSVExpanded</code> \u274c Disabled Expands CSV enum strings to typed arrays (e.g., \"1,2,3\" \u2192 [1, 2, 3]) <code>FixTypeDuplicateOperationId</code> \u274c Disabled Renames duplicate operationId values to ensure uniqueness <code>FixTypeStubMissingRef</code> \u274c Disabled Creates empty stubs for unresolved <code>$ref</code> targets <p>Why are some fixes disabled by default?</p> <p>Disabled fixes fall into two categories:</p> <ul> <li>Performance-sensitive: Schema renaming (<code>FixTypeRenamedGenericSchema</code>) and pruning (<code>FixTypePrunedUnusedSchema</code>, <code>FixTypePrunedEmptyPath</code>) walk all references and compute unused schemas, which can significantly slow processing of large specifications.</li> <li>Behavioral impact: <code>FixTypeDuplicateOperationId</code> renames operation IDs that clients and SDK generators may already depend on. <code>FixTypeStubMissingRef</code> injects synthetic placeholder content into the document. Both are opt-in to avoid unexpected breakage.</li> </ul> <p>Back to top</p>"},{"location":"packages/fixer/#api-styles","title":"API Styles","text":""},{"location":"packages/fixer/#functional-options-recommended","title":"Functional Options (Recommended)","text":"<pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Applied %d fixes\\n\", result.FixCount)\n</code></pre>"},{"location":"packages/fixer/#struct-based-reusable","title":"Struct-Based (Reusable)","text":"<pre><code>f := fixer.New()\nf.InferTypes = true\n\nresult1, _ := f.Fix(\"api1.yaml\")\nresult2, _ := f.Fix(\"api2.yaml\")\n</code></pre>"},{"location":"packages/fixer/#enable-specific-fixes","title":"Enable Specific Fixes","text":"<pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"api.yaml\"),\n    fixer.WithEnabledFixes(\n        fixer.FixTypeMissingPathParameter,\n        fixer.FixTypeRenamedGenericSchema,\n        fixer.FixTypePrunedUnusedSchema,\n    ),\n)\n</code></pre>"},{"location":"packages/fixer/#enable-all-fixes","title":"Enable ALL Fixes","text":"<pre><code>f := fixer.New()\nf.EnabledFixes = []fixer.FixType{} // Empty slice enables all\nresult, _ := f.Fix(\"api.yaml\")\n</code></pre> <p>Back to top</p>"},{"location":"packages/fixer/#practical-examples","title":"Practical Examples","text":"<p>See also: Basic example, Functional options on pkg.go.dev</p>"},{"location":"packages/fixer/#basic-fixing","title":"Basic Fixing","text":"<pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\nfor _, fix := range result.Fixes {\n    fmt.Printf(\"Fixed: %s at %s\\n\", fix.Type, fix.Path)\n}\n</code></pre>"},{"location":"packages/fixer/#type-inference","title":"Type Inference","text":"<p>See also: Type inference example on pkg.go.dev</p> <p>When enabled, the fixer infers parameter types from naming conventions:</p> Pattern Inferred Type <code>*id</code>, <code>*Id</code>, <code>*ID</code> <code>integer</code> <code>*uuid</code>, <code>*guid</code> <code>string</code> (format: uuid) Everything else <code>string</code> <pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithInferTypes(true),\n)\n</code></pre>"},{"location":"packages/fixer/#dry-run-mode","title":"Dry-Run Mode","text":"<p>See also: Dry-run example on pkg.go.dev</p> <p>Preview fixes without applying them:</p> <pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithDryRun(true),\n)\nfmt.Printf(\"Would apply %d fixes\\n\", result.FixCount)\n// result.Document is unchanged\n</code></pre>"},{"location":"packages/fixer/#generic-schema-renaming","title":"Generic Schema Renaming","text":"<p>See also: Generic naming example on pkg.go.dev</p> <pre><code>result, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"api.yaml\"),\n    fixer.WithEnabledFixes(fixer.FixTypeRenamedGenericSchema),\n    fixer.WithGenericNaming(fixer.GenericNamingOf),\n)\n// Response[User] \u2192 ResponseOfUser\n</code></pre> <p>Back to top</p>"},{"location":"packages/fixer/#generic-naming-strategies","title":"Generic Naming Strategies","text":"<p>See also: Naming config example, Strategy example on pkg.go.dev</p> <p>When fixing invalid schema names like <code>Response[User]</code>:</p> Strategy Result <code>GenericNamingUnderscore</code> <code>Response_User_</code> <code>GenericNamingOf</code> <code>ResponseOfUser</code> <code>GenericNamingFor</code> <code>ResponseForUser</code> <code>GenericNamingFlattened</code> <code>ResponseUser</code> <code>GenericNamingDot</code> <code>Response.User</code> <p>Configure with <code>WithGenericNaming()</code> or <code>WithGenericNamingConfig()</code>.</p> <p>Back to top</p>"},{"location":"packages/fixer/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/fixer/#functional-options","title":"Functional Options","text":"Option Description <code>WithFilePath(path)</code> Path to specification file <code>WithParsed(result)</code> Pre-parsed ParseResult <code>WithInferTypes(bool)</code> Infer parameter types from names <code>WithEnabledFixes(fixes...)</code> Specific fix types to enable <code>WithGenericNaming(strategy)</code> Naming strategy for generic schemas <code>WithGenericNamingConfig(cfg)</code> Custom naming configuration <code>WithDryRun(bool)</code> Preview without applying <code>WithMutableInput(bool)</code> Skip defensive copy when caller owns input <code>WithUserAgent(userAgent string)</code> Custom User-Agent for HTTP requests <code>WithSourceMap(sm *parser.SourceMap)</code> Source map for line/column info in fixes <code>WithOperationIdNamingConfig(config OperationIdNamingConfig)</code> Configuration for duplicate operationId renaming <code>WithStubConfig(config StubConfig)</code> Configuration for missing reference stub creation <code>WithStubResponseDescription(desc string)</code> Default description for stubbed responses"},{"location":"packages/fixer/#fixer-fields","title":"Fixer Fields","text":"Field Type Description <code>InferTypes</code> <code>bool</code> Enable type inference <code>EnabledFixes</code> <code>[]FixType</code> Fix types to apply (empty = all) <code>UserAgent</code> <code>string</code> User-Agent string for HTTP requests <code>SourceMap</code> <code>*parser.SourceMap</code> Source location lookup for fix issues <code>GenericNamingConfig</code> <code>GenericNamingConfig</code> Custom naming rules <code>OperationIdNamingConfig</code> <code>OperationIdNamingConfig</code> Configuration for duplicate operationId renaming <code>StubConfig</code> <code>StubConfig</code> Configuration for missing reference stub creation <code>DryRun</code> <code>bool</code> Preview mode <code>MutableInput</code> <code>bool</code> Skip defensive copy"},{"location":"packages/fixer/#fixresult-fields","title":"FixResult Fields","text":"Field Type Description <code>Document</code> <code>any</code> Fixed document <code>Fixes</code> <code>[]Fix</code> Applied fixes with details <code>FixCount</code> <code>int</code> Total fixes applied <code>SourceFormat</code> <code>SourceFormat</code> Preserved format <code>ToParseResult()</code> <code>*parser.ParseResult</code> Converts result for package chaining <p>Back to top</p>"},{"location":"packages/fixer/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>FixResult</code> to a <code>parser.ParseResult</code>:</p> <pre><code>// Fix then validate\nfixResult, err := fixer.FixWithOptions(\n    fixer.WithFilePath(\"openapi.yaml\"),\n    fixer.WithInferTypes(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*fixResult.ToParseResult())\nfmt.Printf(\"Valid: %v\\n\", valResult.Valid)\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*fixResult.ToParseResult(), \"3.1.0\")\n</code></pre> <p>This enables workflows like: <code>parse \u2192 fix \u2192 validate \u2192 convert \u2192 join</code></p> <p>Back to top</p>"},{"location":"packages/fixer/#best-practices","title":"Best Practices","text":"<ol> <li>Start with defaults - <code>FixTypeMissingPathParameter</code> handles the most common issue</li> <li>Enable expensive fixes only when needed - Schema pruning/renaming can be slow on large specs</li> <li>Use dry-run in CI - Verify what would change before applying</li> <li>Validate after fixing - Ensure the fixed document is valid</li> <li>Pipeline usage - <code>oastools fix api.yaml | oastools validate -q -</code></li> </ol> <p>Back to top</p>"},{"location":"packages/fixer/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd27 Selective fixes example - Enable specific fix types</li> <li>\ud83d\uddd1\ufe0f Prune unused schemas - Remove unreferenced definitions</li> <li>\ud83d\udcc1 Prune empty paths - Clean up empty path items</li> <li>\u2705 Check results example - Inspect applied fixes</li> </ul>"},{"location":"packages/generator/","title":"Generator","text":""},{"location":"packages/generator/#generator-package-deep-dive","title":"Generator Package Deep Dive","text":""},{"location":"packages/generator/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Generation Modes</li> <li>Server Extensions</li> <li>Key Features</li> <li>API Styles</li> <li>Practical Examples</li> <li>Source Map Integration</li> <li>Configuration Reference</li> <li>GenerateResult Structure</li> <li>Best Practices</li> </ul> <p>The <code>generator</code> package creates idiomatic Go code from OpenAPI Specification documents. It produces type-safe API clients, server interface stubs, and model types with comprehensive support for authentication, file splitting for large APIs, and extensible code generation.</p>"},{"location":"packages/generator/#overview","title":"Overview","text":"<p>Code generation transforms your OpenAPI specification into production-ready Go code. Rather than hand-writing HTTP clients or server handlers, the generator produces type-safe code that matches your API contract exactly. The generated code emphasizes Go idioms, proper error handling, and clean interfaces that integrate naturally with existing Go projects.</p> <p>The generator supports OAS 2.0 through OAS 3.2.0, automatically adapting its output to handle version-specific features like requestBody (OAS 3.x) versus body parameters (OAS 2.0).</p> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#generation-modes","title":"Generation Modes","text":"<p>The generator supports three complementary modes that can be combined:</p> <p>Client Mode generates an HTTP client with methods for each API operation. Each method has strongly-typed parameters and return types, handles request/response serialization, and supports authentication via ClientOptions.</p> <p>Server Mode generates interface definitions that your server code must implement. This provides a clean contract between your API specification and your implementation, ensuring type safety at compile time.</p> <p>Types Mode generates Go structs from your schema definitions. This mode is automatically enabled when generating clients or servers, but can be used standalone when you only need the model types.</p> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#server-extensions","title":"Server Extensions","text":"<p>When generating server code (<code>--server</code> or <code>WithServer(true)</code>), additional extensions provide a complete server framework with runtime validation, request binding, routing, and testing support.</p>"},{"location":"packages/generator/#available-server-extensions","title":"Available Server Extensions","text":"Flag / Option Generated File Description <code>--server-responses</code> / <code>WithServerResponses(true)</code> <code>server_responses.go</code> Typed response writers and error helpers <code>--server-binder</code> / <code>WithServerBinder(true)</code> <code>server_binder.go</code> Type-safe parameter binding from HTTP requests <code>--server-middleware</code> / <code>WithServerMiddleware(true)</code> <code>server_middleware.go</code> Validation middleware using httpvalidator <code>--server-router</code> / <code>WithServerRouter(\"stdlib\")</code> <code>server_router.go</code> HTTP router with path matching and handler dispatch <code>--server-stubs</code> / <code>WithServerStubs(true)</code> <code>server_stubs.go</code> Configurable stub implementations for testing <code>--server-all</code> / <code>WithServerAll()</code> All above Enable all server extensions"},{"location":"packages/generator/#response-helpers-server_responsesgo","title":"Response Helpers (<code>server_responses.go</code>)","text":"<p>Response helpers provide type-safe response writing with per-operation response types:</p> <pre><code>// Generated for each operation\ntype ListPetsResponse struct {\n    statusCode int\n    body       any\n}\n\nfunc (ListPetsResponse) Status200(pets []Pet) ListPetsResponse { ... }\nfunc (ListPetsResponse) StatusDefault(err Error) ListPetsResponse { ... }\nfunc (r ListPetsResponse) WriteTo(w http.ResponseWriter) error { ... }\n\n// Common helpers\nfunc WriteJSON(w http.ResponseWriter, statusCode int, body any) { ... }\nfunc WriteError(w http.ResponseWriter, statusCode int, message string) { ... }\nfunc WriteNoContent(w http.ResponseWriter) { ... }\n</code></pre> <p>Usage:</p> <pre><code>func (s *MyServer) ListPets(ctx context.Context, req *ListPetsRequest) (ListPetsResponse, error) {\n    pets, err := s.db.GetPets(req.Limit)\n    if err != nil {\n        return ListPetsResponse{}.StatusDefault(Error{Message: err.Error()}), nil\n    }\n    return ListPetsResponse{}.Status200(pets), nil\n}\n</code></pre>"},{"location":"packages/generator/#request-binder-server_bindergo","title":"Request Binder (<code>server_binder.go</code>)","text":"<p>The request binder extracts and validates parameters from HTTP requests, converting them to typed request structs:</p> <pre><code>type RequestBinder struct {\n    validator *httpvalidator.Validator\n}\n\nfunc NewRequestBinder(parsed *parser.ParseResult) (*RequestBinder, error) { ... }\nfunc NewRequestBinderFromValidator(v *httpvalidator.Validator) *RequestBinder { ... }\n\n// Per-operation binding methods\nfunc (b *RequestBinder) BindListPetsRequest(r *http.Request) (*ListPetsRequest, *BindingError) { ... }\nfunc (b *RequestBinder) BindCreatePetRequest(r *http.Request) (*CreatePetRequest, *BindingError) { ... }\n</code></pre> <p>Usage:</p> <pre><code>binder, _ := NewRequestBinder(parsed)\n\nhttp.HandleFunc(\"/pets\", func(w http.ResponseWriter, r *http.Request) {\n    req, bindErr := binder.BindListPetsRequest(r)\n    if bindErr != nil {\n        WriteError(w, 400, bindErr.Error())\n        return\n    }\n    // req is now a typed *ListPetsRequest with validated parameters\n})\n</code></pre>"},{"location":"packages/generator/#validation-middleware-server_middlewarego","title":"Validation Middleware (<code>server_middleware.go</code>)","text":"<p>Validation middleware integrates with <code>httpvalidator</code> for request/response validation:</p> <pre><code>type ValidationConfig struct {\n    IncludeRequestValidation  bool\n    IncludeResponseValidation bool\n    StrictMode                bool\n    OnValidationError         func(w http.ResponseWriter, r *http.Request, result *httpvalidator.RequestValidationResult)\n}\n\nfunc DefaultValidationConfig() ValidationConfig { ... }\nfunc ValidationMiddleware(parsed *parser.ParseResult) func(http.Handler) http.Handler { ... }\nfunc ValidationMiddlewareWithConfig(parsed *parser.ParseResult, cfg ValidationConfig) func(http.Handler) http.Handler { ... }\n</code></pre> <p>Usage:</p> <pre><code>parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\n\n// Wrap your handler with validation\nhandler := ValidationMiddleware(parsed)(myHandler)\n\n// Or with custom configuration\ncfg := DefaultValidationConfig()\ncfg.StrictMode = true\ncfg.OnValidationError = func(w http.ResponseWriter, r *http.Request, result *httpvalidator.RequestValidationResult) {\n    // result.Errors contains detailed validation errors\n    WriteError(w, 422, \"validation failed\")\n}\nhandler = ValidationMiddlewareWithConfig(parsed, cfg)(myHandler)\n</code></pre>"},{"location":"packages/generator/#router-server_routergo","title":"Router (<code>server_router.go</code>)","text":"<p>The router dispatches HTTP requests to your <code>ServerInterface</code> implementation:</p> <pre><code>type ServerRouter struct {\n    server     ServerInterface\n    validator  *httpvalidator.Validator\n    middleware []func(http.Handler) http.Handler\n}\n\nfunc NewServerRouter(server ServerInterface, parsed *parser.ParseResult, opts ...RouterOption) (*ServerRouter, error) { ... }\nfunc (r *ServerRouter) Handler() http.Handler { ... }\nfunc (r *ServerRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) { ... }\n\n// Router options\nfunc WithMiddleware(mw ...func(http.Handler) http.Handler) RouterOption { ... }\n\n// Path parameter helper\nfunc PathParam(r *http.Request, name string) string { ... }\n</code></pre> <p>Usage:</p> <pre><code>server := NewMyPetStoreServer()\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\n\nrouter, err := NewServerRouter(server, parsed,\n    WithMiddleware(loggingMiddleware),\n    WithMiddleware(ValidationMiddleware(parsed)),\n    WithErrorHandler(func(r *http.Request, err error) {\n        // Log errors server-side without exposing to clients\n        log.Printf(\"Handler error: %s %s: %v\", r.Method, r.URL.Path, err)\n    }),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nhttp.ListenAndServe(\":8080\", router)\n</code></pre> <p>Error Handling: The router returns a generic \"internal server error\" message to clients to prevent information disclosure. Use <code>WithErrorHandler</code> to log the actual error for debugging.</p>"},{"location":"packages/generator/#chi-router-server_router_chigo","title":"Chi Router (<code>server_router_chi.go</code>)","text":"<p>For projects using chi, enable the chi router with <code>--server-router chi</code>:</p> <pre><code>oastools generate server -i openapi.yaml -o petstore --server-router chi\n</code></pre> <pre><code>import (\n    \"github.com/go-chi/chi/v5\"\n    \"github.com/go-chi/chi/v5/middleware\"\n)\n\nserver := NewMyPetStoreServer()\n\n// Create chi router with built-in path parameter extraction\nrouter := NewChiRouter(server,\n    WithMiddleware(middleware.Logger),\n    WithMiddleware(middleware.Recoverer),\n    WithErrorHandler(func(r *http.Request, err error) {\n        log.Printf(\"Handler error: %s %s: %v\", r.Method, r.URL.Path, err)\n    }),\n)\n\nhttp.ListenAndServe(\":8080\", router)\n</code></pre> <p>Key differences from stdlib router:</p> <ul> <li>Chi handles path parameter extraction natively via <code>chi.URLParam()</code></li> <li>No need for the <code>PathParam()</code> helper function</li> <li>Compatible with chi's ecosystem of middleware</li> <li><code>NewChiRouter()</code> returns <code>chi.Router</code> directly (no error return)</li> </ul>"},{"location":"packages/generator/#stub-server-server_stubsgo","title":"Stub Server (<code>server_stubs.go</code>)","text":"<p>The stub server is a configurable mock implementation for testing:</p> <pre><code>type StubServer struct {\n    ListPetsFunc   func(ctx context.Context, req *ListPetsRequest) (ListPetsResponse, error)\n    CreatePetFunc  func(ctx context.Context, req *CreatePetRequest) (CreatePetResponse, error)\n    ShowPetByIdFunc func(ctx context.Context, req *ShowPetByIdRequest) (ShowPetByIdResponse, error)\n}\n\nfunc NewStubServer() *StubServer { ... }\nfunc NewStubServerWithOptions(opts ...StubServerOption) *StubServer { ... }\nfunc (s *StubServer) Reset() { ... }\n\n// Per-operation options\nfunc WithListPets(fn func(ctx context.Context, req *ListPetsRequest) (ListPetsResponse, error)) StubServerOption { ... }\n</code></pre> <p>Usage in tests:</p> <pre><code>func TestPetAPI(t *testing.T) {\n    stub := NewStubServerWithOptions(\n        WithListPets(func(ctx context.Context, req *ListPetsRequest) (ListPetsResponse, error) {\n            return ListPetsResponse{}.Status200([]Pet{{ID: 1, Name: \"Fluffy\"}}), nil\n        }),\n    )\n\n    parsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\n    router, _ := NewServerRouter(stub, parsed)\n\n    req := httptest.NewRequest(\"GET\", \"/pets\", nil)\n    rec := httptest.NewRecorder()\n    router.ServeHTTP(rec, req)\n\n    assert.Equal(t, 200, rec.Code)\n}\n</code></pre>"},{"location":"packages/generator/#full-server-generation-example","title":"Full Server Generation Example","text":"<p>Generate a complete server with all extensions:</p> <pre><code>result, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"petstore.yaml\"),\n    generator.WithPackageName(\"petstore\"),\n    generator.WithServer(true),\n    generator.WithServerAll(),  // Enable all extensions\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Generated files:\n// - types.go           (schema types)\n// - server.go          (ServerInterface, request types, UnimplementedServer)\n// - server_responses.go (response types and helpers)\n// - server_binder.go   (request binding)\n// - server_middleware.go (validation middleware)\n// - server_router.go   (HTTP routing)\n// - server_stubs.go    (test stubs)\n\nif err := result.WriteFiles(\"./generated/petstore\"); err != nil {\n    log.Fatal(err)\n}\n</code></pre> <p>CLI equivalent:</p> <pre><code>oastools generate --server --server-all -o ./generated/petstore -p petstore petstore.yaml\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#key-features","title":"Key Features","text":""},{"location":"packages/generator/#security-helpers","title":"Security Helpers","text":"<p>See also: Security helpers example on pkg.go.dev</p> <p>The generator automatically creates authentication helpers based on your security schemes. These helpers are generated as <code>ClientOption</code> functions that configure the client for specific authentication methods.</p> <p>Supported Security Types:</p> Security Type Generated Helper API Key (header) <code>With{Name}APIKey(key string)</code> API Key (query) <code>With{Name}APIKeyQuery(key string)</code> API Key (cookie) <code>With{Name}APIKeyCookie(key string)</code> HTTP Basic <code>With{Name}BasicAuth(username, password string)</code> HTTP Bearer <code>With{Name}BearerToken(token string)</code> OAuth2 <code>With{Name}OAuth2Token(token string)</code> OpenID Connect <code>With{Name}Token(token string)</code>"},{"location":"packages/generator/#file-splitting-for-large-apis","title":"File Splitting for Large APIs","text":"<p>See also: File splitting example on pkg.go.dev</p> <p>Large API specifications like Microsoft Graph or Stripe can produce thousands of lines of generated code. The generator automatically splits output across multiple files based on configurable thresholds and grouping strategies.</p>"},{"location":"packages/generator/#advanced-security-features","title":"Advanced Security Features","text":"<p>See also: OAuth2 flows example on pkg.go.dev</p> <p>Beyond basic authentication helpers, the generator supports advanced security scenarios:</p> <p>OAuth2 Token Flows generates helpers for token acquisition, refresh, and authorization code exchange.</p> <p>Credential Management generates a <code>CredentialProvider</code> interface with built-in implementations for memory storage, environment variables, and credential chains.</p> <p>Security Enforcement generates server-side middleware for validating security requirements on incoming requests.</p> <p>OpenID Connect Discovery generates clients for OIDC <code>.well-known</code> endpoint discovery and auto-configuration.</p> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#api-styles","title":"API Styles","text":""},{"location":"packages/generator/#functional-options-api","title":"Functional Options API","text":"<p>Best for one-off generation with inline configuration:</p> <pre><code>result, err := generator.GenerateWithOptions(\n    generator.WithFilePath(\"openapi.yaml\"),\n    generator.WithPackageName(\"petstore\"),\n    generator.WithClient(true),\n    generator.WithServer(true),\n)\n</code></pre>"},{"location":"packages/generator/#struct-based-api","title":"Struct-Based API","text":"<p>Best for multiple generation operations with consistent configuration:</p> <pre><code>g := generator.New()\ng.PackageName = \"api\"\ng.GenerateClient = true\ng.GenerateServer = true\ng.UsePointers = true\ng.IncludeValidation = true\n\nresult1, _ := g.Generate(\"users-api.yaml\")\nresult2, _ := g.Generate(\"orders-api.yaml\")\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#practical-examples","title":"Practical Examples","text":"<p>See also: Basic example, Client and server on pkg.go.dev</p>"},{"location":"packages/generator/#generating-a-basic-client","title":"Generating a Basic Client","text":"<p>The simplest use case generates a client library from an OpenAPI specification:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"petstore.yaml\"),\n        generator.WithPackageName(\"petstore\"),\n        generator.WithClient(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Write generated files to directory\n    if err := result.WriteFiles(\"./generated/petstore\"); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Generated %d files\\n\", len(result.Files))\n    for _, file := range result.Files {\n        fmt.Printf(\"  %s (%d bytes)\\n\", file.Name, len(file.Content))\n    }\n}\n</code></pre> <p>Example Input (petstore.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Pet Store API\n  version: 1.0.0\nservers:\n  - url: https://api.petstore.example.com/v1\npaths:\n  /pets:\n    get:\n      operationId: listPets\n      parameters:\n        - name: limit\n          in: query\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Pet'\n    post:\n      operationId: createPet\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/NewPet'\n      responses:\n        '201':\n          description: Created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Pet'\n  /pets/{petId}:\n    get:\n      operationId: getPet\n      parameters:\n        - name: petId\n          in: path\n          required: true\n          schema:\n            type: integer\n            format: int64\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Pet'\ncomponents:\n  schemas:\n    Pet:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: integer\n          format: int64\n        name:\n          type: string\n        tag:\n          type: string\n    NewPet:\n      type: object\n      required:\n        - name\n      properties:\n        name:\n          type: string\n        tag:\n          type: string\n</code></pre> <p>Generated Output Structure:</p> <pre><code>generated/petstore/\n\u251c\u2500\u2500 client.go          # HTTP client implementation\n\u251c\u2500\u2500 types.go           # Pet, NewPet structs\n\u251c\u2500\u2500 security_helpers.go # Authentication helpers (if security schemes exist)\n\u2514\u2500\u2500 README.md          # Usage documentation\n</code></pre> <p>Generated Client Usage:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"myproject/generated/petstore\"\n)\n\nfunc main() {\n    // Create client with base URL\n    client := petstore.NewClient(\"https://api.petstore.example.com/v1\")\n\n    // List pets with optional limit\n    limit := 10\n    pets, err := client.ListPets(context.Background(), &amp;limit)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    for _, pet := range pets {\n        fmt.Printf(\"Pet: %s (ID: %d)\\n\", pet.Name, pet.ID)\n    }\n\n    // Create a new pet\n    newPet := &amp;petstore.NewPet{\n        Name: \"Fluffy\",\n        Tag:  stringPtr(\"cat\"),\n    }\n\n    created, err := client.CreatePet(context.Background(), newPet)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Created pet with ID: %d\\n\", created.ID)\n\n    // Get specific pet\n    pet, err := client.GetPet(context.Background(), created.ID)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Retrieved: %s\\n\", pet.Name)\n}\n\nfunc stringPtr(s string) *string { return &amp;s }\n</code></pre>"},{"location":"packages/generator/#generating-server-interface","title":"Generating Server Interface","text":"<p>Generate server interfaces for framework-agnostic implementation:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"petstore.yaml\"),\n        generator.WithPackageName(\"petstore\"),\n        generator.WithServer(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/petstore\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Generated Server Interface:</p> <pre><code>// Code generated by oastools. DO NOT EDIT.\n\npackage petstore\n\nimport \"context\"\n\n// PetStoreServer defines the interface for the Pet Store API.\n// Implement this interface to create your server.\ntype PetStoreServer interface {\n    // ListPets returns a list of pets.\n    ListPets(ctx context.Context, req *ListPetsRequest) (*ListPetsResponse, error)\n\n    // CreatePet creates a new pet.\n    CreatePet(ctx context.Context, req *CreatePetRequest) (*CreatePetResponse, error)\n\n    // GetPet returns a specific pet by ID.\n    GetPet(ctx context.Context, req *GetPetRequest) (*GetPetResponse, error)\n}\n\n// ListPetsRequest contains the parameters for ListPets.\ntype ListPetsRequest struct {\n    Limit *int `json:\"limit,omitempty\"`\n}\n\n// ListPetsResponse contains the response for ListPets.\ntype ListPetsResponse struct {\n    Pets []Pet `json:\"pets\"`\n}\n\n// CreatePetRequest contains the parameters for CreatePet.\ntype CreatePetRequest struct {\n    Body NewPet `json:\"body\"`\n}\n\n// CreatePetResponse contains the response for CreatePet.\ntype CreatePetResponse struct {\n    Pet Pet `json:\"pet\"`\n}\n\n// GetPetRequest contains the parameters for GetPet.\ntype GetPetRequest struct {\n    PetID int64 `json:\"petId\"`\n}\n\n// GetPetResponse contains the response for GetPet.\ntype GetPetResponse struct {\n    Pet Pet `json:\"pet\"`\n}\n</code></pre> <p>Implementing the Server:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"sync\"\n    \"sync/atomic\"\n\n    \"myproject/generated/petstore\"\n)\n\n// PetStoreImpl implements the petstore.PetStoreServer interface.\ntype PetStoreImpl struct {\n    mu     sync.RWMutex\n    pets   map[int64]*petstore.Pet\n    nextID int64\n}\n\nfunc NewPetStoreImpl() *PetStoreImpl {\n    return &amp;PetStoreImpl{\n        pets: make(map[int64]*petstore.Pet),\n    }\n}\n\nfunc (s *PetStoreImpl) ListPets(ctx context.Context, req *petstore.ListPetsRequest) (*petstore.ListPetsResponse, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n\n    pets := make([]petstore.Pet, 0, len(s.pets))\n    for _, pet := range s.pets {\n        pets = append(pets, *pet)\n        if req.Limit != nil &amp;&amp; len(pets) &gt;= *req.Limit {\n            break\n        }\n    }\n\n    return &amp;petstore.ListPetsResponse{Pets: pets}, nil\n}\n\nfunc (s *PetStoreImpl) CreatePet(ctx context.Context, req *petstore.CreatePetRequest) (*petstore.CreatePetResponse, error) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n\n    id := atomic.AddInt64(&amp;s.nextID, 1)\n    pet := &amp;petstore.Pet{\n        ID:   id,\n        Name: req.Body.Name,\n        Tag:  req.Body.Tag,\n    }\n    s.pets[id] = pet\n\n    return &amp;petstore.CreatePetResponse{Pet: *pet}, nil\n}\n\nfunc (s *PetStoreImpl) GetPet(ctx context.Context, req *petstore.GetPetRequest) (*petstore.GetPetResponse, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n\n    pet, ok := s.pets[req.PetID]\n    if !ok {\n        return nil, ErrNotFound\n    }\n\n    return &amp;petstore.GetPetResponse{Pet: *pet}, nil\n}\n</code></pre>"},{"location":"packages/generator/#client-with-security-helpers","title":"Client with Security Helpers","text":"<p>Generate a client with authentication support:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"secure-api.yaml\"),\n        generator.WithPackageName(\"api\"),\n        generator.WithClient(true),\n        generator.WithSecurity(true),  // Enable security helpers\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Example Spec with Security:</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Secure API\n  version: 1.0.0\ncomponents:\n  securitySchemes:\n    apiKeyHeader:\n      type: apiKey\n      in: header\n      name: X-API-Key\n    bearerAuth:\n      type: http\n      scheme: bearer\n    oauth2:\n      type: oauth2\n      flows:\n        clientCredentials:\n          tokenUrl: https://auth.example.com/oauth/token\n          scopes:\n            read: Read access\n            write: Write access\n</code></pre> <p>Generated Security Helpers:</p> <pre><code>// Code generated by oastools. DO NOT EDIT.\n\npackage api\n\nimport (\n    \"context\"\n    \"encoding/base64\"\n    \"net/http\"\n)\n\n// WithApiKeyHeaderAPIKey sets the X-API-Key header for API key authentication.\nfunc WithApiKeyHeaderAPIKey(key string) ClientOption {\n    return func(c *Client) {\n        c.requestMiddleware = append(c.requestMiddleware, \n            func(ctx context.Context, req *http.Request) error {\n                req.Header.Set(\"X-API-Key\", key)\n                return nil\n            })\n    }\n}\n\n// WithBearerAuthBearerToken sets the Authorization header with a Bearer token.\nfunc WithBearerAuthBearerToken(token string) ClientOption {\n    return func(c *Client) {\n        c.requestMiddleware = append(c.requestMiddleware,\n            func(ctx context.Context, req *http.Request) error {\n                req.Header.Set(\"Authorization\", \"Bearer \"+token)\n                return nil\n            })\n    }\n}\n\n// WithOauth2OAuth2Token sets the Authorization header with an OAuth2 token.\nfunc WithOauth2OAuth2Token(token string) ClientOption {\n    return func(c *Client) {\n        c.requestMiddleware = append(c.requestMiddleware,\n            func(ctx context.Context, req *http.Request) error {\n                req.Header.Set(\"Authorization\", \"Bearer \"+token)\n                return nil\n            })\n    }\n}\n</code></pre> <p>Using Security Helpers:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"myproject/generated/api\"\n)\n\nfunc main() {\n    // Create client with API key authentication\n    client := api.NewClient(\n        \"https://api.example.com\",\n        api.WithApiKeyHeaderAPIKey(\"your-api-key-here\"),\n    )\n\n    // Or use Bearer token\n    client = api.NewClient(\n        \"https://api.example.com\",\n        api.WithBearerAuthBearerToken(\"your-jwt-token\"),\n    )\n\n    // Or use OAuth2 token\n    client = api.NewClient(\n        \"https://api.example.com\",\n        api.WithOauth2OAuth2Token(\"your-oauth-token\"),\n    )\n\n    // Make authenticated requests\n    result, err := client.GetProtectedResource(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"Result: %+v\", result)\n}\n</code></pre>"},{"location":"packages/generator/#advanced-security-oauth2-flows","title":"Advanced Security: OAuth2 Flows","text":"<p>Generate OAuth2 token flow helpers for complete authentication workflows:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"oauth-api.yaml\"),\n        generator.WithPackageName(\"api\"),\n        generator.WithClient(true),\n        generator.WithOAuth2Flows(true),  // Generate token flow helpers\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Generated OAuth2 Flow Helpers:</p> <pre><code>// OAuth2TokenResponse represents an OAuth2 token response.\ntype OAuth2TokenResponse struct {\n    AccessToken  string `json:\"access_token\"`\n    TokenType    string `json:\"token_type\"`\n    ExpiresIn    int    `json:\"expires_in\"`\n    RefreshToken string `json:\"refresh_token,omitempty\"`\n    Scope        string `json:\"scope,omitempty\"`\n}\n\n// OAuth2Client handles OAuth2 authentication flows.\ntype OAuth2Client struct {\n    TokenURL     string\n    ClientID     string\n    ClientSecret string\n    HTTPClient   *http.Client\n}\n\n// ClientCredentialsGrant performs the client credentials grant flow.\nfunc (c *OAuth2Client) ClientCredentialsGrant(ctx context.Context, scopes []string) (*OAuth2TokenResponse, error) {\n    // Implementation handles token request\n}\n\n// RefreshToken refreshes an existing token.\nfunc (c *OAuth2Client) RefreshToken(ctx context.Context, refreshToken string) (*OAuth2TokenResponse, error) {\n    // Implementation handles token refresh\n}\n\n// WithAutoRefresh returns a ClientOption that automatically refreshes tokens.\nfunc WithAutoRefresh() ClientOption {\n    // Implementation handles automatic token refresh\n}\n</code></pre> <p>Using OAuth2 Flows:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    \"time\"\n\n    \"myproject/generated/api\"\n)\n\nfunc main() {\n    // Create OAuth2 client\n    oauth := &amp;api.OAuth2Client{\n        TokenURL:     \"https://auth.example.com/oauth/token\",\n        ClientID:     \"your-client-id\",\n        ClientSecret: \"your-client-secret\",\n    }\n\n    // Get initial token\n    token, err := oauth.ClientCredentialsGrant(context.Background(), []string{\"read\", \"write\"})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create API client with token\n    client := api.NewClient(\n        \"https://api.example.com\",\n        api.WithOauth2OAuth2Token(token.AccessToken),\n    )\n\n    // Or use auto-refresh for long-running applications\n    client = api.NewClient(\n        \"https://api.example.com\",\n        api.WithAutoRefresh(),\n    )\n}\n</code></pre>"},{"location":"packages/generator/#credential-management","title":"Credential Management","text":"<p>Generate credential provider interfaces for flexible authentication:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"api.yaml\"),\n        generator.WithPackageName(\"api\"),\n        generator.WithClient(true),\n        generator.WithCredentialMgmt(true),  // Generate credential management\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Generated Credential Management:</p> <pre><code>// CredentialProvider retrieves credentials for API authentication.\ntype CredentialProvider interface {\n    GetCredential(ctx context.Context, scheme string) (string, error)\n}\n\n// MemoryCredentialProvider stores credentials in memory.\n// Useful for testing and simple applications.\ntype MemoryCredentialProvider struct {\n    credentials map[string]string\n}\n\n// EnvCredentialProvider retrieves credentials from environment variables.\ntype EnvCredentialProvider struct {\n    // EnvMapping maps security scheme names to environment variable names.\n    EnvMapping map[string]string\n}\n\n// CredentialChain tries multiple providers in order.\ntype CredentialChain struct {\n    Providers []CredentialProvider\n}\n\n// WithCredentialProvider returns a ClientOption that uses the given provider.\nfunc WithCredentialProvider(provider CredentialProvider) ClientOption {\n    // Implementation\n}\n</code></pre> <p>Using Credential Providers:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n\n    \"myproject/generated/api\"\n)\n\nfunc main() {\n    // Use environment variables for credentials\n    envProvider := &amp;api.EnvCredentialProvider{\n        EnvMapping: map[string]string{\n            \"apiKey\":     \"API_KEY\",\n            \"bearerAuth\": \"AUTH_TOKEN\",\n        },\n    }\n\n    // Or create a chain for fallback\n    chain := &amp;api.CredentialChain{\n        Providers: []api.CredentialProvider{\n            envProvider,\n            &amp;api.MemoryCredentialProvider{\n                credentials: map[string]string{\n                    \"apiKey\": \"fallback-key\",\n                },\n            },\n        },\n    }\n\n    client := api.NewClient(\n        \"https://api.example.com\",\n        api.WithCredentialProvider(chain),\n    )\n\n    // Credentials are resolved automatically per request\n    result, err := client.GetResource(context.Background())\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"Result: %+v\", result)\n}\n</code></pre>"},{"location":"packages/generator/#file-splitting-for-large-apis_1","title":"File Splitting for Large APIs","text":"<p>Configure file splitting when generating from large specifications:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"large-api.yaml\"),  // 1000+ operations\n        generator.WithPackageName(\"api\"),\n        generator.WithClient(true),\n\n        // File splitting configuration\n        generator.WithMaxLinesPerFile(2000),      // Split at 2000 lines\n        generator.WithMaxTypesPerFile(200),       // Max 200 types per file\n        generator.WithMaxOperationsPerFile(100),  // Max 100 operations per file\n        generator.WithSplitByTag(true),           // Group by operation tags\n        generator.WithSplitByPathPrefix(true),    // Fallback: group by path prefix\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Generated %d files:\\n\", len(result.Files))\n    for _, file := range result.Files {\n        fmt.Printf(\"  %s (%d bytes)\\n\", file.Name, len(file.Content))\n    }\n}\n</code></pre> <p>Example Output Structure for Large API:</p> <pre><code>generated/api/\n\u251c\u2500\u2500 client.go                 # Core client type and helpers\n\u251c\u2500\u2500 users_client.go           # Operations tagged \"users\"\n\u251c\u2500\u2500 orders_client.go          # Operations tagged \"orders\"\n\u251c\u2500\u2500 products_client.go        # Operations tagged \"products\"\n\u251c\u2500\u2500 admin_client.go           # Operations tagged \"admin\"\n\u251c\u2500\u2500 types.go                  # Shared types\n\u251c\u2500\u2500 users_types.go            # Types for users operations\n\u251c\u2500\u2500 orders_types.go           # Types for orders operations\n\u251c\u2500\u2500 security_helpers.go       # Authentication helpers\n\u2514\u2500\u2500 README.md                 # Usage documentation\n</code></pre>"},{"location":"packages/generator/#server-side-security-enforcement","title":"Server-Side Security Enforcement","text":"<p>Generate security validation middleware for server implementations:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/generator\"\n)\n\nfunc main() {\n    result, err := generator.GenerateWithOptions(\n        generator.WithFilePath(\"api.yaml\"),\n        generator.WithPackageName(\"api\"),\n        generator.WithServer(true),\n        generator.WithSecurityEnforce(true),  // Generate enforcement middleware\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := result.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>Generated Security Enforcement:</p> <pre><code>// SecurityRequirement describes a security requirement for an operation.\ntype SecurityRequirement struct {\n    Scheme string\n    Scopes []string\n}\n\n// OperationSecurityRequirements maps operation IDs to their security requirements.\nvar OperationSecurityRequirements = map[string][]SecurityRequirement{\n    \"listUsers\":   {{Scheme: \"bearerAuth\", Scopes: []string{\"read\"}}},\n    \"createUser\":  {{Scheme: \"bearerAuth\", Scopes: []string{\"write\"}}},\n    \"adminAction\": {{Scheme: \"bearerAuth\", Scopes: []string{\"admin\"}}},\n}\n\n// SecurityValidator validates security requirements for requests.\ntype SecurityValidator struct {\n    // TokenValidator validates bearer tokens.\n    TokenValidator func(token string, scopes []string) error\n    // APIKeyValidator validates API keys.\n    APIKeyValidator func(key string) error\n}\n\n// RequireSecurityMiddleware returns HTTP middleware that enforces security.\nfunc RequireSecurityMiddleware(validator *SecurityValidator) func(http.Handler) http.Handler {\n    // Implementation validates security per-operation\n}\n</code></pre>"},{"location":"packages/generator/#high-performance-generation-with-pre-parsed-documents","title":"High-Performance Generation with Pre-Parsed Documents","text":"<p>For workflows that combine parsing, validation, and generation:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/erraggy/oastools/generator\"\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    // Parse once\n    parseResult, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"api.yaml\"),\n        parser.WithValidateStructure(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Validate\n    valResult, err := validator.ValidateWithOptions(\n        validator.WithParsed(*parseResult),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n    if !valResult.Valid {\n        log.Fatal(\"Specification has validation errors\")\n    }\n\n    // Generate from pre-parsed document\n    start := time.Now()\n    genResult, err := generator.GenerateWithOptions(\n        generator.WithParsed(*parseResult),\n        generator.WithPackageName(\"api\"),\n        generator.WithClient(true),\n        generator.WithServer(true),\n    )\n    elapsed := time.Since(start)\n\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Generation completed in %v\\n\", elapsed)\n    fmt.Printf(\"Files generated: %d\\n\", len(genResult.Files))\n\n    if err := genResult.WriteFiles(\"./generated/api\"); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#source-map-integration","title":"Source Map Integration","text":"<p>Source maps enable precise issue locations by tracking line and column numbers from your YAML/JSON source. Without source maps, generation issues only show JSON paths. With source maps, issues include file:line:column positions that IDEs can click to jump directly to the problematic schema or operation.</p> <p>Without source maps:</p> <pre><code>warning: components.schemas.Order: schema has no properties defined\n</code></pre> <p>With source maps:</p> <pre><code>openapi.yaml:142:5: warning: schema has no properties defined\n</code></pre> <p>To enable source map tracking:</p> <pre><code>parseResult, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithSourceMap(true),  // Enable line tracking during parse\n)\n\nresult, _ := generator.GenerateWithOptions(\n    generator.WithParsed(*parseResult),\n    generator.WithSourceMap(parseResult.SourceMap),  // Pass to generator\n    generator.WithPackageName(\"api\"),\n    generator.WithClient(true),\n)\n\n// Issues now include line/column/file info\nfor _, issue := range result.Issues {\n    if issue.HasLocation() {\n        // IDE-friendly format: file:line:column\n        fmt.Printf(\"%s: %s: %s\\n\", issue.Location(), issue.Severity, issue.Message)\n    } else {\n        // Fallback to JSON path\n        fmt.Printf(\"%s: %s: %s\\n\", issue.Path, issue.Severity, issue.Message)\n    }\n}\n</code></pre> <p>The <code>Location()</code> method returns the IDE-friendly <code>file:line:column</code> format. The <code>HasLocation()</code> method checks if line info is available (returns <code>true</code> when <code>Line &gt; 0</code>).</p> <p>Back to top</p>"},{"location":"packages/generator/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/generator/#generator-fields","title":"Generator Fields","text":"<pre><code>type Generator struct {\n    // Package name for generated code (default: \"api\")\n    PackageName string\n\n    // Generation modes\n    GenerateClient bool\n    GenerateServer bool\n    GenerateTypes  bool  // Auto-enabled with client or server\n\n    // Type options\n    UsePointers       bool  // Pointer types for optional fields (default: true)\n    IncludeValidation bool  // Validation tags on structs (default: true)\n\n    // Behavior\n    StrictMode  bool  // Fail on any issues\n    IncludeInfo bool  // Include informational messages\n\n    // File splitting\n    MaxLinesPerFile      int   // Default: 2000, 0 = no limit\n    MaxTypesPerFile      int   // Default: 200\n    MaxOperationsPerFile int   // Default: 100\n    SplitByTag           bool  // Default: true\n    SplitByPathPrefix    bool  // Default: true\n\n    // Security options\n    GenerateSecurity        bool  // Default: true when GenerateClient\n    GenerateOAuth2Flows     bool\n    GenerateCredentialMgmt  bool\n    GenerateSecurityEnforce bool\n    GenerateOIDCDiscovery   bool\n    GenerateReadme          bool  // Default: true\n}\n</code></pre>"},{"location":"packages/generator/#available-options","title":"Available Options","text":"Option Description <code>WithFilePath(string)</code> Input specification path or URL <code>WithParsed(ParseResult)</code> Pre-parsed specification <code>WithPackageName(string)</code> Go package name <code>WithClient(bool)</code> Enable client generation <code>WithServer(bool)</code> Enable server generation <code>WithTypes(bool)</code> Enable types-only generation <code>WithSecurity(bool)</code> Enable security helpers <code>WithOAuth2Flows(bool)</code> Enable OAuth2 flow helpers <code>WithCredentialMgmt(bool)</code> Enable credential management <code>WithSecurityEnforce(bool)</code> Enable security enforcement <code>WithOIDCDiscovery(bool)</code> Enable OIDC discovery client <code>WithMaxLinesPerFile(int)</code> File splitting threshold <code>WithSplitByTag(bool)</code> Group operations by tag <code>WithReadme(bool)</code> Generate README.md <code>WithServerResponses(bool)</code> Generate typed response writers <code>WithServerBinder(bool)</code> Generate request parameter binding <code>WithServerMiddleware(bool)</code> Generate validation middleware <code>WithServerRouter(string)</code> Generate HTTP router (\"stdlib\", \"chi\") <code>WithServerStubs(bool)</code> Generate stub server for testing <code>WithServerEmbedSpec(bool)</code> Embed the OpenAPI spec in generated code <code>WithServerAll()</code> Enable all server extensions <p>\u2191 Back to top</p>"},{"location":"packages/generator/#generateresult-structure","title":"GenerateResult Structure","text":"<pre><code>type GenerateResult struct {\n    // Files contains all generated files\n    Files []GeneratedFile\n\n    // Version info\n    SourceVersion    string\n    SourceOASVersion parser.OASVersion\n    SourceFormat     parser.SourceFormat\n    PackageName      string\n\n    // Statistics\n    GeneratedTypes      int\n    GeneratedOperations int\n\n    // Timing and size\n    LoadTime      time.Duration\n    GenerateTime  time.Duration\n    SourceSize    int64\n    Stats         parser.DocumentStats\n    Success       bool\n\n    // Issues encountered\n    Issues        []GenerateIssue\n    InfoCount     int\n    WarningCount  int\n    CriticalCount int\n}\n\ntype GeneratedFile struct {\n    Name    string\n    Content []byte\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/generator/#best-practices","title":"Best Practices","text":"<p>Always validate before generating to ensure your specification is correct. Generation from invalid specs may produce incorrect or incomplete code.</p> <p>Use meaningful operation IDs in your OpenAPI spec. These become method names in the generated client and server interfaces.</p> <p>Choose pointer usage based on your needs. Pointers for optional fields (<code>UsePointers: true</code>) allows distinguishing between \"not set\" and \"set to zero value\", but requires nil checks. Value types are simpler but lose this distinction.</p> <p>Enable security helpers when generating clients to get type-safe authentication configuration rather than manually setting headers.</p> <p>Use file splitting for large APIs to improve compilation times and code organization. The default thresholds work well for most cases.</p> <p>Keep generated code in a separate package from your hand-written code. This makes regeneration safe and keeps the boundary clear.</p> <p>Commit generated code to version control so that consumers don't need the generator installed. Tag generated files with <code>// Code generated by oastools. DO NOT EDIT.</code></p> <p>Use the README generation feature to provide usage documentation alongside the generated code.</p>"},{"location":"packages/generator/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udda5\ufe0f Server extensions example - Full server framework generation</li> <li>\ud83d\udd00 Server router example - HTTP routing generation</li> <li>\ud83e\udd8a Chi router example - Chi framework support</li> <li>\ud83e\uddea Server stubs example - Test stub generation</li> </ul>"},{"location":"packages/generator/#full-working-examples","title":"Full Working Examples","text":"<p>The <code>examples/</code> directory contains complete, generated modules you can browse:</p> <ul> <li>examples/petstore/ - Full client/server with OAuth2 flows, OIDC discovery, credential management, security enforcement, and all server extensions generated from the Swagger Petstore API</li> </ul>"},{"location":"packages/httpvalidator/","title":"HTTP Validator","text":""},{"location":"packages/httpvalidator/#http-validator-package-deep-dive","title":"HTTP Validator Package Deep Dive","text":""},{"location":"packages/httpvalidator/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Parameter Deserialization</li> <li>Schema Validation</li> <li>Middleware Integration</li> <li>Validation Result Structure</li> <li>Configuration Reference</li> <li>Best Practices</li> </ul> <p>The <code>httpvalidator</code> package validates HTTP requests and responses against OpenAPI Specification documents at runtime. It enables API gateways, middleware, and testing frameworks to enforce API contracts, ensuring that HTTP traffic conforms to the declared specification.</p>"},{"location":"packages/httpvalidator/#overview","title":"Overview","text":"<p>Runtime HTTP validation catches contract violations before they reach application logic. The httpvalidator package supports both request validation (incoming traffic) and response validation (outgoing traffic), with comprehensive parameter deserialization and JSON Schema validation.</p> <p>The validator supports OAS 2.0 (Swagger) through OAS 3.2, automatically adapting its behavior to match the specification version. It handles all OAS parameter serialization styles (simple, form, matrix, label, deepObject, spaceDelimited, pipeDelimited) and performs schema validation for request and response bodies.</p> <p>Key features include:</p> <ul> <li>Request validation: Path parameters, query parameters, headers, cookies, request body</li> <li>Response validation: Status codes, headers, response body</li> <li>Parameter deserialization: Automatic type conversion according to OAS style and schema</li> <li>Schema validation: Type checking, constraints (min/max, pattern, enum), composition (allOf/anyOf/oneOf)</li> <li>Middleware-friendly API: Designed for use with standard <code>net/http</code> patterns</li> <li>Strict mode: Optionally reject unknown parameters and undocumented responses</li> </ul> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/httpvalidator/#request-vs-response-validation","title":"Request vs Response Validation","text":"<p>Request validation examines incoming HTTP requests against the specification's path and operation definitions. It verifies that:</p> <ul> <li>The request path matches a defined path template</li> <li>The HTTP method is supported for that path</li> <li>All required path, query, header, and cookie parameters are present</li> <li>Parameter values match their declared types and constraints</li> <li>The request body (if present) matches the declared schema</li> </ul> <p>Response validation checks outgoing HTTP responses against the operation's response definitions. It ensures that:</p> <ul> <li>The response status code is documented in the operation</li> <li>Response headers match declared headers</li> <li>The response body conforms to the declared schema for that status code</li> </ul>"},{"location":"packages/httpvalidator/#validation-vs-deserialization","title":"Validation vs Deserialization","text":"<p>The validator performs two distinct operations:</p> <p>Deserialization converts raw parameter strings into typed values according to the OAS parameter style and schema. For example, a query parameter <code>?tags=foo,bar,baz</code> with style <code>form</code> and <code>explode: false</code> deserializes to <code>[]string{\"foo\", \"bar\", \"baz\"}</code>.</p> <p>Validation then checks the deserialized values against the parameter's schema constraints (type, format, minimum, maximum, pattern, enum, etc.).</p> <p>Deserialized values are available in the validation result for use by your application, eliminating the need for manual parameter parsing.</p>"},{"location":"packages/httpvalidator/#strict-mode","title":"Strict Mode","text":"<p>By default, the validator is permissive: it validates declared parameters but allows undeclared parameters to pass through. This accommodates real-world scenarios where clients send extra headers or where responses include additional status codes not documented in the specification.</p> <p>Strict mode changes this behavior:</p> <ul> <li>Unknown query parameters: Rejected (error)</li> <li>Unknown headers: Rejected (error), except for standard HTTP headers like <code>Content-Type</code>, <code>Content-Length</code>, <code>User-Agent</code></li> <li>Unknown cookies: Rejected (error)</li> <li>Undocumented response status codes: Rejected (error)</li> </ul> <p>Use strict mode when you need exact contract enforcement, such as in testing scenarios or strict API gateway policies.</p>"},{"location":"packages/httpvalidator/#path-matching-specificity","title":"Path Matching Specificity","text":"<p>See also: PathMatcher example, PathMatcherSet example on pkg.go.dev</p> <p>When multiple path templates could match a request (e.g., <code>/users/123</code> could match both <code>/users/{id}</code> and <code>/users/new</code>), the validator uses specificity-based ordering following OpenAPI best practices:</p> <ol> <li>Static paths (no parameters) have highest priority</li> <li>Paths with fewer parameters have higher priority</li> <li>Paths with more static segments have higher priority</li> </ol> <p>This ensures that <code>/users/new</code> (static) matches before <code>/users/{id}</code> (parameterized).</p> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#api-styles","title":"API Styles","text":""},{"location":"packages/httpvalidator/#functional-options-api","title":"Functional Options API","text":"<p>Best for one-off validations with inline configuration:</p> <pre><code>result, err := httpvalidator.ValidateRequestWithOptions(\n    req,\n    httpvalidator.WithFilePath(\"openapi.yaml\"),\n    httpvalidator.WithStrictMode(true),\n)\n</code></pre>"},{"location":"packages/httpvalidator/#struct-based-api","title":"Struct-Based API","text":"<p>See also: New validator example on pkg.go.dev</p> <p>Best for reusable validators in middleware or long-running services:</p> <pre><code>// Parse specification once at startup\nparsed, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n)\n\n// Create validator instance\nv, _ := httpvalidator.New(parsed)\nv.StrictMode = true\n\n// Reuse for all requests\nresult1, _ := v.ValidateRequest(req1)\nresult2, _ := v.ValidateRequest(req2)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#practical-examples","title":"Practical Examples","text":"<p>See also: Request validation example, Invalid request example, Response validation example on pkg.go.dev</p>"},{"location":"packages/httpvalidator/#basic-request-validation","title":"Basic Request Validation","text":"<p>Validate an incoming HTTP request against the specification:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    // Parse specification\n    parsed, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create validator\n    v, err := httpvalidator.New(parsed)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create sample request\n    req, _ := http.NewRequest(\"GET\", \"/users/123?page=1&amp;limit=10\", nil)\n\n    // Validate request\n    result, err := v.ValidateRequest(req)\n    if err != nil {\n        log.Fatalf(\"Validation failed: %v\", err)\n    }\n\n    if result.Valid {\n        fmt.Println(\"\u2713 Request is valid\")\n        fmt.Printf(\"  Path params: %v\\n\", result.PathParams)\n        fmt.Printf(\"  Query params: %v\\n\", result.QueryParams)\n    } else {\n        fmt.Println(\"\u2717 Request validation failed:\")\n        for _, e := range result.Errors {\n            fmt.Printf(\"  [%s] %s: %s\\n\", e.Severity, e.Path, e.Message)\n        }\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#response-validation-in-middleware","title":"Response Validation in Middleware","text":"<p>Validate responses using captured response data:</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n)\n\n// ResponseRecorder captures response data for validation\ntype ResponseRecorder struct {\n    http.ResponseWriter\n    StatusCode int\n    Body       *bytes.Buffer\n}\n\nfunc (r *ResponseRecorder) WriteHeader(code int) {\n    r.StatusCode = code\n    r.ResponseWriter.WriteHeader(code)\n}\n\nfunc (r *ResponseRecorder) Write(b []byte) (int, error) {\n    r.Body.Write(b)\n    return r.ResponseWriter.Write(b)\n}\n\n// ValidationMiddleware validates both requests and responses\nfunc ValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            // Validate request\n            reqResult, _ := v.ValidateRequest(r)\n            if !reqResult.Valid {\n                http.Error(w, \"Invalid request\", http.StatusBadRequest)\n                return\n            }\n\n            // Record response for validation\n            recorder := &amp;ResponseRecorder{\n                ResponseWriter: w,\n                StatusCode:     http.StatusOK,\n                Body:           new(bytes.Buffer),\n            }\n\n            // Call next handler\n            next.ServeHTTP(recorder, r)\n\n            // Validate response\n            respResult, _ := v.ValidateResponseData(\n                r,\n                recorder.StatusCode,\n                recorder.Header(),\n                recorder.Body.Bytes(),\n            )\n\n            if !respResult.Valid {\n                // Log validation failures\n                for _, e := range respResult.Errors {\n                    log.Printf(\"Response validation error: %s\", e.Message)\n                }\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#request-body-validation","title":"Request Body Validation","text":"<p>Validate JSON request bodies against schemas:</p> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    parsed, _ := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n    v, _ := httpvalidator.New(parsed)\n\n    // Create request with JSON body\n    body := bytes.NewBufferString(`{\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"age\": 30\n    }`)\n\n    req, _ := http.NewRequest(\"POST\", \"/users\", body)\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    // Validate request (including body schema)\n    result, err := v.ValidateRequest(req)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if result.Valid {\n        fmt.Println(\"\u2713 Request body is valid\")\n    } else {\n        fmt.Println(\"\u2717 Request body validation failed:\")\n        for _, e := range result.Errors {\n            fmt.Printf(\"  %s: %s\\n\", e.Path, e.Message)\n        }\n    }\n}\n</code></pre> <p>Example OpenAPI Specification:</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: User API\n  version: 1.0.0\npaths:\n  /users:\n    post:\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [name, email]\n              properties:\n                name:\n                  type: string\n                  minLength: 1\n                email:\n                  type: string\n                  format: email\n                age:\n                  type: integer\n                  minimum: 0\n                  maximum: 150\n</code></pre>"},{"location":"packages/httpvalidator/#parameter-validation-with-type-conversion","title":"Parameter Validation with Type Conversion","text":"<p>Access deserialized and validated parameters:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    parsed, _ := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n    v, _ := httpvalidator.New(parsed)\n\n    // Request with various parameter types\n    req, _ := http.NewRequest(\n        \"GET\",\n        \"/users/123/posts?published=true&amp;limit=10&amp;tags=golang,api\",\n        nil,\n    )\n    req.Header.Set(\"X-API-Version\", \"v1\")\n\n    result, err := v.ValidateRequest(req)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if result.Valid {\n        // Access typed, deserialized parameters\n        userID := result.PathParams[\"userId\"]       // \"123\" (string)\n        published := result.QueryParams[\"published\"] // true (bool)\n        limit := result.QueryParams[\"limit\"]        // 10 (int)\n        tags := result.QueryParams[\"tags\"]          // []string{\"golang\", \"api\"}\n        apiVersion := result.HeaderParams[\"X-API-Version\"] // \"v1\" (string)\n\n        fmt.Printf(\"User ID: %v (%T)\\n\", userID, userID)\n        fmt.Printf(\"Published: %v (%T)\\n\", published, published)\n        fmt.Printf(\"Limit: %v (%T)\\n\", limit, limit)\n        fmt.Printf(\"Tags: %v (%T)\\n\", tags, tags)\n        fmt.Printf(\"API Version: %v (%T)\\n\", apiVersion, apiVersion)\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#strict-mode-for-contract-enforcement","title":"Strict Mode for Contract Enforcement","text":"<p>Reject requests with undeclared parameters:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc main() {\n    parsed, _ := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n\n    v, _ := httpvalidator.New(parsed)\n    v.StrictMode = true  // Enable strict validation\n\n    // Request with an undeclared query parameter\n    req, _ := http.NewRequest(\n        \"GET\",\n        \"/users?page=1&amp;undeclared=value\",\n        nil,\n    )\n\n    result, _ := v.ValidateRequest(req)\n\n    if !result.Valid {\n        fmt.Println(\"\u2717 Validation failed (strict mode):\")\n        for _, e := range result.Errors {\n            fmt.Printf(\"  %s: %s\\n\", e.Path, e.Message)\n        }\n        // Output:\n        // \u2717 Validation failed (strict mode):\n        //   query.undeclared: unknown query parameter 'undeclared'\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#functional-options-for-one-off-validation","title":"Functional Options for One-Off Validation","text":"<p>See also: Functional options example on pkg.go.dev</p> <p>Use functional options when you don't need a reusable validator:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n)\n\nfunc main() {\n    req, _ := http.NewRequest(\"GET\", \"/users/123\", nil)\n\n    // Validate without creating a validator instance\n    result, err := httpvalidator.ValidateRequestWithOptions(\n        req,\n        httpvalidator.WithFilePath(\"openapi.yaml\"),\n        httpvalidator.WithStrictMode(true),\n        httpvalidator.WithIncludeWarnings(true),\n    )\n\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Valid: %v\\n\", result.Valid)\n}\n</code></pre>"},{"location":"packages/httpvalidator/#integration-with-testing","title":"Integration with Testing","text":"<p>Use httpvalidator in API tests to verify request/response conformance:</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n\n    \"github.com/erraggy/oastools/httpvalidator\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\nfunc TestAPIConformance(t *testing.T) {\n    // Parse specification once for all tests\n    parsed, _ := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n    v, _ := httpvalidator.New(parsed)\n    v.StrictMode = true\n\n    // Test request validation\n    req := httptest.NewRequest(\"GET\", \"/users/123\", nil)\n    result, err := v.ValidateRequest(req)\n    if err != nil {\n        t.Fatalf(\"Validation error: %v\", err)\n    }\n    if !result.Valid {\n        t.Errorf(\"Request validation failed: %v\", result.Errors)\n    }\n\n    // Test response validation\n    recorder := httptest.NewRecorder()\n    recorder.WriteHeader(http.StatusOK)\n    recorder.Write([]byte(`{\"id\": \"123\", \"name\": \"John\"}`))\n    recorder.Header().Set(\"Content-Type\", \"application/json\")\n\n    respResult, _ := v.ValidateResponseData(\n        req,\n        recorder.Code,\n        recorder.Header(),\n        recorder.Body.Bytes(),\n    )\n\n    if !respResult.Valid {\n        t.Errorf(\"Response validation failed: %v\", respResult.Errors)\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#parameter-deserialization","title":"Parameter Deserialization","text":"<p>The validator automatically deserializes parameters according to their OpenAPI style and schema definition. Understanding the deserialization rules helps you configure your specification correctly and interpret validation results.</p>"},{"location":"packages/httpvalidator/#style-reference","title":"Style Reference","text":"Location Default Style Supported Styles path simple simple, label, matrix query form form, spaceDelimited, pipeDelimited, deepObject header simple simple cookie form form"},{"location":"packages/httpvalidator/#simple-style","title":"Simple Style","text":"<p>Simple style (default for path and header parameters) serializes values without prefixes or delimiters.</p> <p>Primitive values:</p> <pre><code>param=value          \u2192 \"value\"\n</code></pre> <p>Array with explode=false:</p> <pre><code>param=red,green,blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Array with explode=true:</p> <pre><code>param=red&amp;param=green&amp;param=blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Object with explode=false:</p> <pre><code>param=role,admin,enabled,true \u2192 map[string]interface{}{\"role\": \"admin\", \"enabled\": \"true\"}\n</code></pre> <p>Object with explode=true:</p> <pre><code>role=admin&amp;enabled=true \u2192 map[string]interface{}{\"role\": \"admin\", \"enabled\": \"true\"}\n</code></pre>"},{"location":"packages/httpvalidator/#form-style","title":"Form Style","text":"<p>Form style (default for query and cookie parameters) uses ampersand-separated key-value pairs.</p> <p>Primitive values:</p> <pre><code>param=value \u2192 \"value\"\n</code></pre> <p>Array with explode=false:</p> <pre><code>param=red,green,blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Array with explode=true:</p> <pre><code>param=red&amp;param=green&amp;param=blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Object with explode=true:</p> <pre><code>role=admin&amp;enabled=true \u2192 map[string]interface{}{\"role\": \"admin\", \"enabled\": \"true\"}\n</code></pre>"},{"location":"packages/httpvalidator/#matrix-style","title":"Matrix Style","text":"<p>Matrix style (path parameters only) uses semicolon-prefixed parameters.</p> <p>Primitive values:</p> <pre><code>;param=value \u2192 \"value\"\n</code></pre> <p>Array with explode=false:</p> <pre><code>;param=red,green,blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Array with explode=true:</p> <pre><code>;param=red;param=green;param=blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre>"},{"location":"packages/httpvalidator/#label-style","title":"Label Style","text":"<p>Label style (path parameters only) uses dot-prefixed parameters.</p> <p>Primitive values:</p> <pre><code>.value \u2192 \"value\"\n</code></pre> <p>Array with explode=false:</p> <pre><code>.red.green.blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>Array with explode=true:</p> <pre><code>.red.green.blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre>"},{"location":"packages/httpvalidator/#deepobject-style","title":"DeepObject Style","text":"<p>DeepObject style (query parameters only) uses bracket notation for nested objects.</p> <p>Nested object:</p> <pre><code>filter[name]=John&amp;filter[age]=30 \u2192 map[string]interface{}{\"name\": \"John\", \"age\": \"30\"}\n</code></pre> <p>This style is particularly useful for complex query parameters representing structured data.</p>"},{"location":"packages/httpvalidator/#spacedelimited-and-pipedelimited-styles","title":"SpaceDelimited and PipeDelimited Styles","text":"<p>SpaceDelimited and PipeDelimited (query parameters only) use space or pipe as array delimiters.</p> <p>SpaceDelimited:</p> <pre><code>tags=red%20green%20blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre> <p>PipeDelimited:</p> <pre><code>tags=red|green|blue \u2192 []string{\"red\", \"green\", \"blue\"}\n</code></pre>"},{"location":"packages/httpvalidator/#type-coercion","title":"Type Coercion","text":"<p>After deserialization, the validator performs type coercion based on the parameter's schema:</p> <ul> <li>string: No conversion (raw string value)</li> <li>integer: Parsed with <code>strconv.Atoi</code></li> <li>number: Parsed with <code>strconv.ParseFloat</code></li> <li>boolean: Parsed with <code>strconv.ParseBool</code> (accepts \"true\", \"false\", \"1\", \"0\")</li> <li>array: Elements are recursively type-coerced based on the array item schema</li> <li>object: Properties are recursively type-coerced based on their schemas</li> </ul> <p>If type coercion fails (e.g., \"abc\" cannot be parsed as an integer), a validation error is added.</p> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#schema-validation","title":"Schema Validation","text":"<p>The validator includes a minimal JSON Schema implementation that validates request and response bodies against their declared schemas. This implementation focuses on the JSON Schema features commonly used in OpenAPI specifications.</p>"},{"location":"packages/httpvalidator/#supported-schema-features","title":"Supported Schema Features","text":"<p>Type Validation:</p> <ul> <li>Primitive types: <code>string</code>, <code>number</code>, <code>integer</code>, <code>boolean</code>, <code>null</code></li> <li>Structured types: <code>array</code>, <code>object</code></li> <li>OAS 3.1 type arrays: <code>type: [\"string\", \"null\"]</code></li> <li>OAS 3.0 nullable: <code>nullable: true</code></li> </ul> <p>String Constraints:</p> <ul> <li><code>minLength</code>, <code>maxLength</code></li> <li><code>pattern</code> (regex validation)</li> <li><code>format</code> (email, uri, uuid, date-time, date, etc.)</li> <li><code>enum</code> (allowed values)</li> </ul> <p>Number Constraints:</p> <ul> <li><code>minimum</code>, <code>maximum</code></li> <li><code>exclusiveMinimum</code>, <code>exclusiveMaximum</code></li> <li><code>multipleOf</code></li> </ul> <p>Array Constraints:</p> <ul> <li><code>minItems</code>, <code>maxItems</code></li> <li><code>uniqueItems</code></li> <li><code>items</code> (schema for array elements)</li> </ul> <p>Object Constraints:</p> <ul> <li><code>required</code> (required property names)</li> <li><code>properties</code> (property schemas)</li> <li><code>additionalProperties</code> (schema for undeclared properties, or boolean to allow/disallow)</li> <li><code>minProperties</code>, <code>maxProperties</code></li> </ul> <p>Composition:</p> <ul> <li><code>allOf</code> (must match all schemas)</li> <li><code>anyOf</code> (must match at least one schema)</li> <li><code>oneOf</code> (must match exactly one schema)</li> </ul> <p>References:</p> <ul> <li><code>$ref</code> (references to component schemas)</li> </ul>"},{"location":"packages/httpvalidator/#validation-behavior","title":"Validation Behavior","text":"<p>Type checking validates that the data type matches the declared type. For OAS 3.1, type can be an array (e.g., <code>[\"string\", \"null\"]</code>), allowing multiple types.</p> <p>Constraint checking validates that values meet their declared constraints. For example, a string with <code>minLength: 5</code> must have at least 5 characters.</p> <p>Format validation performs limited format checking for common formats:</p> <ul> <li><code>email</code>: Basic email pattern</li> <li><code>uri</code>: URL format check</li> <li><code>uuid</code>: UUID v4 pattern</li> <li><code>date-time</code>, <code>date</code>, <code>time</code>: ISO 8601 format</li> </ul> <p>Composition applies all composition rules:</p> <ul> <li><code>allOf</code>: Value must validate against every schema in the array</li> <li><code>anyOf</code>: Value must validate against at least one schema in the array</li> <li><code>oneOf</code>: Value must validate against exactly one schema (not zero, not multiple)</li> </ul> <p>Recursion handles nested schemas for objects and arrays. The validator recursively descends into properties and array items to validate nested structures.</p>"},{"location":"packages/httpvalidator/#schema-validation-example","title":"Schema Validation Example","text":"<pre><code>openapi: 3.0.3\npaths:\n  /products:\n    post:\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [name, price]\n              properties:\n                name:\n                  type: string\n                  minLength: 3\n                  maxLength: 100\n                price:\n                  type: number\n                  minimum: 0\n                  exclusiveMinimum: true\n                tags:\n                  type: array\n                  items:\n                    type: string\n                  minItems: 1\n                  uniqueItems: true\n</code></pre> <p>Valid request body:</p> <pre><code>{\n  \"name\": \"Widget\",\n  \"price\": 19.99,\n  \"tags\": [\"electronics\", \"gadgets\"]\n}\n</code></pre> <p>Invalid request body (multiple violations):</p> <pre><code>{\n  \"name\": \"AB\",           // Too short (minLength: 3)\n  \"price\": 0,             // Not greater than 0 (exclusiveMinimum: true)\n  \"tags\": []              // Too few items (minItems: 1)\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#middleware-integration","title":"Middleware Integration","text":"<p>The httpvalidator package is designed for seamless integration with standard Go middleware patterns. This section demonstrates common middleware scenarios.</p>"},{"location":"packages/httpvalidator/#request-validation-middleware","title":"Request Validation Middleware","text":"<p>Validate all incoming requests before they reach handlers:</p> <pre><code>func RequestValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            result, err := v.ValidateRequest(r)\n            if err != nil {\n                http.Error(w, \"Internal validation error\", http.StatusInternalServerError)\n                return\n            }\n\n            if !result.Valid {\n                // Return 400 Bad Request with validation errors\n                w.Header().Set(\"Content-Type\", \"application/json\")\n                w.WriteHeader(http.StatusBadRequest)\n                json.NewEncoder(w).Encode(map[string]interface{}{\n                    \"error\": \"Validation failed\",\n                    \"details\": result.Errors,\n                })\n                return\n            }\n\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#response-validation-middleware","title":"Response Validation Middleware","text":"<p>Validate responses before sending them to clients:</p> <pre><code>type ResponseRecorder struct {\n    http.ResponseWriter\n    StatusCode int\n    Body       *bytes.Buffer\n    Headers    http.Header\n}\n\nfunc NewResponseRecorder(w http.ResponseWriter) *ResponseRecorder {\n    return &amp;ResponseRecorder{\n        ResponseWriter: w,\n        StatusCode:     http.StatusOK,\n        Body:           new(bytes.Buffer),\n        Headers:        make(http.Header),\n    }\n}\n\nfunc (r *ResponseRecorder) WriteHeader(code int) {\n    r.StatusCode = code\n    for k, v := range r.ResponseWriter.Header() {\n        r.Headers[k] = v\n    }\n    r.ResponseWriter.WriteHeader(code)\n}\n\nfunc (r *ResponseRecorder) Write(b []byte) (int, error) {\n    r.Body.Write(b)\n    return r.ResponseWriter.Write(b)\n}\n\nfunc ResponseValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            recorder := NewResponseRecorder(w)\n\n            next.ServeHTTP(recorder, r)\n\n            // Validate response after handler completes\n            result, err := v.ValidateResponseData(\n                r,\n                recorder.StatusCode,\n                recorder.Headers,\n                recorder.Body.Bytes(),\n            )\n\n            if err != nil || !result.Valid {\n                log.Printf(\"Response validation failed for %s %s: %v\",\n                    r.Method, r.URL.Path, result.Errors)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#combined-request-and-response-validation","title":"Combined Request and Response Validation","text":"<p>Validate both directions in a single middleware:</p> <pre><code>func ValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            // Validate request\n            reqResult, err := v.ValidateRequest(r)\n            if err != nil || !reqResult.Valid {\n                w.WriteHeader(http.StatusBadRequest)\n                json.NewEncoder(w).Encode(map[string]interface{}{\n                    \"error\": \"Invalid request\",\n                    \"details\": reqResult.Errors,\n                })\n                return\n            }\n\n            // Record response\n            recorder := NewResponseRecorder(w)\n            next.ServeHTTP(recorder, r)\n\n            // Validate response\n            respResult, _ := v.ValidateResponseData(\n                r,\n                recorder.StatusCode,\n                recorder.Headers,\n                recorder.Body.Bytes(),\n            )\n\n            if !respResult.Valid {\n                log.Printf(\"Response validation failed: %v\", respResult.Errors)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"packages/httpvalidator/#passing-validated-parameters-to-handlers","title":"Passing Validated Parameters to Handlers","text":"<p>Store validated and deserialized parameters in the request context:</p> <pre><code>type contextKey string\n\nconst validatedParamsKey contextKey = \"validatedParams\"\n\ntype ValidatedParams struct {\n    PathParams   map[string]interface{}\n    QueryParams  map[string]interface{}\n    HeaderParams map[string]interface{}\n    CookieParams map[string]interface{}\n}\n\nfunc ValidationMiddleware(v *httpvalidator.Validator) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            result, err := v.ValidateRequest(r)\n            if err != nil || !result.Valid {\n                http.Error(w, \"Invalid request\", http.StatusBadRequest)\n                return\n            }\n\n            // Store validated params in context\n            params := &amp;ValidatedParams{\n                PathParams:   result.PathParams,\n                QueryParams:  result.QueryParams,\n                HeaderParams: result.HeaderParams,\n                CookieParams: result.CookieParams,\n            }\n\n            ctx := context.WithValue(r.Context(), validatedParamsKey, params)\n            next.ServeHTTP(w, r.WithContext(ctx))\n        })\n    }\n}\n\n// In your handler\nfunc GetUserHandler(w http.ResponseWriter, r *http.Request) {\n    params := r.Context().Value(validatedParamsKey).(*ValidatedParams)\n    userID := params.PathParams[\"userId\"].(string)\n\n    // Use the validated, typed parameter\n    user, _ := getUserByID(userID)\n    json.NewEncoder(w).Encode(user)\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#validation-result-structure","title":"Validation Result Structure","text":"<p>Request and response validation return separate result types, each tailored to their context.</p>"},{"location":"packages/httpvalidator/#requestvalidationresult","title":"RequestValidationResult","text":"<pre><code>// RequestValidationResult contains the results of validating an HTTP request\n// against an OpenAPI specification.\ntype RequestValidationResult struct {\n    // Valid is true if the request passes all validation checks.\n    Valid bool\n\n    // Errors contains all validation errors found.\n    Errors []ValidationError\n\n    // Warnings contains best-practice warnings (if IncludeWarnings is enabled).\n    Warnings []ValidationError\n\n    // MatchedPath is the OpenAPI path template that matched the request\n    // (e.g., \"/pets/{petId}\"). Empty if no path matched.\n    MatchedPath string\n\n    // MatchedMethod is the HTTP method of the request (e.g., \"GET\", \"POST\").\n    MatchedMethod string\n\n    // PathParams contains the extracted and validated path parameters.\n    // Keys are parameter names, values are the deserialized values.\n    PathParams map[string]any\n\n    // QueryParams contains the extracted and validated query parameters.\n    QueryParams map[string]any\n\n    // HeaderParams contains the extracted and validated header parameters.\n    HeaderParams map[string]any\n\n    // CookieParams contains the extracted and validated cookie parameters.\n    CookieParams map[string]any\n}\n</code></pre>"},{"location":"packages/httpvalidator/#responsevalidationresult","title":"ResponseValidationResult","text":"<pre><code>// ResponseValidationResult contains the results of validating an HTTP response\n// against an OpenAPI specification.\ntype ResponseValidationResult struct {\n    // Valid is true if the response passes all validation checks.\n    Valid bool\n\n    // Errors contains all validation errors found.\n    Errors []ValidationError\n\n    // Warnings contains best-practice warnings (if IncludeWarnings is enabled).\n    Warnings []ValidationError\n\n    // StatusCode is the HTTP status code of the response.\n    StatusCode int\n\n    // ContentType is the Content-Type of the response.\n    ContentType string\n\n    // MatchedPath is the OpenAPI path template that matched the original request.\n    MatchedPath string\n\n    // MatchedMethod is the HTTP method of the original request.\n    MatchedMethod string\n}\n</code></pre>"},{"location":"packages/httpvalidator/#validationerror","title":"ValidationError","text":"<p><code>ValidationError</code> is a type alias for <code>issues.Issue</code>, providing a unified issue type across oastools packages:</p> <pre><code>// ValidationError is an alias to issues.Issue.\ntype ValidationError = issues.Issue\n\n// The underlying issues.Issue struct has the following fields:\n//   Path     string             // JSON path to the problematic field\n//   Message  string             // Human-readable description\n//   Severity severity.Severity  // Severity level (not a string)\n//   Field    string             // Specific field name\n//   Value    any                // Problematic value (optional)\n//   SpecRef  string             // URL to OAS specification section (optional)\n//   Context  string             // Additional context (optional)\n//   Line     int                // 1-based line number (0 if unknown)\n//   Column   int                // 1-based column number (0 if unknown)\n//   File     string             // Source file path (empty for main document)\n</code></pre> <p>Note that <code>Severity</code> is of type <code>severity.Severity</code>, not <code>string</code>. The httpvalidator package re-exports severity constants for convenience:</p> <pre><code>const (\n    SeverityError    = severity.SeverityError\n    SeverityWarning  = severity.SeverityWarning\n    SeverityInfo     = severity.SeverityInfo\n    SeverityCritical = severity.SeverityCritical\n)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/httpvalidator/#validator-fields","title":"Validator Fields","text":"<pre><code>type Validator struct {\n    // IncludeWarnings determines whether to include best practice warnings\n    // in validation results. Default is true.\n    IncludeWarnings bool\n\n    // StrictMode enables stricter validation behavior:\n    // - Rejects requests with unknown query parameters\n    // - Rejects requests with unknown headers\n    // - Rejects responses with undocumented status codes\n    // Default is false.\n    StrictMode bool\n}\n</code></pre>"},{"location":"packages/httpvalidator/#available-options","title":"Available Options","text":"Option Description <code>WithFilePath(string)</code> Load specification from file path <code>WithParsed(*ParseResult)</code> Use pre-parsed specification <code>WithStrictMode(bool)</code> Enable/disable strict validation <code>WithIncludeWarnings(bool)</code> Include/exclude best practice warnings <code>WithSkipBodyValidation(bool)</code> Skip request/response body validation <code>WithSkipQueryValidation(bool)</code> Skip query parameter validation <code>WithSkipHeaderValidation(bool)</code> Skip header parameter validation <code>WithSkipCookieValidation(bool)</code> Skip cookie parameter validation <code>WithMaxBodySize(int64)</code> Maximum body size to validate (in bytes)"},{"location":"packages/httpvalidator/#usage-examples","title":"Usage Examples","text":"<pre><code>// Functional options API\nresult, err := httpvalidator.ValidateRequestWithOptions(\n    req,\n    httpvalidator.WithFilePath(\"openapi.yaml\"),\n    httpvalidator.WithStrictMode(true),\n)\n\n// Struct-based API\nparsed, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\nv, _ := httpvalidator.New(parsed)\nv.StrictMode = true\nv.IncludeWarnings = true\nresult, _ := v.ValidateRequest(req)\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#best-practices","title":"Best Practices","text":"<p>Parse specifications once at startup. In production services, parse the OpenAPI specification during initialization and create a single Validator instance for reuse. Parsing on every request is inefficient.</p> <p>Use strict mode in testing, permissive mode in production. Strict mode catches contract violations during development and testing. In production, permissive mode accommodates real-world variance (extra headers, additional response codes) without breaking clients.</p> <p>Log response validation failures. Unlike request validation failures (which should return 400 Bad Request), response validation failures indicate bugs in your service. Log these failures for monitoring and debugging.</p> <p>Store validated parameters in request context. The validator deserializes and type-converts parameters for you. Pass these validated values through the request context to avoid duplicate parsing in handlers.</p> <p>Validate responses in integration tests. Use httpvalidator in your test suite to ensure your API implementation matches its specification. This catches discrepancies early.</p> <p>Handle validation errors gracefully. Return structured error responses that help API consumers understand what went wrong. Include the validation error paths and messages in your response body.</p> <p>Be aware of schema validation limitations. The built-in schema validator handles common JSON Schema features but is not a complete implementation. For advanced schema validation (JSON Schema 2020-12 with all keywords), consider integrating a full-featured JSON Schema library.</p> <p>Consider performance for high-throughput services. Path matching and schema validation add latency to request processing. Profile your service under load and consider:</p> <ul> <li>Validating requests but not responses in production (response validation in tests only)</li> <li>Selective validation (validate only critical paths or methods)</li> <li>Asynchronous response validation (log failures without blocking the response)</li> </ul> <p>Update validators when specifications change. If your specification is updated at runtime (dynamic API configurations), recreate the Validator with the new specification. Validators are immutable once created.</p> <p>\u2191 Back to top</p>"},{"location":"packages/httpvalidator/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\u2705 Request validation example - Validate incoming requests</li> <li>\u274c Invalid request example - Handle validation errors</li> <li>\ud83d\udce4 Response validation example - Validate outgoing responses</li> <li>\ud83d\udd00 Path matching examples - Path template matching</li> </ul>"},{"location":"packages/joiner/","title":"Joiner","text":""},{"location":"packages/joiner/#joiner-package-deep-dive","title":"Joiner Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the joiner in your browser \u2192</p>"},{"location":"packages/joiner/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Operation-Aware Schema Renaming</li> <li>Custom Collision Handlers</li> <li>Limitations</li> <li>Configuration Reference</li> <li>JoinResult Structure</li> <li>Source Map Integration</li> <li>Package Chaining</li> <li>Best Practices</li> <li>Common Patterns</li> <li>CLI Usage</li> </ul> <p>The <code>joiner</code> package merges multiple OpenAPI Specification documents into a single unified document. It provides sophisticated collision handling strategies, automatic reference rewriting, and semantic deduplication for large-scale API consolidation scenarios.</p>"},{"location":"packages/joiner/#overview","title":"Overview","text":"<p>When organizations maintain multiple API specifications\u2014whether from different teams, microservices, or API modules\u2014the joiner enables consolidation into a single document. This is particularly valuable for generating unified documentation, client SDKs, or gateway configurations from distributed API definitions.</p> <p>The joiner supports OAS 2.0 documents merging with other 2.0 documents, and all OAS 3.x versions together (3.0.x, 3.1.x, 3.2.x). It uses the version and format (JSON or YAML) from the first document as the result format, ensuring consistency in the output.</p> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/joiner/#collision-handling","title":"Collision Handling","text":"<p>When merging multiple documents, name collisions are inevitable\u2014two documents might define different schemas with the same name, or contain overlapping paths. The joiner provides seven collision strategies to handle these situations:</p> Strategy Behavior <code>StrategyFailOnCollision</code> Return error on any collision (default, safest) <code>StrategyAcceptLeft</code> Keep value from first/left document <code>StrategyAcceptRight</code> Keep value from last/right document (overwrite) <code>StrategyFailOnPaths</code> Fail only on path collisions, allow schema merging <code>StrategyRenameLeft</code> Rename left schema, keep right under original name <code>StrategyRenameRight</code> Rename right schema, keep left under original name <code>StrategyDeduplicateEquivalent</code> Merge structurally identical schemas <p>Strategies can be set globally or per-component type (paths, schemas, other components), giving fine-grained control over merge behavior.</p>"},{"location":"packages/joiner/#collision-handlers","title":"Collision Handlers","text":"<p>For advanced collision handling beyond the built-in strategies, you can register a collision handler callback. The handler is invoked when a collision is detected, receiving full context about both values and their sources. Handlers can:</p> <ol> <li>Observe and log - Return <code>ContinueWithStrategy()</code> to log collisions while deferring to the configured strategy</li> <li>Make decisions - Return <code>AcceptLeft()</code>, <code>AcceptRight()</code>, <code>Rename()</code>, <code>Deduplicate()</code>, or <code>Fail()</code> to override the strategy</li> <li>Provide custom values - Return <code>UseCustomValue(mergedSchema)</code> to supply a custom merged result</li> </ol> <p>If a handler returns an error, the joiner logs a warning and falls back to the configured strategy, ensuring handlers cannot break join operations.</p> <p>See Custom Collision Handlers for complete documentation and examples.</p>"},{"location":"packages/joiner/#semantic-deduplication","title":"Semantic Deduplication","text":"<p>Beyond handling same-named collisions, the joiner can identify and consolidate schemas that are structurally identical but have different names. When your Users API and Orders API both define equivalent <code>Address</code> and <code>Location</code> schemas, semantic deduplication recognizes they're identical and consolidates them.</p>"},{"location":"packages/joiner/#reference-rewriting","title":"Reference Rewriting","text":"<p>When schemas are renamed or deduplicated, all <code>$ref</code> references throughout the merged document are automatically updated. This ensures the resulting document maintains valid internal references without manual intervention.</p> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#api-styles","title":"API Styles","text":"<p>See also: Basic example, Custom strategies example, Semantic deduplication example on pkg.go.dev</p>"},{"location":"packages/joiner/#functional-options-api","title":"Functional Options API","text":"<p>Best for single merge operations with inline configuration:</p> <pre><code>result, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"base.yaml\", \"ext.yaml\"),\n    joiner.WithPathStrategy(joiner.StrategyFailOnCollision),\n    joiner.WithSchemaStrategy(joiner.StrategyAcceptLeft),\n)\n</code></pre>"},{"location":"packages/joiner/#struct-based-api","title":"Struct-Based API","text":"<p>Best for multiple merge operations or complex configuration:</p> <pre><code>config := joiner.DefaultConfig()\nconfig.PathStrategy = joiner.StrategyFailOnPaths\nconfig.SchemaStrategy = joiner.StrategyDeduplicateEquivalent\nconfig.EquivalenceMode = \"deep\"\n\nj := joiner.New(config)\nresult1, _ := j.Join([]string{\"api1-base.yaml\", \"api1-ext.yaml\"})\nresult2, _ := j.Join([]string{\"api2-base.yaml\", \"api2-ext.yaml\"})\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#practical-examples","title":"Practical Examples","text":""},{"location":"packages/joiner/#basic-document-joining","title":"Basic Document Joining","text":"<p>The simplest use case merges two or more documents with default settings:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    outputPath := filepath.Join(os.TempDir(), \"merged.yaml\")\n\n    config := joiner.DefaultConfig()\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\n        \"users-api.yaml\",\n        \"orders-api.yaml\",\n        \"products-api.yaml\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := j.WriteResult(result, outputPath); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Successfully merged %d documents\\n\", 3)\n    fmt.Printf(\"Output version: %s\\n\", result.Version)\n    fmt.Printf(\"Total paths: %d\\n\", result.Stats.PathCount)\n    fmt.Printf(\"Total schemas: %d\\n\", result.Stats.SchemaCount)\n    fmt.Printf(\"Collisions resolved: %d\\n\", result.CollisionCount)\n}\n</code></pre> <p>Example Input (users-api.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Users API\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      operationId: listUsers\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n</code></pre> <p>Example Input (orders-api.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Orders API\n  version: 1.0.0\npaths:\n  /orders:\n    get:\n      operationId: listOrders\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Order'\ncomponents:\n  schemas:\n    Order:\n      type: object\n      properties:\n        id:\n          type: integer\n        userId:\n          type: integer\n</code></pre> <p>Example Output (merged.yaml):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Users API  # Info from first document\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      operationId: listUsers\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/User'\n  /orders:\n    get:\n      operationId: listOrders\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Order'\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n    Order:\n      type: object\n      properties:\n        id:\n          type: integer\n        userId:\n          type: integer\n</code></pre>"},{"location":"packages/joiner/#handling-schema-collisions-with-rename-strategies","title":"Handling Schema Collisions with Rename Strategies","text":"<p>When different APIs define schemas with the same name but different structures, use rename strategies to preserve both:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.DefaultConfig()\n\n    // Keep left schema, rename right schema\n    config.SchemaStrategy = joiner.StrategyRenameRight\n    // Template for renamed schemas: \"User_orders-api\" format\n    config.RenameTemplate = \"{{.Name}}_{{.Source}}\"\n\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\n        \"users-api.yaml\",    // Has User schema (id, name, email)\n        \"orders-api.yaml\",   // Has User schema (id, customerId) - different structure!\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Result will have:\n    // - User (from users-api.yaml, original name)\n    // - User_orders-api (from orders-api.yaml, renamed)\n    // All $refs in orders-api paths are rewritten to User_orders-api\n\n    fmt.Printf(\"Collisions resolved: %d\\n\", result.CollisionCount)\n    for _, warning := range result.Warnings {\n        fmt.Printf(\"  %s\\n\", warning)\n    }\n}\n</code></pre> <p>Example Output:</p> <pre><code>Collisions resolved: 1\n  schema 'User' collision: right renamed to 'User_orders-api'\n</code></pre> <p>Back to top</p>"},{"location":"packages/joiner/#operation-aware-schema-renaming","title":"Operation-Aware Schema Renaming","text":""},{"location":"packages/joiner/#the-problem","title":"The Problem","text":"<p>When joining OpenAPI specifications from different services, you often encounter generic schema names that collide. Consider two microservices:</p> <p>users-service.yaml:</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Users Service\n  version: 1.0.0\npaths:\n  /users:\n    get:\n      operationId: listUsers\n      tags: [users]\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Response'\ncomponents:\n  schemas:\n    Response:\n      type: object\n      properties:\n        data:\n          type: array\n          items:\n            $ref: '#/components/schemas/User'\n        total:\n          type: integer\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n</code></pre> <p>orders-service.yaml:</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Orders Service\n  version: 1.0.0\npaths:\n  /orders:\n    get:\n      operationId: listOrders\n      tags: [orders]\n      responses:\n        '200':\n          description: Success\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Response'\ncomponents:\n  schemas:\n    Response:\n      type: object\n      properties:\n        data:\n          type: array\n          items:\n            $ref: '#/components/schemas/Order'\n        count:\n          type: integer\n    Order:\n      type: object\n      properties:\n        id:\n          type: integer\n        userId:\n          type: integer\n</code></pre> <p>Both services define a <code>Response</code> schema with different structures. A basic rename template like <code>{{.Name}}_{{.Source}}</code> would produce <code>Response_orders_service</code>\u2014functional but not descriptive. For programmatically generated specs or code generation, you want names like <code>ListUsersResponse</code> and <code>ListOrdersResponse</code>.</p>"},{"location":"packages/joiner/#the-solution","title":"The Solution","text":"<p>Operation-aware renaming traces schemas back to their originating operations, enabling semantic names based on paths, methods, operation IDs, and tags:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.DefaultConfig()\n    config.SchemaStrategy = joiner.StrategyRenameRight\n\n    // Enable operation context for rich rename templates\n    config.OperationContext = true\n\n    // Use operation-derived naming\n    config.RenameTemplate = \"{{pascalCase .OperationID}}{{.Name}}\"\n\n    // Select how to pick the primary operation when a schema\n    // is referenced by multiple operations\n    config.PrimaryOperationPolicy = joiner.PolicyMostSpecific\n\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\n        \"users-service.yaml\",\n        \"orders-service.yaml\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Result will have:\n    // - Response (from users-service, kept original)\n    // - ListOrdersResponse (from orders-service, renamed with context)\n\n    fmt.Printf(\"Schemas renamed with operation context\\n\")\n    fmt.Printf(\"Collisions: %d\\n\", result.CollisionCount)\n}\n</code></pre>"},{"location":"packages/joiner/#how-it-works","title":"How It Works","text":"<p>The joiner builds a reference graph that maps each schema to the operations that use it. This graph captures both direct references (operation \u2192 schema) and indirect references (operation \u2192 schema \u2192 nested schema).</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   GET /users    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502    Response     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502      User       \u2502\n\u2502   listUsers     \u2502     \u2502   (schema)      \u2502     \u2502   (schema)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                       \u25b2                       \u25b2\n        \u2502                       \u2502                       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      Reference Graph\n</code></pre> <p>The reference graph construction:</p> <ol> <li>Traverses all paths and operations - Records which schemas are referenced in request bodies, responses, parameters, and headers</li> <li>Tracks schema-to-schema references - Records <code>$ref</code> chains through properties, items, allOf/anyOf/oneOf, and other composition keywords</li> <li>Resolves lineage - For any schema, walks up the reference chain to find all operations that ultimately use it</li> <li>Caches results - Lineage is computed once and cached for efficient template evaluation</li> </ol> <p>When a collision occurs and renaming is needed, the joiner:</p> <ol> <li>Retrieves the operation lineage for the schema</li> <li>Selects a primary operation based on the configured policy</li> <li>Builds a <code>RenameContext</code> with all available operation metadata</li> <li>Executes the rename template with this rich context</li> </ol>"},{"location":"packages/joiner/#renamecontext-reference","title":"RenameContext Reference","text":"<p>The <code>RenameContext</code> provides comprehensive metadata for rename template evaluation:</p>"},{"location":"packages/joiner/#core-fields-always-available","title":"Core Fields (Always Available)","text":"Field Type Description Example <code>Name</code> string Original schema name <code>\"Response\"</code> <code>Source</code> string Source file name (sanitized, no extension) <code>\"orders_service\"</code> <code>Index</code> int Document index (0-based) <code>1</code>"},{"location":"packages/joiner/#operation-context-fields-when-operationcontext-is-true","title":"Operation Context Fields (When <code>OperationContext</code> is true)","text":"Field Type Description Example <code>Path</code> string API path from primary operation <code>\"/orders\"</code> <code>Method</code> string HTTP method (lowercase) <code>\"get\"</code> <code>OperationID</code> string Operation ID if defined <code>\"listOrders\"</code> <code>Tags</code> []string Tags from primary operation <code>[\"orders\"]</code> <code>UsageType</code> string Where schema is used <code>\"response\"</code> <code>StatusCode</code> string Response status code <code>\"200\"</code> <code>ParamName</code> string Parameter name (for parameter usage) <code>\"filter\"</code> <code>MediaType</code> string Content media type <code>\"application/json\"</code> <code>PrimaryResource</code> string First path segment (resource name) <code>\"orders\"</code>"},{"location":"packages/joiner/#aggregate-context-fields-multi-operation-schemas","title":"Aggregate Context Fields (Multi-Operation Schemas)","text":"Field Type Description Example <code>AllPaths</code> []string All paths referencing this schema <code>[\"/orders\", \"/orders/{id}\"]</code> <code>AllMethods</code> []string All HTTP methods (deduplicated) <code>[\"get\", \"post\"]</code> <code>AllOperationIDs</code> []string All operation IDs (non-empty only) <code>[\"listOrders\", \"getOrder\"]</code> <code>AllTags</code> []string All tags (deduplicated, sorted) <code>[\"admin\", \"orders\"]</code> <code>RefCount</code> int Total operation references <code>3</code> <code>IsShared</code> bool True if used by multiple operations <code>true</code>"},{"location":"packages/joiner/#usagetype-values","title":"UsageType Values","text":"Value Description <code>\"request\"</code> Schema used in request body <code>\"response\"</code> Schema used in response body <code>\"parameter\"</code> Schema used in parameter definition <code>\"header\"</code> Schema used in header definition <code>\"callback\"</code> Schema used in callback definition"},{"location":"packages/joiner/#template-functions-reference","title":"Template Functions Reference","text":"<p>The joiner provides built-in template functions for transforming context values:</p>"},{"location":"packages/joiner/#path-functions","title":"Path Functions","text":"Function Description Example Input Example Output <code>pathSegment</code> Extract nth segment (0-indexed, negative from end) <code>pathSegment \"/users/{id}/orders\" 0</code> <code>\"users\"</code> <code>pathSegment</code> Negative index <code>pathSegment \"/users/{id}/orders\" -1</code> <code>\"orders\"</code> <code>pathResource</code> First non-parameter segment <code>pathResource \"/users/{id}/orders\"</code> <code>\"users\"</code> <code>pathLast</code> Last non-parameter segment <code>pathLast \"/users/{id}/orders\"</code> <code>\"orders\"</code> <code>pathClean</code> Sanitize path for naming <code>pathClean \"/users/{id}\"</code> <code>\"users_id\"</code> <p>Path functions automatically skip path parameters (segments like <code>{id}</code> or <code>{userId}</code>).</p>"},{"location":"packages/joiner/#tag-functions","title":"Tag Functions","text":"Function Description Example Input Example Output <code>firstTag</code> First tag or empty string <code>firstTag .Tags</code> <code>\"orders\"</code> <code>joinTags</code> Join tags with separator <code>joinTags .Tags \"_\"</code> <code>\"admin_orders\"</code> <code>hasTag</code> Check if tag exists <code>hasTag .Tags \"admin\"</code> <code>true</code>"},{"location":"packages/joiner/#case-functions","title":"Case Functions","text":"Function Description Example Input Example Output <code>pascalCase</code> PascalCase conversion <code>pascalCase \"list_orders\"</code> <code>\"ListOrders\"</code> <code>camelCase</code> camelCase conversion <code>camelCase \"list_orders\"</code> <code>\"listOrders\"</code> <code>snakeCase</code> snake_case conversion <code>snakeCase \"ListOrders\"</code> <code>\"list_orders\"</code> <code>kebabCase</code> kebab-case conversion <code>kebabCase \"ListOrders\"</code> <code>\"list-orders\"</code> <p>Case functions handle various input formats: <code>snake_case</code>, <code>kebab-case</code>, <code>camelCase</code>, <code>PascalCase</code>, and space-separated words.</p>"},{"location":"packages/joiner/#conditional-helpers","title":"Conditional Helpers","text":"Function Description Example <code>default</code> Return fallback if value empty <code>default .OperationID \"Unknown\"</code> <code>coalesce</code> First non-empty value <code>coalesce .OperationID .Path .Name</code>"},{"location":"packages/joiner/#primary-operation-policy","title":"Primary Operation Policy","text":"<p>When a schema is referenced by multiple operations, the joiner must select one as the \"primary\" operation for template context. Three policies are available:</p> Policy Behavior Best For <code>PolicyFirstEncountered</code> Uses the first operation found during graph traversal Deterministic results based on document order <code>PolicyMostSpecific</code> Prefers operations with operationId, then those with tags Well-documented APIs with operation IDs <code>PolicyAlphabetical</code> Sorts by path+method, uses alphabetically first Reproducible builds regardless of traversal order <p>Example: Policy behavior with a shared schema</p> <p>Consider an <code>Address</code> schema used by three operations:</p> <pre><code>paths:\n  /users/{id}:\n    get:\n      operationId: getUser\n      tags: [users]\n  /orders:\n    post:\n      operationId: createOrder\n      tags: [orders]\n  /shipping:\n    get:\n      # No operationId\n      tags: [shipping]\n</code></pre> Policy Selected Operation Reason <code>PolicyFirstEncountered</code> GET /users/{id} First in document order <code>PolicyMostSpecific</code> GET /users/{id} Has operationId (both GET /users and POST /orders do, but GET comes first) <code>PolicyAlphabetical</code> POST /orders \"/orders\" + \"post\" comes before \"/shipping\" + \"get\" and \"/users/{id}\" + \"get\" <p>Configure the policy in your joiner config:</p> <pre><code>config := joiner.DefaultConfig()\nconfig.OperationContext = true\nconfig.PrimaryOperationPolicy = joiner.PolicyMostSpecific\n</code></pre>"},{"location":"packages/joiner/#example-template-patterns","title":"Example Template Patterns","text":"<p>Common rename template patterns for different scenarios:</p> Scenario Template Example Output Operation ID prefix <code>{{pascalCase .OperationID}}{{.Name}}</code> <code>ListOrdersResponse</code> Resource-based <code>{{pascalCase (pathResource .Path)}}{{.Name}}</code> <code>OrdersResponse</code> Tag-based <code>{{pascalCase (firstTag .Tags)}}{{.Name}}</code> <code>OrdersResponse</code> Method + resource <code>{{pascalCase .Method}}{{pascalCase (pathResource .Path)}}{{.Name}}</code> <code>GetOrdersResponse</code> Full path <code>{{pascalCase (pathClean .Path)}}{{.Name}}</code> <code>OrdersIdResponse</code> With fallback <code>{{pascalCase (coalesce .OperationID (pathResource .Path) .Source)}}{{.Name}}</code> <code>ListOrdersResponse</code> Versioned API <code>{{.Name}}_{{pathSegment .Path 0}}_{{.Source}}</code> <code>Response_v2_orders</code> Response codes <code>{{pascalCase .OperationID}}{{.StatusCode}}{{.Name}}</code> <code>ListOrders200Response</code> Shared indicator <code>{{if .IsShared}}Shared{{end}}{{.Name}}_{{.Source}}</code> <code>SharedResponse_orders</code>"},{"location":"packages/joiner/#handling-shared-schemas","title":"Handling Shared Schemas","text":"<p>Schemas referenced by multiple operations require special consideration. Use the <code>IsShared</code> field to detect and handle these cases:</p> <pre><code>// Template that indicates shared schemas\nconfig.RenameTemplate = `{{if .IsShared}}Common{{else}}{{pascalCase .OperationID}}{{end}}{{.Name}}`\n\n// Results:\n// - Schema used by one operation: \"ListOrdersResponse\"\n// - Schema used by multiple operations: \"CommonResponse\"\n</code></pre> <p>For more granular control, use aggregate fields:</p> <pre><code>// Use all operation IDs for shared schemas\nconfig.RenameTemplate = `{{if .IsShared}}{{range $i, $id := .AllOperationIDs}}{{if $i}}_{{end}}{{$id}}{{end}}_{{.Name}}{{else}}{{.OperationID}}_{{.Name}}{{end}}`\n\n// Shared schema used by listOrders and getOrder: \"listOrders_getOrder_Response\"\n// Single-use schema: \"listOrders_Response\"\n</code></pre>"},{"location":"packages/joiner/#limitations","title":"Limitations","text":""},{"location":"packages/joiner/#operation-context-for-base-document-schemas","title":"Operation Context for Base Document Schemas","text":"<p>When using <code>WithOperationContext(true)</code>, only schemas from the RIGHT (incoming) documents receive operation-derived context. The LEFT (base) document's schemas do not have their operation references traced.</p> <p>This means for base document schemas, the following <code>RenameContext</code> fields will be empty:</p> <ul> <li><code>Path</code>, <code>Method</code>, <code>OperationID</code>, <code>Tags</code></li> <li><code>UsageType</code>, <code>StatusCode</code>, <code>ParamName</code>, <code>MediaType</code></li> <li><code>AllPaths</code>, <code>AllMethods</code>, <code>AllOperationIDs</code>, <code>AllTags</code></li> <li><code>RefCount</code>, <code>PrimaryResource</code>, <code>IsShared</code></li> </ul> <p>Only the core fields (<code>Name</code>, <code>Source</code>, <code>Index</code>) are populated for base document schemas.</p> <p>Workaround: If you need operation context for all schemas, consider restructuring your join order so the document with schemas requiring operation context is joined as the RIGHT document.</p>"},{"location":"packages/joiner/#oas-20-support","title":"OAS 2.0 Support","text":"<p>Operation-aware renaming works with both OAS 2.0 and OAS 3.x documents. The reference graph construction adapts to each version's structure:</p> OAS Version Request Body Detection Schema Reference Path OAS 2.0 Body parameter with <code>in: body</code> <code>#/definitions/SchemaName</code> OAS 3.x <code>requestBody.content.*.schema</code> <code>#/components/schemas/SchemaName</code> <p>For OAS 2.0 documents:</p> <pre><code>config := joiner.DefaultConfig()\nconfig.SchemaStrategy = joiner.StrategyRenameRight\nconfig.OperationContext = true\nconfig.RenameTemplate = \"{{pascalCase .OperationID}}{{.Name}}\"\n\nj := joiner.New(config)\n\n// Works with OAS 2.0 (Swagger) documents\nresult, err := j.Join([]string{\n    \"swagger-users.yaml\",  // OAS 2.0\n    \"swagger-orders.yaml\", // OAS 2.0\n})\n</code></pre>"},{"location":"packages/joiner/#webhook-support-oas-31","title":"Webhook Support (OAS 3.1+)","text":"<p>For OAS 3.1+ documents with webhooks, the reference graph includes webhook operations:</p> <pre><code>webhooks:\n  orderCreated:\n    post:\n      operationId: handleOrderCreated\n      tags: [webhooks]\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/OrderEvent'\n</code></pre> <p>The <code>Path</code> field for webhook operations uses the format <code>webhook:&lt;name&gt;</code>:</p> Template Webhook Path Result <code>{{.Path}}</code> orderCreated webhook <code>webhook:orderCreated</code> <code>{{pathResource .Path}}</code> orderCreated webhook <code>webhook</code>"},{"location":"packages/joiner/#callback-support","title":"Callback Support","text":"<p>Callbacks in OAS 3.0+ are also tracked in the reference graph. The path includes the parent operation and callback name:</p> <pre><code>paths:\n  /orders:\n    post:\n      operationId: createOrder\n      callbacks:\n        orderStatus:\n          '{$request.body#/callbackUrl}':\n            post:\n              requestBody:\n                content:\n                  application/json:\n                    schema:\n                      $ref: '#/components/schemas/StatusUpdate'\n</code></pre> <p>For callback operations, the <code>Path</code> field uses the format <code>&lt;parent_path&gt;-&gt;&lt;callback_name&gt;:&lt;callback_path&gt;</code>:</p> <pre><code>/orders-&gt;orderStatus:{$request.body#/callbackUrl}\n</code></pre> <p>The <code>UsageType</code> will be <code>\"callback\"</code> for schemas referenced within callbacks.</p>"},{"location":"packages/joiner/#debugging-rename-templates","title":"Debugging Rename Templates","text":"<p>To debug rename templates, use a template that outputs all available fields:</p> <pre><code>// Debug template that shows all context\nconfig.RenameTemplate = `DEBUG_{{.Name}}_path={{.Path}}_method={{.Method}}_op={{.OperationID}}_usage={{.UsageType}}_shared={{.IsShared}}`\n</code></pre> <p>This produces names like:</p> <pre><code>DEBUG_Response_path=/orders_method=get_op=listOrders_usage=response_shared=false\n</code></pre> <p>Once you've identified the available fields, simplify to your production template.</p>"},{"location":"packages/joiner/#performance-considerations","title":"Performance Considerations","text":"<p>Building the reference graph adds a traversal pass over the document. For most specifications, this overhead is negligible:</p> Document Size Typical Overhead Small (&lt; 50 paths) &lt; 1ms Medium (50-500 paths) 1-5ms Large (500+ paths) 5-20ms <p>The reference graph is built once per document and cached. Lineage resolution is also cached, so multiple schema renames reuse the same graph traversal results.</p> <p>To minimize overhead when operation context is not needed:</p> <pre><code>config := joiner.DefaultConfig()\nconfig.OperationContext = false  // Default - skip graph building\nconfig.RenameTemplate = \"{{.Name}}_{{.Source}}\"  // Core fields only\n</code></pre>"},{"location":"packages/joiner/#integration-with-semantic-deduplication","title":"Integration with Semantic Deduplication","text":"<p>Operation-aware renaming and semantic deduplication are complementary features:</p> Feature Purpose When to Use Semantic Deduplication Consolidates structurally identical schemas When schemas are duplicated across services Operation-Aware Renaming Creates meaningful names for colliding schemas When schemas have the same name but different structures <p>Use both together for comprehensive schema management:</p> <pre><code>config := joiner.DefaultConfig()\n\n// Consolidate identical schemas first\nconfig.SemanticDeduplication = true\n\n// For remaining collisions (same name, different structure),\n// use operation-aware renaming\nconfig.SchemaStrategy = joiner.StrategyRenameRight\nconfig.OperationContext = true\nconfig.RenameTemplate = \"{{pascalCase .OperationID}}{{.Name}}\"\nconfig.PrimaryOperationPolicy = joiner.PolicyMostSpecific\n\nj := joiner.New(config)\nresult, err := j.Join(files)\n</code></pre> <p>With this configuration:</p> <ol> <li>Structurally identical schemas (e.g., <code>Address</code> in users and orders) are consolidated</li> <li>Structurally different schemas with the same name (e.g., different <code>Response</code> schemas) are renamed with operation context</li> </ol>"},{"location":"packages/joiner/#common-pitfalls","title":"Common Pitfalls","text":"<p>Empty OperationID: Not all APIs define operation IDs. Use fallbacks:</p> <pre><code>// Bad - empty OperationID produces \"Response\"\nconfig.RenameTemplate = \"{{.OperationID}}{{.Name}}\"\n\n// Good - falls back to path resource\nconfig.RenameTemplate = \"{{pascalCase (coalesce .OperationID (pathResource .Path) .Source)}}{{.Name}}\"\n</code></pre> <p>Orphaned Schemas: Schemas not referenced by any operation will have empty operation context. These typically include:</p> <ul> <li>Base schemas used only via <code>allOf</code>/<code>anyOf</code>/<code>oneOf</code></li> <li>Schemas defined but never referenced</li> <li>Nested <code>$defs</code> schemas</li> </ul> <p>For orphaned schemas, the template receives only core fields (<code>Name</code>, <code>Source</code>, <code>Index</code>). Design templates with fallbacks:</p> <pre><code>// Handles orphaned schemas gracefully\nconfig.RenameTemplate = `{{if .Path}}{{pascalCase .OperationID}}{{.Name}}{{else}}{{.Name}}_{{.Source}}{{end}}`\n</code></pre> <p>Path Parameters in Templates: Path functions skip parameters, but <code>pathClean</code> converts them:</p> <pre><code>pathClean(\"/users/{id}\")       // \"users_id\" - includes parameter name\npathResource(\"/users/{id}\")    // \"users\" - excludes parameter\npathLast(\"/users/{id}/orders\") // \"orders\" - excludes parameter\n</code></pre> <p>Back to top</p>"},{"location":"packages/joiner/#custom-collision-handlers","title":"Custom Collision Handlers","text":"<p>While the built-in collision strategies (<code>StrategyAcceptLeft</code>, <code>StrategyRenameRight</code>, etc.) handle most use cases, some scenarios require custom logic. Collision handlers provide a callback mechanism for fine-grained collision control.</p>"},{"location":"packages/joiner/#when-to-use-collision-handlers","title":"When to Use Collision Handlers","text":"<p>Use collision handlers when you need to:</p> <ul> <li>Log all collisions for audit trails or debugging</li> <li>Apply conditional logic - different decisions based on schema names, sources, or content</li> <li>Implement custom merging - combine properties from both schemas</li> <li>Integrate with external systems - validate decisions against a schema registry</li> <li>Fail selectively - reject specific collisions while allowing others</li> </ul>"},{"location":"packages/joiner/#basic-usage","title":"Basic Usage","text":"<p>Register a collision handler using <code>WithCollisionHandler</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    result, err := joiner.JoinWithOptions(\n        joiner.WithFilePaths(\"base.yaml\", \"overlay.yaml\"),\n        joiner.WithSchemaStrategy(joiner.StrategyAcceptLeft), // Default strategy\n        joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n            // Log all collisions\n            log.Printf(\"Collision: %s %s at %s\", collision.Type, collision.Name, collision.JSONPath)\n\n            // Custom logic: always accept right for \"Response\" schemas\n            if collision.Name == \"Response\" {\n                return joiner.AcceptRightWithMessage(\"Response schemas always use overlay version\"), nil\n            }\n\n            // Defer to configured strategy for everything else\n            return joiner.ContinueWithStrategy(), nil\n        }),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Collisions resolved: %d\\n\", result.CollisionCount)\n}\n</code></pre>"},{"location":"packages/joiner/#collisioncontext-reference","title":"CollisionContext Reference","text":"<p>The handler receives a <code>CollisionContext</code> with complete information about the collision:</p> Field Type Description <code>Type</code> <code>CollisionType</code> What collided: <code>CollisionTypeSchema</code>, <code>CollisionTypePath</code>, etc. <code>Name</code> <code>string</code> The colliding name (e.g., \"User\", \"/pets\") <code>JSONPath</code> <code>string</code> Full JSON path (e.g., \"$.components.schemas.User\") <code>LeftSource</code> <code>string</code> Source file/identifier for the left (base) document <code>LeftLocation</code> <code>*SourceLocation</code> Line/column in left document (nil if unknown) <code>LeftValue</code> <code>any</code> The left component (<code>*parser.Schema</code>, <code>*parser.PathItem</code>, etc.) <code>RightSource</code> <code>string</code> Source file/identifier for the right (incoming) document <code>RightLocation</code> <code>*SourceLocation</code> Line/column in right document (nil if unknown) <code>RightValue</code> <code>any</code> The right component <code>RenameInfo</code> <code>*RenameContext</code> Operation context for rename templates (nil for paths) <code>ConfiguredStrategy</code> <code>CollisionStrategy</code> The strategy that would apply without handler"},{"location":"packages/joiner/#resolution-actions","title":"Resolution Actions","text":"<p>Return one of these resolution helpers from your handler:</p> Helper Description <code>ContinueWithStrategy()</code> Defer to the configured strategy (observe-only mode) <code>AcceptLeft()</code> Keep the left (base) value <code>AcceptRight()</code> Keep the right (incoming) value <code>Rename()</code> Rename the right value using the rename template <code>Deduplicate()</code> Treat colliding values as equivalent (skip the right) <code>Fail()</code> Abort the join with an error <code>UseCustomValue(value)</code> Use a custom merged value (schemas only) <p>All helpers have <code>WithMessage(string)</code> variants for logging:</p> <pre><code>return joiner.AcceptLeftWithMessage(\"Keeping base schema per policy\"), nil\n</code></pre>"},{"location":"packages/joiner/#handler-patterns","title":"Handler Patterns","text":""},{"location":"packages/joiner/#observe-only-logging","title":"Observe-Only (Logging)","text":"<p>Log all collisions without affecting behavior:</p> <pre><code>joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n    log.Printf(\"[COLLISION] %s: %s (%s vs %s)\",\n        collision.Type,\n        collision.Name,\n        collision.LeftSource,\n        collision.RightSource,\n    )\n    return joiner.ContinueWithStrategy(), nil\n})\n</code></pre>"},{"location":"packages/joiner/#conditional-decisions","title":"Conditional Decisions","text":"<p>Apply different resolutions based on collision attributes:</p> <pre><code>joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n    // Fail on path collisions (strict)\n    if collision.Type == joiner.CollisionTypePath {\n        return joiner.FailWithMessage(\"Path collisions not allowed\"), nil\n    }\n\n    // Accept right for \"Error\" schemas (overlay overrides)\n    if collision.Name == \"Error\" || collision.Name == \"ErrorResponse\" {\n        return joiner.AcceptRight(), nil\n    }\n\n    // Use deduplication for common schemas\n    if collision.Name == \"Pagination\" || collision.Name == \"Links\" {\n        return joiner.Deduplicate(), nil\n    }\n\n    // Default to configured strategy\n    return joiner.ContinueWithStrategy(), nil\n})\n</code></pre>"},{"location":"packages/joiner/#custom-schema-merging","title":"Custom Schema Merging","text":"<p>Provide a merged schema that combines properties from both:</p> <pre><code>joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n    if collision.Type != joiner.CollisionTypeSchema {\n        return joiner.ContinueWithStrategy(), nil\n    }\n\n    leftSchema := collision.LeftValue.(*parser.Schema)\n    rightSchema := collision.RightValue.(*parser.Schema)\n\n    // Create merged schema with properties from both\n    merged := &amp;parser.Schema{\n        Type:        leftSchema.Type,\n        Description: rightSchema.Description, // Prefer right description\n        Properties:  make(map[string]*parser.Schema),\n    }\n\n    // Copy all properties from left\n    for name, prop := range leftSchema.Properties {\n        merged.Properties[name] = prop\n    }\n\n    // Add/override with properties from right\n    for name, prop := range rightSchema.Properties {\n        merged.Properties[name] = prop\n    }\n\n    return joiner.UseCustomValueWithMessage(merged, \"Merged properties from both schemas\"), nil\n})\n</code></pre>"},{"location":"packages/joiner/#type-filtered-handlers","title":"Type-Filtered Handlers","text":"<p>Use <code>WithCollisionHandlerFor</code> to handle only specific collision types:</p> <pre><code>// Only handle schema collisions - paths use configured strategy\njoiner.WithCollisionHandlerFor(\n    func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n        // This handler only receives schema collisions\n        log.Printf(\"Schema collision: %s\", collision.Name)\n        return joiner.ContinueWithStrategy(), nil\n    },\n    joiner.CollisionTypeSchema,\n)\n</code></pre> <p>Filter for multiple types:</p> <pre><code>joiner.WithCollisionHandlerFor(\n    handler,\n    joiner.CollisionTypeSchema,\n    joiner.CollisionTypePath,\n)\n</code></pre>"},{"location":"packages/joiner/#supported-collision-types","title":"Supported Collision Types","text":"Type Description Custom Value Support Rename Support <code>CollisionTypeSchema</code> Schema in components.schemas (OAS3) or definitions (OAS2) \u2705 Yes \u2705 Yes <code>CollisionTypePath</code> Path in paths section \u274c No \u274c No <p>Note: <code>Rename()</code> and <code>UseCustomValue()</code> are not supported for path collisions because paths are URL endpoints that cannot be renamed or custom-merged without breaking API contracts. Use <code>AcceptLeft()</code>, <code>AcceptRight()</code>, <code>Deduplicate()</code>, or <code>Fail()</code> for path collisions.</p>"},{"location":"packages/joiner/#error-handling","title":"Error Handling","text":"<p>If your handler returns an error, the joiner:</p> <ol> <li>Logs a warning with the error message</li> <li>Falls back to the configured strategy</li> <li>Continues the join operation</li> </ol> <p>This ensures handlers cannot break the join:</p> <pre><code>joiner.WithCollisionHandler(func(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n    // If validation fails, error triggers fallback to strategy\n    if err := validateCollision(collision); err != nil {\n        return joiner.CollisionResolution{}, err\n    }\n    return joiner.AcceptLeft(), nil\n})\n</code></pre>"},{"location":"packages/joiner/#warnings","title":"Warnings","text":"<p>Handler-related events appear in <code>JoinResult.StructuredWarnings</code>:</p> Category When <code>WarnHandlerError</code> Handler returned an error (fell back to strategy) <code>WarnHandlerResolution</code> Handler provided a resolution with a message <pre><code>for _, warning := range result.StructuredWarnings {\n    if warning.Category == joiner.WarnHandlerError {\n        log.Printf(\"Handler error at %s: %s\", warning.Path, warning.Message)\n    }\n}\n</code></pre>"},{"location":"packages/joiner/#complete-example","title":"Complete Example","text":"<p>A production-ready handler that implements a schema governance policy:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"strings\"\n\n    \"github.com/erraggy/oastools/joiner\"\n    \"github.com/erraggy/oastools/parser\"\n)\n\n// governanceHandler implements organization schema policies\nfunc governanceHandler(collision joiner.CollisionContext) (joiner.CollisionResolution, error) {\n    // Only handle schemas\n    if collision.Type != joiner.CollisionTypeSchema {\n        return joiner.ContinueWithStrategy(), nil\n    }\n\n    name := collision.Name\n\n    // Policy 1: Common schemas must be deduplicated\n    commonSchemas := []string{\"Error\", \"Pagination\", \"Links\", \"Meta\"}\n    for _, common := range commonSchemas {\n        if name == common {\n            return joiner.DeduplicateWithMessage(\n                fmt.Sprintf(\"%s is a common schema - deduplicating\", name),\n            ), nil\n        }\n    }\n\n    // Policy 2: Response schemas always come from the service (right)\n    if strings.HasSuffix(name, \"Response\") {\n        return joiner.AcceptRightWithMessage(\"Service-specific response schema\"), nil\n    }\n\n    // Policy 3: Request schemas always come from the base (left)\n    if strings.HasSuffix(name, \"Request\") {\n        return joiner.AcceptLeftWithMessage(\"Base request schema takes precedence\"), nil\n    }\n\n    // Policy 4: Fail on unexpected collisions\n    return joiner.FailWithMessage(\n        fmt.Sprintf(\"Unexpected schema collision: %s - review governance policy\", name),\n    ), nil\n}\n\nfunc main() {\n    result, err := joiner.JoinWithOptions(\n        joiner.WithFilePaths(\n            \"base-api.yaml\",\n            \"users-service.yaml\",\n            \"orders-service.yaml\",\n        ),\n        joiner.WithSchemaStrategy(joiner.StrategyFailOnCollision),\n        joiner.WithCollisionHandler(governanceHandler),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Join completed with %d collisions resolved\\n\", result.CollisionCount)\n\n    // Review any governance decisions\n    for _, warning := range result.StructuredWarnings {\n        if warning.Category == joiner.WarnHandlerResolution {\n            fmt.Printf(\"  Policy applied at %s: %s\\n\", warning.Path, warning.Message)\n        }\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#namespace-prefixes-for-team-based-apis","title":"Namespace Prefixes for Team-Based APIs","text":"<p>When consolidating APIs from different teams, namespace prefixes prevent collisions while maintaining clarity about schema origins:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.DefaultConfig()\n    config.SchemaStrategy = joiner.StrategyAcceptLeft\n\n    // Map source files to namespace prefixes\n    config.NamespacePrefix = map[string]string{\n        \"users-api.yaml\":   \"Users\",\n        \"billing-api.yaml\": \"Billing\",\n        \"orders-api.yaml\":  \"Orders\",\n    }\n\n    // Apply prefix to ALL schemas, not just collisions\n    config.AlwaysApplyPrefix = true\n\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\n        \"users-api.yaml\",\n        \"billing-api.yaml\",\n        \"orders-api.yaml\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Schemas will be named:\n    // Users_User, Users_Profile\n    // Billing_Invoice, Billing_Payment\n    // Orders_Order, Orders_LineItem\n\n    fmt.Printf(\"Merged with namespace prefixes\\n\")\n    fmt.Printf(\"Schema count: %d\\n\", result.Stats.SchemaCount)\n}\n</code></pre>"},{"location":"packages/joiner/#semantic-deduplication-across-documents","title":"Semantic Deduplication Across Documents","text":"<p>When multiple APIs define structurally identical schemas with different names, semantic deduplication consolidates them:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    result, err := joiner.JoinWithOptions(\n        joiner.WithFilePaths(\n            \"users-api.yaml\",    // Has Address schema\n            \"orders-api.yaml\",   // Has ShippingAddress schema (identical structure)\n            \"billing-api.yaml\",  // Has BillingAddress schema (identical structure)\n        ),\n        joiner.WithSemanticDeduplication(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // If Address, ShippingAddress, and BillingAddress are structurally identical,\n    // they'll be consolidated to \"Address\" (alphabetically first)\n    // All references are rewritten automatically\n\n    fmt.Printf(\"Schema count after deduplication: %d\\n\", result.Stats.SchemaCount)\n    for _, warning := range result.Warnings {\n        fmt.Printf(\"  %s\\n\", warning)\n    }\n}\n</code></pre> <p>Example Input Documents:</p> <p>users-api.yaml:</p> <pre><code>components:\n  schemas:\n    Address:\n      type: object\n      properties:\n        street:\n          type: string\n        city:\n          type: string\n        zip:\n          type: string\n</code></pre> <p>orders-api.yaml:</p> <pre><code>components:\n  schemas:\n    ShippingAddress:\n      type: object\n      properties:\n        street:\n          type: string\n        city:\n          type: string\n        zip:\n          type: string\n</code></pre> <p>Example Output:</p> <pre><code>Schema count after deduplication: 1\n  semantic deduplication: consolidated 3 duplicate definition(s)\n</code></pre>"},{"location":"packages/joiner/#empty-schemas-are-preserved","title":"Empty Schemas Are Preserved","text":"<p>Empty schemas (those with no structural constraints) are automatically excluded from deduplication, even when they appear structurally identical. This is because empty schemas serve different semantic purposes depending on context:</p> <ul> <li>Placeholders for schemas to be defined later</li> <li>\"Any type\" markers that accept any value</li> <li>Context-specific wildcards with meaning derived from their name or position</li> </ul> <p>A schema is considered \"empty\" if it has no type, format, properties, validation rules, or composition keywords. Metadata fields (title, description, example, deprecated) are NOT considered constraints.</p> <pre><code># users-api.yaml\ncomponents:\n  schemas:\n    AnyPayload: {}           # \"Accept any request body\"\n    User:\n      type: object\n      properties:\n        name:\n          type: string\n\n# events-api.yaml\ncomponents:\n  schemas:\n    DynamicData: {}           # \"Event data can be anything\"\n    User:                     # Identical to users-api User\n      type: object\n      properties:\n        name:\n          type: string\n</code></pre> <p>After joining with semantic deduplication enabled:</p> <ul> <li><code>AnyPayload</code> and <code>DynamicData</code> are both preserved (empty schemas are never consolidated)</li> <li>The two <code>User</code> schemas are consolidated into one (structurally identical, non-empty)</li> </ul>"},{"location":"packages/joiner/#schema-equivalence-detection","title":"Schema Equivalence Detection","text":"<p>For collision handling with <code>StrategyDeduplicateEquivalent</code>, configure the depth of structural comparison:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.DefaultConfig()\n\n    // Use deduplication for same-named schemas\n    config.SchemaStrategy = joiner.StrategyDeduplicateEquivalent\n\n    // Configure comparison depth:\n    // \"none\"    - No comparison, always treat as collision\n    // \"shallow\" - Compare top-level properties only\n    // \"deep\"    - Full recursive structural comparison\n    config.EquivalenceMode = \"deep\"\n\n    j := joiner.New(config)\n\n    // If both files have User schema with identical structure,\n    // they'll be merged without error\n    // If structures differ, join fails with collision error\n    result, err := j.Join([]string{\"api1.yaml\", \"api2.yaml\"})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"Merged successfully, %d collisions resolved\", result.CollisionCount)\n}\n</code></pre>"},{"location":"packages/joiner/#high-performance-joining-with-pre-parsed-documents","title":"High-Performance Joining with Pre-Parsed Documents","text":"<p>For integration with other oastools packages, use pre-parsed documents for 154x faster performance:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/erraggy/oastools/joiner\"\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    // Parse and validate documents\n    files := []string{\"api1.yaml\", \"api2.yaml\", \"api3.yaml\"}\n    var parsed []parser.ParseResult\n\n    for _, file := range files {\n        p, err := parser.ParseWithOptions(\n            parser.WithFilePath(file),\n            parser.WithValidateStructure(true),\n        )\n        if err != nil {\n            log.Fatalf(\"Failed to parse %s: %v\", file, err)\n        }\n\n        // Validate before joining (required)\n        v, err := validator.ValidateWithOptions(\n            validator.WithParsed(*p),\n        )\n        if err != nil {\n            log.Fatalf(\"Failed to validate %s: %v\", file, err)\n        }\n        if !v.Valid {\n            log.Fatalf(\"%s has validation errors\", file)\n        }\n\n        parsed = append(parsed, *p)\n    }\n\n    // Join using pre-parsed documents (154x faster)\n    start := time.Now()\n    result, err := joiner.JoinWithOptions(\n        joiner.WithParsed(parsed...),\n        joiner.WithSchemaStrategy(joiner.StrategyAcceptLeft),\n    )\n    elapsed := time.Since(start)\n\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Join completed in %v\\n\", elapsed)\n    fmt.Printf(\"Paths: %d, Schemas: %d\\n\", \n        result.Stats.PathCount, result.Stats.SchemaCount)\n}\n</code></pre>"},{"location":"packages/joiner/#collision-report-generation","title":"Collision Report Generation","text":"<p>For debugging complex merges, enable collision reporting:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.DefaultConfig()\n    config.SchemaStrategy = joiner.StrategyAcceptLeft\n    config.CollisionReport = true  // Enable detailed reporting\n\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\n        \"api1.yaml\",\n        \"api2.yaml\",\n        \"api3.yaml\",\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if result.CollisionDetails != nil {\n        fmt.Printf(\"Collision Report:\\n\")\n        fmt.Printf(\"  Total collisions: %d\\n\", result.CollisionDetails.TotalCount)\n        fmt.Printf(\"  Schema collisions: %d\\n\", result.CollisionDetails.SchemaCount)\n        fmt.Printf(\"  Path collisions: %d\\n\", result.CollisionDetails.PathCount)\n\n        for _, collision := range result.CollisionDetails.Collisions {\n            fmt.Printf(\"\\n  %s collision: %s\\n\", collision.Type, collision.Name)\n            fmt.Printf(\"    Sources: %v\\n\", collision.Sources)\n            fmt.Printf(\"    Resolution: %s\\n\", collision.Resolution)\n        }\n    }\n}\n</code></pre>"},{"location":"packages/joiner/#overlay-integration-during-join","title":"Overlay Integration During Join","text":"<p>Apply transformations during the join process:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    result, err := joiner.JoinWithOptions(\n        joiner.WithFilePaths(\"api1.yaml\", \"api2.yaml\"),\n\n        // Apply overlay to each input before merging\n        joiner.WithPreJoinOverlayFile(\"normalize.yaml\"),\n\n        // Apply overlay to final result\n        joiner.WithPostJoinOverlayFile(\"enhance.yaml\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"Join with overlays completed: %d paths\", result.Stats.PathCount)\n}\n</code></pre> <p>Example Pre-Join Overlay (normalize.yaml):</p> <pre><code>overlay: 1.0.0\ninfo:\n  title: Normalization Overlay\nactions:\n  - target: $.paths.*.*.responses.*.description\n    update:\n      description: Standardized response\n</code></pre>"},{"location":"packages/joiner/#different-strategies-per-component-type","title":"Different Strategies per Component Type","text":"<p>Fine-grained control over collision handling for different specification elements:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/joiner\"\n)\n\nfunc main() {\n    config := joiner.JoinerConfig{\n        // Fail on path collisions - paths must be unique\n        PathStrategy: joiner.StrategyFailOnCollision,\n\n        // For schemas, rename collisions from the right document\n        SchemaStrategy: joiner.StrategyRenameRight,\n        RenameTemplate: \"{{.Name}}_v{{.Index}}\",\n\n        // For other components (parameters, responses), keep left\n        ComponentStrategy: joiner.StrategyAcceptLeft,\n\n        // Merge arrays (servers, security requirements)\n        MergeArrays: true,\n\n        // Remove duplicate tags by name\n        DeduplicateTags: true,\n    }\n\n    j := joiner.New(config)\n\n    result, err := j.Join([]string{\"base.yaml\", \"extension.yaml\"})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Merged with custom strategies\\n\")\n    fmt.Printf(\"Warnings: %d\\n\", len(result.Warnings))\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/joiner/#joinerconfig-fields","title":"JoinerConfig Fields","text":"<pre><code>type JoinerConfig struct {\n    // Global default strategy for all collisions\n    DefaultStrategy CollisionStrategy\n\n    // Per-component type strategies (override DefaultStrategy)\n    PathStrategy      CollisionStrategy\n    SchemaStrategy    CollisionStrategy\n    ComponentStrategy CollisionStrategy\n\n    // Tag and array handling\n    DeduplicateTags bool  // Remove duplicate tags by name\n    MergeArrays     bool  // Merge servers, security, tags arrays\n\n    // Rename strategy configuration\n    RenameTemplate string              // Go template: \"{{.Name}}_{{.Source}}\"\n    NamespacePrefix map[string]string  // Source file \u2192 prefix mapping\n    AlwaysApplyPrefix bool             // Apply prefix to all schemas, not just collisions\n\n    // Equivalence detection configuration\n    EquivalenceMode string  // \"none\", \"shallow\", or \"deep\"\n\n    // Reporting\n    CollisionReport bool  // Generate detailed collision analysis\n\n    // Post-processing\n    SemanticDeduplication bool  // Consolidate identical schemas across documents\n}\n</code></pre>"},{"location":"packages/joiner/#available-options","title":"Available Options","text":"Option Description <code>WithFilePaths(paths ...string)</code> Input file paths or URLs <code>WithParsed(docs ...ParseResult)</code> Pre-parsed documents (154x faster) <code>WithConfig(JoinerConfig)</code> Full configuration object <code>WithPathStrategy(CollisionStrategy)</code> Strategy for path collisions <code>WithSchemaStrategy(CollisionStrategy)</code> Strategy for schema collisions <code>WithComponentStrategy(CollisionStrategy)</code> Strategy for other components <code>WithSemanticDeduplication(bool)</code> Enable cross-document deduplication <code>WithCollisionHandler(handler)</code> Register collision handler callback <code>WithCollisionHandlerFor(handler, types...)</code> Register handler for specific collision types <code>WithPreJoinOverlayFile(string)</code> Overlay applied to each input <code>WithPostJoinOverlayFile(string)</code> Overlay applied to merged result <code>WithCollisionReport(bool)</code> Enable detailed collision analysis in result <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#joinresult-structure","title":"JoinResult Structure","text":"<pre><code>type JoinResult struct {\n    // Document contains the merged document\n    // (*parser.OAS2Document or *parser.OAS3Document)\n    Document any\n\n    // Version is the OpenAPI version string (e.g., \"3.0.3\")\n    Version string\n\n    // OASVersion is the enumerated version\n    OASVersion parser.OASVersion\n\n    // SourceFormat is the format of the first source file\n    SourceFormat parser.SourceFormat\n\n    // Warnings contains non-fatal issues encountered\n    Warnings []string\n\n    // CollisionCount tracks resolved collisions\n    CollisionCount int\n\n    // Stats contains document statistics\n    Stats parser.DocumentStats\n\n    // CollisionDetails contains detailed analysis\n    // (when CollisionReport is enabled)\n    CollisionDetails *CollisionReport\n}\n</code></pre>"},{"location":"packages/joiner/#joinresult-methods","title":"JoinResult Methods","text":"Method Returns Description <code>ToParseResult()</code> <code>*parser.ParseResult</code> Converts result for package chaining <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#source-map-integration","title":"Source Map Integration","text":"<p>Source maps enable precise collision and warning locations by tracking line and column numbers from your YAML/JSON source files. Without source maps, collision errors only show JSON paths. With source maps, collision errors include file:line:column positions that IDEs can click to jump directly to the conflict.</p> <p>Without source maps:</p> <pre><code>schema collision: 'User' defined in users-api.yaml (components.schemas.User) and orders-api.yaml (components.schemas.User)\n</code></pre> <p>With source maps:</p> <pre><code>schema collision: 'User' defined in users-api.yaml:45:5 and orders-api.yaml:62:5\n</code></pre> <p>When joining multiple files, use <code>WithSourceMaps</code> (plural) to pass source maps for all input documents:</p> <pre><code>sourceMaps := make(map[string]*parser.SourceMap)\nvar docs []parser.ParseResult\n\nfor _, path := range []string{\"users-api.yaml\", \"orders-api.yaml\"} {\n    p, _ := parser.ParseWithOptions(\n        parser.WithFilePath(path),\n        parser.WithSourceMap(true),  // Enable line tracking during parse\n    )\n    sourceMaps[path] = p.SourceMap\n    docs = append(docs, *p)\n}\n\nresult, _ := joiner.JoinWithOptions(\n    joiner.WithParsed(docs...),\n    joiner.WithSourceMaps(sourceMaps),  // Pass all source maps (keyed by file path)\n)\n\n// Warnings and collision details now include line/column/file info\nfor _, warning := range result.Warnings {\n    fmt.Println(warning)  // Includes file:line:column when available\n}\n</code></pre> <p>The joiner uses <code>WithSourceMaps</code> (plural, with a map) because it needs source maps from multiple input files to track collision locations across documents.</p> <p>Back to top</p>"},{"location":"packages/joiner/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>JoinResult</code> to a <code>parser.ParseResult</code>:</p> <pre><code>// Join then validate\njoinResult, err := joiner.JoinWithOptions(\n    joiner.WithFilePaths(\"users-api.yaml\", \"orders-api.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*joinResult.ToParseResult())\nfmt.Printf(\"Valid: %v\\n\", valResult.Valid)\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*joinResult.ToParseResult(), \"3.1.0\")\n\n// Or chain to fixer\nfixResult, _ := fixer.FixWithOptions(\n    fixer.WithParsed(*joinResult.ToParseResult()),\n)\n</code></pre> <p>This enables workflows like: <code>parse \u2192 join \u2192 validate \u2192 convert \u2192 diff</code></p> <p>Note: Join warnings are converted to string warnings in the resulting ParseResult.</p> <p>Back to top</p>"},{"location":"packages/joiner/#best-practices","title":"Best Practices","text":"<p>Always validate input documents before joining. The joiner requires documents with no validation errors. Use the validator package first.</p> <p>Use StrategyFailOnCollision initially to understand what collisions exist in your documents before choosing a resolution strategy.</p> <p>Choose collision strategies based on your use case:</p> <ul> <li>Fail strategies for strict merging where collisions indicate problems</li> <li>Accept strategies when you have a clear \"primary\" document</li> <li>Rename strategies when you need to preserve both versions</li> <li>Deduplicate strategies when schemas should be consolidated</li> </ul> <p>Use namespace prefixes for team-based consolidation to maintain clarity about schema origins in large merged documents.</p> <p>Enable semantic deduplication when consolidating APIs that likely share common schemas (addresses, pagination, error responses).</p> <p>Use the parse-once pattern when integrating with validation or other processing for 154x performance improvement.</p> <p>Use collision handlers when you need conditional logic, audit logging, or custom schema merging beyond what built-in strategies provide. Start with observe-only handlers (<code>ContinueWithStrategy()</code>) to understand collision patterns before implementing custom resolution logic.</p> <p>\u2191 Back to top</p>"},{"location":"packages/joiner/#common-patterns","title":"Common Patterns","text":""},{"location":"packages/joiner/#microservices-consolidation","title":"Microservices Consolidation","text":"<pre><code>// Collect all service specs\nservices := []string{\n    \"auth-service/openapi.yaml\",\n    \"user-service/openapi.yaml\",\n    \"order-service/openapi.yaml\",\n    \"payment-service/openapi.yaml\",\n}\n\nconfig := joiner.DefaultConfig()\nconfig.PathStrategy = joiner.StrategyFailOnCollision\nconfig.SchemaStrategy = joiner.StrategyRenameRight\nconfig.RenameTemplate = \"{{.Name}}_{{.Source}}\"\nconfig.SemanticDeduplication = true\n\nj := joiner.New(config)\nresult, err := j.Join(services)\n</code></pre>"},{"location":"packages/joiner/#api-gateway-aggregation","title":"API Gateway Aggregation","text":"<pre><code>// Prefix schemas by team for gateway configuration\nconfig.NamespacePrefix = map[string]string{\n    \"team-a/api.yaml\": \"TeamA\",\n    \"team-b/api.yaml\": \"TeamB\",\n    \"team-c/api.yaml\": \"TeamC\",\n}\nconfig.AlwaysApplyPrefix = true\n</code></pre>"},{"location":"packages/joiner/#extension-document-pattern","title":"Extension Document Pattern","text":"<pre><code>// Base API with extensions\nconfig.PathStrategy = joiner.StrategyAcceptRight  // Extensions override base\nconfig.SchemaStrategy = joiner.StrategyAcceptLeft  // Base schemas take priority\n\nresult, _ := j.Join([]string{\n    \"base-api.yaml\",       // Core API\n    \"custom-extension.yaml\", // Customer-specific additions\n})\n</code></pre>"},{"location":"packages/joiner/#cli-usage","title":"CLI Usage","text":"<p>The joiner's operation-aware schema renaming and overlay integration features are fully accessible from the command line.</p>"},{"location":"packages/joiner/#basic-schema-renaming","title":"Basic Schema Renaming","text":"<pre><code># Rename colliding schemas with source file suffix\noastools join --schema-strategy rename-right \\\n  --rename-template \"{{.Name}}_{{.Source}}\" \\\n  -o merged.yaml users-api.yaml orders-api.yaml\n</code></pre>"},{"location":"packages/joiner/#operation-aware-renaming","title":"Operation-Aware Renaming","text":"<p>Enable <code>--operation-context</code> to access path, method, operation ID, and tag information in templates:</p> <pre><code># Use operation ID as prefix (e.g., \"ListUsersResponse\")\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{.OperationID | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Use path resource as prefix (e.g., \"OrdersResponse\")\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{pathResource .Path | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Full method + resource naming (e.g., \"GetOrdersResponse\")\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{.Method | pascalCase}}{{pathResource .Path | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n</code></pre>"},{"location":"packages/joiner/#primary-operation-policy_1","title":"Primary Operation Policy","text":"<p>Control which operation provides context when a schema is used by multiple operations:</p> <pre><code># Prefer operations with operationId defined\noastools join --schema-strategy rename-right --operation-context \\\n  --primary-operation-policy most-specific \\\n  --rename-template \"{{.OperationID | default .Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Alphabetical for reproducible builds\noastools join --schema-strategy rename-right --operation-context \\\n  --primary-operation-policy alphabetical \\\n  --rename-template \"{{.OperationID | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n</code></pre>"},{"location":"packages/joiner/#template-patterns","title":"Template Patterns","text":"<p>Common template patterns for different use cases:</p> <pre><code># With fallback for schemas without operationId\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{coalesce .OperationID (pathResource .Path) .Source | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Different handling for shared vs single-use schemas\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{if .IsShared}}Shared{{else}}{{.OperationID | pascalCase}}{{end}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Include response status code\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{.OperationID | pascalCase}}{{.StatusCode}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Tag-based naming\noastools join --schema-strategy rename-right --operation-context \\\n  --rename-template \"{{firstTag .Tags | pascalCase}}{{.Name}}\" \\\n  -o merged.yaml api1.yaml api2.yaml\n</code></pre>"},{"location":"packages/joiner/#overlay-integration","title":"Overlay Integration","text":"<p>Apply overlays during the join process:</p> <pre><code># Pre-overlay: applied to each input before merging\n# Post-overlay: applied to the final merged result\noastools join \\\n  --pre-overlay normalize.yaml \\\n  --post-overlay enhance.yaml \\\n  -o merged.yaml api1.yaml api2.yaml\n\n# Multiple overlays (applied in order)\noastools join \\\n  --pre-overlay strip-internal.yaml \\\n  --pre-overlay standardize-responses.yaml \\\n  --post-overlay add-security.yaml \\\n  --post-overlay add-metadata.yaml \\\n  -o merged.yaml api1.yaml api2.yaml\n</code></pre> <p>Example pre-overlay (normalize.yaml):</p> <pre><code>overlay: 1.0.0\ninfo:\n  title: Normalization Overlay\n  version: 1.0.0\nactions:\n  - target: $..description\n    update:\n      description: \"\"  # Clear all descriptions before merge\n</code></pre> <p>Example post-overlay (enhance.yaml):</p> <pre><code>overlay: 1.0.0\ninfo:\n  title: Enhancement Overlay\n  version: 1.0.0\nactions:\n  - target: $.info\n    update:\n      title: \"Unified API\"\n      version: \"1.0.0\"\n  - target: $.servers\n    update:\n      - url: https://api.example.com/v1\n        description: Production\n</code></pre>"},{"location":"packages/joiner/#combined-features","title":"Combined Features","text":"<p>Use multiple features together for comprehensive join operations:</p> <pre><code># Full-featured join with all options\noastools join \\\n  --schema-strategy rename-right \\\n  --operation-context \\\n  --primary-operation-policy most-specific \\\n  --rename-template \"{{coalesce .OperationID (pathResource .Path) | pascalCase}}{{.Name}}\" \\\n  --semantic-dedup \\\n  --pre-overlay normalize.yaml \\\n  --post-overlay finalize.yaml \\\n  -o merged.yaml \\\n  users-service.yaml orders-service.yaml billing-service.yaml\n</code></pre> <p>This command:</p> <ol> <li>Applies <code>normalize.yaml</code> to each input document</li> <li>Joins the documents with semantic deduplication</li> <li>Renames colliding schemas using operation context</li> <li>Uses the most-specific operation policy for context selection</li> <li>Applies <code>finalize.yaml</code> to the merged result</li> </ol> <p>For complete API documentation and programmatic usage, see the sections above or the Go package documentation.</p>"},{"location":"packages/joiner/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd17 Basic example - Merge two OpenAPI specifications</li> <li>\u2699\ufe0f Custom strategies example - Configure collision handling per component type</li> <li>\ud83e\uddf9 Semantic deduplication example - Consolidate identical schemas</li> </ul>"},{"location":"packages/overlay/","title":"Overlay","text":""},{"location":"packages/overlay/#overlay-package-deep-dive","title":"Overlay Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the overlay tool in your browser \u2192</p> <p>The <code>overlay</code> package implements the OpenAPI Overlay Specification v1.0.0, providing a standardized mechanism for augmenting OpenAPI documents through targeted transformations.</p>"},{"location":"packages/overlay/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>JSONPath Reference</li> <li>Configuration Reference</li> <li>Package Chaining</li> <li>Best Practices</li> </ul>"},{"location":"packages/overlay/#overview","title":"Overview","text":"<p>Overlays use JSONPath expressions to select specific locations in an OpenAPI document and apply updates or removals. This enables environment-specific customizations, removing internal endpoints for public APIs, or batch-updating descriptions across an entire specification.</p> <p>Common use cases:</p> <ul> <li>Remove internal/deprecated paths for public documentation</li> <li>Add environment-specific server URLs</li> <li>Update descriptions or metadata in bulk</li> <li>Add vendor extensions across multiple operations</li> </ul> <p>Back to top</p>"},{"location":"packages/overlay/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/overlay/#overlay-document-structure","title":"Overlay Document Structure","text":"<p>An overlay document contains:</p> <pre><code>overlay: 1.0.0\ninfo:\n  title: Production Customizations\n  version: 1.0.0\nextends: https://example.com/openapi.yaml  # Optional\nactions:\n  - target: $.info\n    update:\n      x-environment: production\n  - target: $.paths[?@.x-internal==true]\n    remove: true\n</code></pre>"},{"location":"packages/overlay/#action-types","title":"Action Types","text":"Type Description Update Merges content into matched nodes. Objects are recursively merged; arrays are appended. Remove Deletes matched nodes from their parent container. Takes precedence if both specified."},{"location":"packages/overlay/#dry-run-mode","title":"Dry-Run Mode","text":"<p>See also: Dry-run example on pkg.go.dev</p> <p>Preview changes without modifying the document:</p> <pre><code>result, _ := overlay.DryRunWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\nfor _, change := range result.Changes {\n    fmt.Printf(\"Would %s %d nodes at %s\\n\",\n        change.Operation, change.MatchCount, change.Target)\n}\n</code></pre> <p>Back to top</p>"},{"location":"packages/overlay/#api-styles","title":"API Styles","text":"<p>See also: Basic example, Validate example, Parse overlay example on pkg.go.dev</p>"},{"location":"packages/overlay/#functional-options-recommended","title":"Functional Options (Recommended)","text":"<pre><code>result, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Applied %d changes\\n\", result.ActionsApplied)\n</code></pre>"},{"location":"packages/overlay/#struct-based-reusable","title":"Struct-Based (Reusable)","text":"<pre><code>a := overlay.NewApplier()\na.StrictTargets = true  // Fail if any target matches nothing\n\nresult1, _ := a.Apply(\"api1.yaml\", \"overlay1.yaml\")\nresult2, _ := a.Apply(\"api2.yaml\", \"overlay2.yaml\")\n</code></pre>"},{"location":"packages/overlay/#pre-parsed-documents","title":"Pre-Parsed Documents","text":"<p>For performance when processing multiple overlays:</p> <pre><code>parseResult, _ := parser.ParseWithOptions(parser.WithFilePath(\"openapi.yaml\"))\noverlayDoc, _ := overlay.ParseOverlayFile(\"changes.yaml\")\n\nresult, _ := overlay.ApplyWithOptions(\n    overlay.WithSpecParsed(*parseResult),\n    overlay.WithOverlayParsed(overlayDoc),\n)\n</code></pre> <p>Back to top</p>"},{"location":"packages/overlay/#practical-examples","title":"Practical Examples","text":"<p>See also: Remove action example, Recursive descent example, Compound filter example on pkg.go.dev</p>"},{"location":"packages/overlay/#remove-internal-endpoints","title":"Remove Internal Endpoints","text":"<pre><code>o := &amp;overlay.Overlay{\n    Version: \"1.0.0\",\n    Info:    overlay.Info{Title: \"Remove Internal\", Version: \"1.0.0\"},\n    Actions: []overlay.Action{\n        {\n            Target: \"$.paths[?@.x-internal==true]\",\n            Remove: true,\n        },\n    },\n}\n</code></pre>"},{"location":"packages/overlay/#update-all-descriptions-recursive-descent","title":"Update All Descriptions (Recursive Descent)","text":"<pre><code>// Find and update ALL descriptions at any depth\no := &amp;overlay.Overlay{\n    Version: \"1.0.0\",\n    Info:    overlay.Info{Title: \"Update Descriptions\", Version: \"1.0.0\"},\n    Actions: []overlay.Action{\n        {\n            Target: \"$..description\",\n            Update: \"Updated by overlay\",\n        },\n    },\n}\n</code></pre>"},{"location":"packages/overlay/#compound-filters","title":"Compound Filters","text":"<pre><code>// Match paths that are BOTH deprecated AND internal\no := &amp;overlay.Overlay{\n    Version: \"1.0.0\",\n    Info:    overlay.Info{Title: \"Filter Test\", Version: \"1.0.0\"},\n    Actions: []overlay.Action{\n        {\n            Target: \"$.paths[?@.deprecated==true &amp;&amp; @.x-internal==true]\",\n            Update: map[string]any{\"x-removal-scheduled\": \"2025-01-01\"},\n        },\n    },\n}\n</code></pre>"},{"location":"packages/overlay/#validation-before-application","title":"Validation Before Application","text":"<pre><code>o, _ := overlay.ParseOverlayFile(\"changes.yaml\")\nif errs := overlay.Validate(o); len(errs) &gt; 0 {\n    for _, err := range errs {\n        fmt.Printf(\"Validation error: %s\\n\", err.Message)\n    }\n}\n</code></pre> <p>Back to top</p>"},{"location":"packages/overlay/#jsonpath-reference","title":"JSONPath Reference","text":"Expression Description Example <code>$.field</code> Root field access <code>$.info</code>, <code>$.paths</code> <code>$.paths['/users']</code> Bracket notation Access path by key <code>$.paths.*</code> Wildcard All paths <code>$.servers[0]</code> Array index First server <code>$.servers[-1]</code> Negative index Last server <code>$..field</code> Recursive descent Find field at any depth <code>[?@.key==value]</code> Simple filter Match by property <code>[?@.a==true &amp;&amp; @.b==false]</code> Compound AND Multiple conditions <code>[?@.a==true \\|\\| @.b==true]</code> Compound OR Either condition <p>Back to top</p>"},{"location":"packages/overlay/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/overlay/#functional-options","title":"Functional Options","text":"Option Description <code>WithSpecFilePath(path)</code> Path to OpenAPI specification file <code>WithSpecParsed(result)</code> Pre-parsed ParseResult <code>WithOverlayFilePath(path)</code> Path to overlay file <code>WithOverlayParsed(o)</code> Pre-parsed Overlay struct <code>WithStrictTargets(bool)</code> Fail if any target matches nothing"},{"location":"packages/overlay/#applier-fields","title":"Applier Fields","text":"Field Type Description <code>StrictTargets</code> <code>bool</code> When true, returns error if any action's target matches zero nodes"},{"location":"packages/overlay/#result-fields","title":"Result Fields","text":"<p>ApplyResult:</p> Field Type Description <code>Document</code> <code>any</code> The modified document <code>SourceFormat</code> <code>parser.SourceFormat</code> The original document format (YAML or JSON) <code>ActionsApplied</code> <code>int</code> Number of actions that matched and modified nodes <code>ActionsSkipped</code> <code>int</code> Number of actions with no matching targets <code>Changes</code> <code>[]ChangeRecord</code> Details of each applied change <code>Warnings</code> <code>[]string</code> Non-fatal warnings during application <code>StructuredWarnings</code> <code>ApplyWarnings</code> Detailed warning information with context <p><code>ToParseResult()</code> converts the result to <code>*parser.ParseResult</code> for package chaining.</p> <p>DryRunResult:</p> Field Type Description <code>WouldApply</code> <code>int</code> Number of actions that would be successfully applied <code>WouldSkip</code> <code>int</code> Number of actions that would be skipped <code>Changes</code> <code>[]ProposedChange</code> Proposed changes that would be made (different type than ApplyResult) <code>Warnings</code> <code>[]string</code> Non-fatal issues that would occur <code>StructuredWarnings</code> <code>ApplyWarnings</code> Detailed warning information with context <p>Back to top</p>"},{"location":"packages/overlay/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>ApplyResult</code> to a <code>parser.ParseResult</code>:</p> <pre><code>// Apply overlay then validate\napplyResult, err := overlay.ApplyWithOptions(\n    overlay.WithSpecFilePath(\"openapi.yaml\"),\n    overlay.WithOverlayFilePath(\"changes.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Chain to validator\nv := validator.New()\nvalResult, _ := v.ValidateParsed(*applyResult.ToParseResult())\nfmt.Printf(\"Valid: %v\\n\", valResult.Valid)\n\n// Or chain to converter\nc := converter.New()\nconvResult, _ := c.ConvertParsed(*applyResult.ToParseResult(), \"3.1.0\")\n</code></pre> <p>This enables workflows like: <code>parse \u2192 overlay \u2192 validate \u2192 convert</code></p> <p>Back to top</p>"},{"location":"packages/overlay/#best-practices","title":"Best Practices","text":"<ol> <li>Use dry-run first - Preview changes before applying to production specs (<code>oastools overlay apply --dry-run -s spec.yaml overlay.yaml</code>)</li> <li>Validate overlays - Call <code>overlay.Validate()</code> before application</li> <li>Order actions carefully - Actions are applied in order; earlier actions affect later ones</li> <li>Use StrictTargets in CI - Catch typos in JSONPath expressions</li> <li>Combine with converter - Use <code>WithPreConversionOverlayFile</code> and <code>WithPostConversionOverlayFile</code> for version migrations</li> </ol> <p>Back to top</p>"},{"location":"packages/overlay/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd0d Dry-run example - Preview changes without applying</li> <li>\u274c Remove action example - Remove nodes from documents</li> <li>\ud83d\udd04 Recursive descent example - Find fields at any depth</li> <li>\ud83e\uddea Compound filter example - Complex filter expressions</li> </ul>"},{"location":"packages/parser/","title":"Parser","text":""},{"location":"packages/parser/#parser-package-deep-dive","title":"Parser Package Deep Dive","text":"<p>The <code>parser</code> package provides parsing for OpenAPI Specification documents, supporting OAS 2.0 through OAS 3.2.0 in YAML and JSON formats.</p>"},{"location":"packages/parser/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>OAS 3.2.0 Features</li> <li>JSON Schema 2020-12 Support</li> <li>API Styles</li> <li>Practical Examples</li> <li>Configuration Reference</li> <li>Document Type Helpers</li> <li>Version-Agnostic Access (DocumentAccessor)</li> <li>Order-Preserving Marshaling</li> <li>Best Practices</li> </ul>"},{"location":"packages/parser/#overview","title":"Overview","text":"<p>The parser can load specifications from local files or remote URLs, resolve external references (<code>$ref</code>), validate structure, and preserve unknown fields for forward compatibility. It automatically detects the file format (JSON/YAML) and OAS version.</p> <p>Key capabilities:</p> <ul> <li>Parse files, URLs, readers, or byte slices</li> <li>Resolve local and external <code>$ref</code> references</li> <li>Detect and handle circular references safely</li> <li>Enforce configurable resource limits</li> <li>Preserve source format for downstream tools</li> </ul> <p>Back to top</p>"},{"location":"packages/parser/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/parser/#format-detection","title":"Format Detection","text":"<p>The parser automatically detects format from:</p> <ol> <li>File extension (<code>.json</code>, <code>.yaml</code>, <code>.yml</code>)</li> <li>Content inspection (JSON starts with <code>{</code> or <code>[</code>)</li> <li>Defaults to YAML if unknown</li> </ol>"},{"location":"packages/parser/#reference-resolution","title":"Reference Resolution","text":"<p>External <code>$ref</code> values are resolved when <code>ResolveRefs</code> is enabled:</p> Reference Type Example Security Local <code>#/components/schemas/User</code> Always allowed File <code>./common.yaml#/schemas/Error</code> Path traversal protected HTTP/HTTPS <code>https://example.com/schemas.yaml</code> Opt-in via <code>WithResolveHTTPRefs</code>"},{"location":"packages/parser/#circular-reference-handling","title":"Circular Reference Handling","text":"<p>When circular references are detected:</p> <ul> <li>The <code>$ref</code> node is left unresolved (preserves the <code>\"$ref\"</code> key)</li> <li>A warning is added to <code>result.Warnings</code></li> <li>The document remains valid for most operations</li> </ul> <p>Detection triggers:</p> <ul> <li>A <code>$ref</code> points to an ancestor in the current resolution path</li> <li>Resolution depth exceeds <code>MaxRefDepth</code> (default: 100)</li> </ul>"},{"location":"packages/parser/#resource-limits","title":"Resource Limits","text":"Limit Default Description <code>MaxRefDepth</code> 100 Maximum nested <code>$ref</code> resolution depth <code>MaxCachedDocuments</code> 100 Maximum external documents to cache <code>MaxFileSize</code> 10MB Maximum file size for external references <p>Back to top</p>"},{"location":"packages/parser/#oas-320-features","title":"OAS 3.2.0 Features","text":"<p>OAS 3.2.0 introduces several new capabilities that the parser fully supports:</p>"},{"location":"packages/parser/#document-identity-self","title":"Document Identity ($self)","text":"<p>The <code>$self</code> field provides a canonical URL for the document:</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\ndoc, _ := result.OAS3Document()\n\nif doc.Self != \"\" {\n    fmt.Printf(\"Document identity: %s\\n\", doc.Self)\n}\n</code></pre>"},{"location":"packages/parser/#additional-http-methods-additionaloperations","title":"Additional HTTP Methods (additionalOperations)","text":"<p>Custom HTTP methods beyond the standard set can be defined via <code>additionalOperations</code>:</p> <pre><code>pathItem := doc.Paths[\"/resource\"]\nfor method, op := range pathItem.AdditionalOperations {\n    fmt.Printf(\"Custom method %s: %s\\n\", method, op.OperationID)\n}\n\n// Use GetOperations to get all operations including custom methods\nallOps := parser.GetOperations(pathItem, parser.OASVersion320)\n</code></pre>"},{"location":"packages/parser/#reusable-media-types-componentsmediatypes","title":"Reusable Media Types (components/mediaTypes)","text":"<p>Media type definitions can be defined once and referenced:</p> <pre><code>if doc.Components != nil &amp;&amp; doc.Components.MediaTypes != nil {\n    for name, mediaType := range doc.Components.MediaTypes {\n        fmt.Printf(\"Media type %s: %v\\n\", name, mediaType.Schema)\n    }\n}\n</code></pre>"},{"location":"packages/parser/#query-method","title":"QUERY Method","text":"<p>OAS 3.2.0 adds native support for the QUERY HTTP method:</p> <pre><code>if pathItem.Query != nil {\n    fmt.Printf(\"QUERY operation: %s\\n\", pathItem.Query.OperationID)\n}\n</code></pre> <p>Back to top</p>"},{"location":"packages/parser/#json-schema-2020-12-support","title":"JSON Schema 2020-12 Support","text":"<p>The parser supports all JSON Schema Draft 2020-12 keywords used in OAS 3.1+:</p>"},{"location":"packages/parser/#content-keywords","title":"Content Keywords","text":"<p>For schemas representing encoded content:</p> Keyword Type Description <code>contentEncoding</code> <code>string</code> Encoding (e.g., \"base64\", \"base32\") <code>contentMediaType</code> <code>string</code> Media type of decoded content <code>contentSchema</code> <code>*Schema</code> Schema for decoded content <pre><code>schema := doc.Components.Schemas[\"EncodedData\"]\nif schema.ContentEncoding != \"\" {\n    fmt.Printf(\"Encoding: %s, Media type: %s\\n\",\n        schema.ContentEncoding, schema.ContentMediaType)\n}\n</code></pre>"},{"location":"packages/parser/#unevaluated-keywords","title":"Unevaluated Keywords","text":"<p>For strict validation of object and array schemas:</p> Keyword Type Description <code>unevaluatedProperties</code> <code>any</code> <code>*Schema</code>, <code>bool</code>, or <code>map[string]any</code> for uncovered properties <code>unevaluatedItems</code> <code>any</code> <code>*Schema</code>, <code>bool</code>, or <code>map[string]any</code> for uncovered array items <pre><code>schema := doc.Components.Schemas[\"StrictObject\"]\nswitch v := schema.UnevaluatedProperties.(type) {\ncase *parser.Schema:\n    // Typed schema - most common after parsing\n    fmt.Printf(\"Unevaluated properties must match: %s\\n\", v.Ref)\ncase bool:\n    // Boolean value - false disallows, true allows any\n    fmt.Printf(\"Unevaluated properties allowed: %v\\n\", v)\ncase map[string]any:\n    // Raw map - when schema wasn't typed during parsing\n    if ref, ok := v[\"$ref\"].(string); ok {\n        fmt.Printf(\"Raw ref to: %s\\n\", ref)\n    }\ndefault:\n    // nil or unexpected type\n    fmt.Println(\"No unevaluatedProperties constraint\")\n}\n</code></pre>"},{"location":"packages/parser/#array-index-references","title":"Array Index References","text":"<p>JSON Pointer references now support array indices per RFC 6901:</p> <pre><code># Example: Reference the first parameter's schema\n$ref: '#/paths/~1users/get/parameters/0/schema'\n</code></pre> <p>The resolver handles:</p> <ul> <li>Valid indices: <code>0</code>, <code>1</code>, <code>2</code>, etc.</li> <li>Out-of-bounds errors with descriptive messages</li> <li>Non-numeric index errors</li> </ul> <p>Back to top</p>"},{"location":"packages/parser/#api-styles","title":"API Styles","text":"<p>See also: Basic example, Functional options example, Reusable parser example on pkg.go.dev</p>"},{"location":"packages/parser/#functional-options-recommended","title":"Functional Options (Recommended)","text":"<pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithValidateStructure(true),\n    parser.WithResolveRefs(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"packages/parser/#struct-based-reusable","title":"Struct-Based (Reusable)","text":"<pre><code>p := parser.New()\np.ResolveRefs = false\np.ValidateStructure = true\n\nresult1, _ := p.Parse(\"api1.yaml\")\nresult2, _ := p.Parse(\"api2.yaml\")\n</code></pre>"},{"location":"packages/parser/#alternative-input-sources","title":"Alternative Input Sources","text":"<pre><code>// From URL\nresult, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"https://example.com/api/openapi.yaml\"),\n)\n\n// From reader\nresult, _ := p.ParseReader(reader, \"config.yaml\")\n\n// From bytes\nresult, _ := p.ParseBytes(data, \"inline.yaml\")\n</code></pre> <p>Back to top</p>"},{"location":"packages/parser/#practical-examples","title":"Practical Examples","text":""},{"location":"packages/parser/#basic-file-parsing","title":"Basic File Parsing","text":"<pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n)\nif err != nil {\n    log.Fatal(err)\n}\nif len(result.Errors) &gt; 0 {\n    fmt.Printf(\"Parse errors: %d\\n\", len(result.Errors))\n}\nfmt.Printf(\"Parsed %s v%s\\n\", result.Version, result.OASVersion)\n</code></pre>"},{"location":"packages/parser/#http-reference-resolution","title":"HTTP Reference Resolution","text":"<p>See also: HTTP refs example, Parse from URL example on pkg.go.dev</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithResolveHTTPRefs(true),      // Enable HTTP refs\n    parser.WithInsecureSkipVerify(true),   // For self-signed certs\n)\n</code></pre>"},{"location":"packages/parser/#custom-resource-limits","title":"Custom Resource Limits","text":"<pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"large-api.yaml\"),\n    parser.WithMaxRefDepth(50),\n    parser.WithMaxCachedDocuments(200),\n    parser.WithMaxFileSize(20*1024*1024), // 20MB\n)\n</code></pre>"},{"location":"packages/parser/#safe-document-mutation-with-deepcopy","title":"Safe Document Mutation with DeepCopy","text":"<p>See also: DeepCopy example on pkg.go.dev</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\n\n// Get the typed document\ndoc, _ := result.OAS3Document()\n\n// Deep copy before mutation\ndocCopy := doc.DeepCopy()\ndocCopy.Info.Title = \"Modified API\"\n\n// Original unchanged\nfmt.Println(doc.Info.Title) // Original title\n</code></pre> <p>Back to top</p>"},{"location":"packages/parser/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/parser/#functional-options","title":"Functional Options","text":"Option Description <code>WithFilePath(path)</code> File path or URL to parse <code>WithBytes(data []byte)</code> Parse from byte slice <code>WithReader(r io.Reader)</code> Parse from an io.Reader <code>WithResolveRefs(bool)</code> Enable <code>$ref</code> resolution (default: true) <code>WithResolveHTTPRefs(bool)</code> Enable HTTP/HTTPS ref resolution (default: false) <code>WithValidateStructure(bool)</code> Validate document structure during parsing <code>WithInsecureSkipVerify(bool)</code> Skip TLS verification for HTTPS refs <code>WithSourceMap(enabled bool)</code> Enable source map tracking for line/column info <code>WithPreserveOrder(enabled bool)</code> Preserve original field ordering from source <code>WithUserAgent(ua string)</code> Custom User-Agent for HTTP requests <code>WithHTTPClient(client *http.Client)</code> Custom HTTP client for remote refs <code>WithMaxRefDepth(n)</code> Max nested ref depth (default: 100) <code>WithMaxCachedDocuments(n)</code> Max cached external docs (default: 100) <code>WithMaxFileSize(n)</code> Max file size in bytes (default: 10MB) <code>WithMaxInputSize(size int)</code> Max input size in bytes <code>WithSourceName(name string)</code> Override source name for bytes/reader input"},{"location":"packages/parser/#parseresult-fields","title":"ParseResult Fields","text":"Field Type Description <code>Document</code> <code>any</code> Parsed document (OAS2Document or OAS3Document) <code>Version</code> <code>string</code> Raw version string from document <code>OASVersion</code> <code>OASVersion</code> Parsed version constant <code>SourceFormat</code> <code>SourceFormat</code> Detected format (JSON or YAML) <code>SourcePath</code> <code>string</code> Original file path <code>Errors</code> <code>[]error</code> Parse errors <code>Warnings</code> <code>[]string</code> Non-fatal warnings <p>Back to top</p>"},{"location":"packages/parser/#document-type-helpers","title":"Document Type Helpers","text":"<p>See also: Document type helpers example on pkg.go.dev</p> <p>ParseResult provides convenient methods for version checking and type assertion:</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\n\n// Version checking\nif result.IsOAS2() {\n    fmt.Println(\"This is a Swagger 2.0 document\")\n}\nif result.IsOAS3() {\n    fmt.Println(\"This is an OAS 3.x document\")\n}\n\n// Safe type assertion\nif doc, ok := result.OAS3Document(); ok {\n    fmt.Printf(\"API: %s v%s\\n\", doc.Info.Title, doc.Info.Version)\n}\nif doc, ok := result.OAS2Document(); ok {\n    fmt.Printf(\"Swagger: %s v%s\\n\", doc.Info.Title, doc.Info.Version)\n}\n</code></pre> <p>Back to top</p>"},{"location":"packages/parser/#version-agnostic-access-documentaccessor","title":"Version-Agnostic Access (DocumentAccessor)","text":"<p>See also: DocumentAccessor example on pkg.go.dev</p> <p>For code that needs to work uniformly across both OAS 2.0 and 3.x documents without type switches, use the <code>DocumentAccessor</code> interface:</p> <pre><code>result, _ := parser.ParseWithOptions(parser.WithFilePath(\"api.yaml\"))\nif accessor := result.AsAccessor(); accessor != nil {\n    // These methods work identically for both versions\n    for path := range accessor.GetPaths() {\n        fmt.Println(\"Path:\", path)\n    }\n\n    // GetSchemas() abstracts the difference:\n    // - OAS 2.0: returns doc.Definitions\n    // - OAS 3.x: returns doc.Components.Schemas\n    for name := range accessor.GetSchemas() {\n        fmt.Println(\"Schema:\", name)\n    }\n\n    // Get the $ref prefix for schema references\n    fmt.Println(\"Prefix:\", accessor.SchemaRefPrefix())\n}\n</code></pre>"},{"location":"packages/parser/#documentaccessor-methods","title":"DocumentAccessor Methods","text":"Method OAS 2.0 Source OAS 3.x Source <code>GetInfo()</code> <code>doc.Info</code> <code>doc.Info</code> <code>GetPaths()</code> <code>doc.Paths</code> <code>doc.Paths</code> <code>GetSchemas()</code> <code>doc.Definitions</code> <code>doc.Components.Schemas</code> <code>GetSecuritySchemes()</code> <code>doc.SecurityDefinitions</code> <code>doc.Components.SecuritySchemes</code> <code>GetParameters()</code> <code>doc.Parameters</code> <code>doc.Components.Parameters</code> <code>GetResponses()</code> <code>doc.Responses</code> <code>doc.Components.Responses</code> <code>SchemaRefPrefix()</code> <code>#/definitions/</code> <code>#/components/schemas/</code> <p>Back to top</p>"},{"location":"packages/parser/#order-preserving-marshaling","title":"Order-Preserving Marshaling","text":"<p>The parser can preserve original field ordering from source documents, enabling deterministic output for hash-based caching and diff-friendly serialization.</p>"},{"location":"packages/parser/#why-it-matters","title":"Why It Matters","text":"<ol> <li> <p>Hash stability: When caching parsed specs by content hash, roundtrip through parse-then-marshal should produce identical output. Without preserved order, map iteration order causes non-deterministic output.</p> </li> <li> <p>Diff-friendly: Editing and re-serializing specs should minimize diffs. Alphabetical reordering of all keys makes diffs noisy and hard to review.</p> </li> <li> <p>Human readability: Authors typically place important fields like <code>openapi</code>, <code>info</code>, and <code>paths</code> at the top. Preserving this order maintains the document's logical structure.</p> </li> </ol>"},{"location":"packages/parser/#how-it-works","title":"How It Works","text":"<p>When <code>WithPreserveOrder(true)</code> is enabled:</p> <ol> <li>Source tree storage: The parser stores the original <code>yaml.Node</code> tree alongside the typed document</li> <li>Key order extraction: During marshal, keys are extracted from source nodes in original order</li> <li>Extra key handling: Keys added during processing (not in source) are sorted alphabetically and appended</li> <li>Performance: O(n) with hash-based indexing for child node lookup</li> </ol>"},{"location":"packages/parser/#when-to-use-it","title":"When to Use It","text":"Use Case Recommendation Hash-based caching Enable - ensures roundtrip identity CI pipelines comparing output Enable - deterministic output Version control of specs Enable - cleaner diffs One-off validation Disable - lower memory overhead Programmatic construction N/A - no source order available"},{"location":"packages/parser/#code-examples","title":"Code Examples","text":"<p>Parsing with order preservation:</p> <pre><code>result, err := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithPreserveOrder(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Check if order information is available\nif result.HasPreservedOrder() {\n    fmt.Println(\"Order was preserved from source\")\n}\n</code></pre> <p>JSON output with preserved order:</p> <pre><code>// Compact JSON\njsonBytes, err := result.MarshalOrderedJSON()\n\n// Indented JSON\njsonIndented, err := result.MarshalOrderedJSONIndent(\"\", \"  \")\n</code></pre> <p>YAML output with preserved order:</p> <pre><code>yamlBytes, err := result.MarshalOrderedYAML()\n</code></pre>"},{"location":"packages/parser/#fallback-behavior","title":"Fallback Behavior","text":"<p>When <code>PreserveOrder</code> is not enabled (or for programmatically constructed documents), the ordered marshal methods fall back to standard marshaling:</p> <ul> <li>JSON: Uses <code>encoding/json</code> which sorts map keys alphabetically</li> <li>YAML: Uses <code>go.yaml.in/yaml/v4</code> which also sorts keys alphabetically</li> </ul> <p>This ensures deterministic output in all cases, just without preserving the original order.</p>"},{"location":"packages/parser/#memory-overhead","title":"Memory Overhead","text":"<p>Enabling <code>PreserveOrder</code> stores an additional <code>*yaml.Node</code> tree in the <code>ParseResult</code>. For typical API specs:</p> Spec Size Approximate Overhead Small (&lt;1KB) ~2-5KB Medium (10-50KB) ~20-100KB Large (&gt;100KB) ~200KB+ <p>For most use cases, this overhead is negligible compared to the benefits of deterministic output.</p>"},{"location":"packages/parser/#limitations","title":"Limitations","text":"<ul> <li>Only works when parsing from source (file, bytes, reader)</li> <li>Not available for documents constructed programmatically via the builder package</li> <li>Source node structure must match parsed document structure for correct ordering</li> </ul> <p>Back to top</p>"},{"location":"packages/parser/#best-practices","title":"Best Practices","text":"<ol> <li>Parse once, use many - Cache ParseResult for operations like validate, convert, diff</li> <li>Use pre-parsed methods - <code>ValidateParsed()</code>, <code>ConvertParsed()</code>, etc. are 9-150x faster</li> <li>Check warnings for circular refs - They indicate unresolved references</li> <li>Enable HTTP refs carefully - Only for trusted sources; use <code>WithInsecureSkipVerify</code> sparingly</li> <li>Use DeepCopy for mutations - Never modify the original parsed document</li> </ol> <p>Back to top</p>"},{"location":"packages/parser/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\ud83d\udd27 Functional options example - Configure parsing with options</li> <li>\ud83c\udf10 HTTP refs example - Resolve external HTTP references</li> <li>\ud83d\udccb DeepCopy example - Safe document mutation</li> <li>\ud83d\udd0d Type helpers example - Version checking and type assertions</li> <li>\ud83d\udd00 DocumentAccessor example - Version-agnostic document access</li> </ul>"},{"location":"packages/validator/","title":"Validator","text":""},{"location":"packages/validator/#validator-package-deep-dive","title":"Validator Package Deep Dive","text":"<p>Try it Online</p> <p>No installation required! Try the validator in your browser \u2192</p>"},{"location":"packages/validator/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Key Concepts</li> <li>API Styles</li> <li>Practical Examples</li> <li>Validation Coverage</li> <li>Validation Result Structure</li> <li>Operation Context</li> <li>Configuration Reference</li> <li>Source Map Integration</li> <li>Package Chaining</li> <li>Best Practices</li> </ul> <p>The <code>validator</code> package performs comprehensive validation of OpenAPI Specification documents against their declared version. It checks structural correctness, semantic constraints, format compliance, and best practices, producing detailed error reports with specification references for every issue found.</p>"},{"location":"packages/validator/#overview","title":"Overview","text":"<p>Validation ensures your OpenAPI documents are correct before using them for code generation, documentation, or API gateway configuration. The validator catches issues ranging from missing required fields to invalid reference targets, malformed URLs, and inconsistent parameter declarations.</p> <p>The validator supports OAS 2.0 through OAS 3.2.0, automatically adapting its rules to match the declared specification version. Each validation error includes a reference to the relevant section of the OpenAPI Specification, making it easy to understand why something is flagged and how to fix it.</p> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#key-concepts","title":"Key Concepts","text":""},{"location":"packages/validator/#validation-vs-parsing","title":"Validation vs Parsing","text":"<p>Understanding the distinction between parsing and validation is important. The parser converts YAML or JSON into structured Go types, performing basic syntax checking but minimal semantic validation. The validator then examines the parsed structure for specification compliance.</p> <p>This separation allows you to parse a document (which might have validation errors) to understand its structure, then validate it to identify issues. It also enables the 30x performance improvement when using <code>ValidateParsed</code> on pre-parsed documents.</p>"},{"location":"packages/validator/#severity-levels","title":"Severity Levels","text":"<p>Validation issues are categorized by severity, helping you prioritize fixes and configure appropriate behavior for your workflow.</p> <p>SeverityError indicates specification violations that make the document invalid according to the OpenAPI Specification. These must be fixed for the document to be compliant.</p> <p>SeverityWarning indicates best practice violations or recommendations that don't prevent the document from being technically valid but may cause issues with tooling or API consumers. Examples include operations without descriptions, trailing slashes in paths, or deprecated patterns.</p> <p>SeverityInfo indicates informational messages that may be useful for debugging or understanding validator behavior but don't require action.</p> <p>SeverityCritical indicates severe issues that prevent further processing. These are rare and typically indicate fundamental document problems.</p>"},{"location":"packages/validator/#strict-mode","title":"Strict Mode","text":"<p>By default, the validator reports errors separately from warnings, and a document is considered valid if it has no errors (warnings are allowed). Strict mode changes this behavior, treating warnings as errors and requiring the document to be warning-free to be considered valid.</p> <p>Use strict mode in CI/CD pipelines where you want to enforce best practices, not just specification compliance.</p> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#api-styles","title":"API Styles","text":"<p>See also: Basic example, Strict mode example, Custom validation example on pkg.go.dev</p>"},{"location":"packages/validator/#functional-options-api","title":"Functional Options API","text":"<p>Best for one-off validations with inline configuration:</p> <pre><code>result, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"openapi.yaml\"),\n    validator.WithIncludeWarnings(true),\n    validator.WithStrictMode(false),\n)\n</code></pre>"},{"location":"packages/validator/#struct-based-api","title":"Struct-Based API","text":"<p>Best for validating multiple documents with consistent configuration:</p> <pre><code>v := validator.New()\nv.IncludeWarnings = true\nv.StrictMode = true\n\nresult1, _ := v.Validate(\"api1.yaml\")\nresult2, _ := v.Validate(\"api2.yaml\")\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#practical-examples","title":"Practical Examples","text":""},{"location":"packages/validator/#basic-validation","title":"Basic Validation","text":"<p>The simplest use case validates a single specification file:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    result, err := validator.ValidateWithOptions(\n        validator.WithFilePath(\"openapi.yaml\"),\n        validator.WithIncludeWarnings(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"OAS Version: %s\\n\", result.Version)\n    fmt.Printf(\"Valid: %v\\n\", result.Valid)\n    fmt.Printf(\"Errors: %d\\n\", result.ErrorCount)\n    fmt.Printf(\"Warnings: %d\\n\", result.WarningCount)\n\n    if !result.Valid {\n        fmt.Println(\"\\nValidation Errors:\")\n        for _, e := range result.Errors {\n            fmt.Printf(\"  [%s] %s: %s\\n\", e.Severity, e.Path, e.Message)\n            if e.SpecRef != \"\" {\n                fmt.Printf(\"       Spec: %s\\n\", e.SpecRef)\n            }\n        }\n    }\n\n    if result.WarningCount &gt; 0 {\n        fmt.Println(\"\\nWarnings:\")\n        for _, w := range result.Warnings {\n            fmt.Printf(\"  [%s] %s: %s\\n\", w.Severity, w.Path, w.Message)\n        }\n    }\n}\n</code></pre> <p>Example Input (with issues):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: Test API\n  # Missing required 'version' field\npaths:\n  /users/:           # Trailing slash (warning)\n    get:\n      # Missing operationId (warning)\n      responses:\n        '200':\n          # Missing description (error)\n  /users/{userId}:\n    get:\n      operationId: getUser\n      # Missing declaration for 'userId' path parameter (error)\n      responses:\n        '200':\n          description: Success\n</code></pre> <p>Example Output:</p> <pre><code>OAS Version: 3.0.3\nValid: false\nErrors: 3\nWarnings: 2\n\nValidation Errors:\n  [error] info.version: missing required field 'version'\n       Spec: https://spec.openapis.org/oas/v3.0.3.html#info-object\n  [error] paths./users/.get.responses.200: missing required field 'description'\n       Spec: https://spec.openapis.org/oas/v3.0.3.html#response-object\n  [error] paths./users/{userId}.get: Path template references parameter '{userId}' but it is not declared in parameters\n       Spec: https://spec.openapis.org/oas/v3.0.3.html#path-item-object\n\nWarnings:\n  [warning] paths./users/: Path should not have a trailing slash\n  [warning] paths./users/.get: Operation should have an operationId\n</code></pre>"},{"location":"packages/validator/#strict-mode-for-cicd","title":"Strict Mode for CI/CD","text":"<p>Enforce both specification compliance and best practices:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    result, err := validator.ValidateWithOptions(\n        validator.WithFilePath(\"openapi.yaml\"),\n        validator.WithIncludeWarnings(true),\n        validator.WithStrictMode(true),  // Treat warnings as errors\n    )\n    if err != nil {\n        log.Fatalf(\"Validation failed: %v\", err)\n    }\n\n    if !result.Valid {\n        fmt.Fprintf(os.Stderr, \"\u274c Validation failed\\n\")\n        fmt.Fprintf(os.Stderr, \"   Errors: %d\\n\", result.ErrorCount)\n        fmt.Fprintf(os.Stderr, \"   Warnings (treated as errors): %d\\n\", result.WarningCount)\n\n        // Print all issues\n        allIssues := append(result.Errors, result.Warnings...)\n        for _, issue := range allIssues {\n            fmt.Fprintf(os.Stderr, \"\\n[%s] %s\\n\", issue.Severity, issue.Path)\n            fmt.Fprintf(os.Stderr, \"  %s\\n\", issue.Message)\n        }\n\n        os.Exit(1)\n    }\n\n    fmt.Println(\"\u2713 Validation passed (including best practices)\")\n}\n</code></pre>"},{"location":"packages/validator/#high-performance-validation-with-pre-parsed-documents","title":"High-Performance Validation with Pre-Parsed Documents","text":"<p>When integrating validation into a pipeline that also uses other oastools packages, parse once and reuse the result for 30x faster validation:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    // Parse once\n    parseResult, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n        parser.WithValidateStructure(true),\n    )\n    if err != nil {\n        log.Fatalf(\"Parse failed: %v\", err)\n    }\n\n    // Validate using pre-parsed document (30x faster)\n    start := time.Now()\n    valResult, err := validator.ValidateWithOptions(\n        validator.WithParsed(*parseResult),\n        validator.WithIncludeWarnings(true),\n    )\n    elapsed := time.Since(start)\n\n    if err != nil {\n        log.Fatalf(\"Validation failed: %v\", err)\n    }\n\n    fmt.Printf(\"Validation completed in %v\\n\", elapsed)\n    fmt.Printf(\"Valid: %v\\n\", valResult.Valid)\n\n    // parseResult can now be used with other packages\n    // (fixer, converter, joiner, generator) without re-parsing\n}\n</code></pre>"},{"location":"packages/validator/#validating-multiple-documents","title":"Validating Multiple Documents","text":"<p>For batch validation scenarios:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"path/filepath\"\n\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    // Create reusable validator\n    v := validator.New()\n    v.IncludeWarnings = true\n    v.StrictMode = false\n\n    // Find all OpenAPI files\n    files, err := filepath.Glob(\"specs/*.yaml\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    var failed []string\n\n    for _, file := range files {\n        result, err := v.Validate(file)\n        if err != nil {\n            log.Printf(\"Error validating %s: %v\", file, err)\n            failed = append(failed, file)\n            continue\n        }\n\n        if result.Valid {\n            fmt.Printf(\"\u2713 %s (warnings: %d)\\n\", file, result.WarningCount)\n        } else {\n            fmt.Printf(\"\u2717 %s (errors: %d, warnings: %d)\\n\", \n                file, result.ErrorCount, result.WarningCount)\n            failed = append(failed, file)\n        }\n    }\n\n    if len(failed) &gt; 0 {\n        fmt.Printf(\"\\n%d/%d files failed validation\\n\", len(failed), len(files))\n    } else {\n        fmt.Printf(\"\\nAll %d files passed validation\\n\", len(files))\n    }\n}\n</code></pre>"},{"location":"packages/validator/#processing-validation-errors-programmatically","title":"Processing Validation Errors Programmatically","text":"<p>Extract and categorize validation issues for custom reporting:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"strings\"\n\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    result, err := validator.ValidateWithOptions(\n        validator.WithFilePath(\"openapi.yaml\"),\n        validator.WithIncludeWarnings(true),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Categorize errors by location\n    bySection := make(map[string][]validator.ValidationError)\n\n    for _, e := range result.Errors {\n        // Extract top-level section from path\n        section := \"document\"\n        if parts := strings.SplitN(e.Path, \".\", 2); len(parts) &gt; 0 {\n            section = parts[0]\n        }\n        bySection[section] = append(bySection[section], e)\n    }\n\n    // Report by section\n    for section, errors := range bySection {\n        fmt.Printf(\"\\n%s issues (%d):\\n\", strings.ToUpper(section), len(errors))\n        for _, e := range errors {\n            fmt.Printf(\"  \u2022 %s: %s\\n\", e.Path, e.Message)\n        }\n    }\n\n    // Identify patterns\n    missingFields := 0\n    invalidRefs := 0\n    formatErrors := 0\n\n    for _, e := range result.Errors {\n        switch {\n        case strings.Contains(e.Message, \"missing required\"):\n            missingFields++\n        case strings.Contains(e.Message, \"does not resolve\"):\n            invalidRefs++\n        case strings.Contains(e.Message, \"Invalid\"):\n            formatErrors++\n        }\n    }\n\n    fmt.Printf(\"\\nError patterns:\\n\")\n    fmt.Printf(\"  Missing required fields: %d\\n\", missingFields)\n    fmt.Printf(\"  Invalid references: %d\\n\", invalidRefs)\n    fmt.Printf(\"  Format errors: %d\\n\", formatErrors)\n}\n</code></pre>"},{"location":"packages/validator/#validation-with-custom-user-agent","title":"Validation with Custom User Agent","text":"<p>When validating specifications from URLs, set a custom User-Agent:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    result, err := validator.ValidateWithOptions(\n        validator.WithFilePath(\"https://api.example.com/openapi.yaml\"),\n        validator.WithUserAgent(\"MyValidationTool/1.0\"),\n        validator.WithIncludeWarnings(true),\n    )\n    if err != nil {\n        log.Fatalf(\"Validation failed: %v\", err)\n    }\n\n    log.Printf(\"Valid: %v, Load time: %v\", result.Valid, result.LoadTime)\n}\n</code></pre>"},{"location":"packages/validator/#integration-with-fixer","title":"Integration with Fixer","text":"<p>A common pattern validates, identifies fixable issues, applies fixes, and re-validates:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/erraggy/oastools/fixer\"\n    \"github.com/erraggy/oastools/parser\"\n    \"github.com/erraggy/oastools/validator\"\n)\n\nfunc main() {\n    // Parse once\n    parseResult, err := parser.ParseWithOptions(\n        parser.WithFilePath(\"openapi.yaml\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Initial validation\n    valResult, _ := validator.ValidateWithOptions(\n        validator.WithParsed(*parseResult),\n    )\n\n    fmt.Printf(\"Initial validation: %d errors\\n\", valResult.ErrorCount)\n\n    if !valResult.Valid {\n        // Attempt automatic fixes\n        fixResult, err := fixer.FixWithOptions(\n            fixer.WithParsed(*parseResult),\n            fixer.WithInferTypes(true),\n        )\n        if err != nil {\n            log.Fatalf(\"Fixer failed: %v\", err)\n        }\n\n        if fixResult.HasFixes() {\n            fmt.Printf(\"Applied %d fixes\\n\", fixResult.FixCount)\n\n            // Re-validate fixed document\n            // Create a new ParseResult from the fixed document\n            fixedParse := &amp;parser.ParseResult{\n                Document:   fixResult.Document,\n                Version:    parseResult.Version,\n                OASVersion: parseResult.OASVersion,\n            }\n\n            valResult, _ = validator.ValidateWithOptions(\n                validator.WithParsed(*fixedParse),\n            )\n\n            fmt.Printf(\"After fixes: %d errors\\n\", valResult.ErrorCount)\n        }\n    }\n\n    if valResult.Valid {\n        fmt.Println(\"\u2713 Document is valid\")\n    } else {\n        fmt.Println(\"\u2717 Manual fixes required:\")\n        for _, e := range valResult.Errors {\n            fmt.Printf(\"  %s: %s\\n\", e.Path, e.Message)\n        }\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#validation-coverage","title":"Validation Coverage","text":"<p>The validator performs comprehensive checks across all document sections. Understanding what's validated helps you interpret results and know what to expect.</p>"},{"location":"packages/validator/#info-object-validation","title":"Info Object Validation","text":"<p>The validator checks that required fields are present and formats are correct.</p> <p>Checked Fields:</p> <ul> <li><code>title</code> (required)</li> <li><code>version</code> (required)</li> <li><code>termsOfService</code> (URL format when present)</li> <li><code>contact.url</code> (URL format when present)</li> <li><code>contact.email</code> (email format when present)</li> <li><code>license.url</code> (URL format when present)</li> </ul>"},{"location":"packages/validator/#path-validation","title":"Path Validation","text":"<p>Paths receive thorough structural and semantic validation.</p> <p>Path Template Checks:</p> <ul> <li>Properly formed parameter placeholders (<code>{paramName}</code>)</li> <li>No unclosed braces</li> <li>No reserved characters in parameter names</li> <li>No consecutive slashes (<code>//</code>)</li> <li>Trailing slash warnings (best practice)</li> </ul> <p>Path Parameter Consistency:</p> <ul> <li>Every <code>{param}</code> in the path template must have a corresponding parameter definition with <code>in: path</code></li> <li>Path parameters must be marked as <code>required: true</code></li> <li>Declared path parameters should be used in the template</li> </ul>"},{"location":"packages/validator/#operation-validation","title":"Operation Validation","text":"<p>Each operation (GET, POST, PUT, etc.) is validated for completeness and correctness.</p> <p>Required Checks:</p> <ul> <li><code>responses</code> object must be present</li> <li>At least one response code or <code>default</code> response</li> <li>Each response must have a <code>description</code></li> </ul> <p>Best Practice Warnings:</p> <ul> <li>Missing <code>operationId</code></li> <li>Missing <code>summary</code> or <code>description</code></li> <li>Duplicate <code>operationId</code> values across operations</li> </ul>"},{"location":"packages/validator/#parameter-validation","title":"Parameter Validation","text":"<p>Parameters are checked for correct structure and usage.</p> <p>Structural Checks:</p> <ul> <li><code>name</code> is required</li> <li><code>in</code> is required and must be one of: path, query, header, cookie</li> <li>Path parameters must have <code>required: true</code></li> <li>Schema or content must be defined (OAS 3.x)</li> </ul> <p>Format Checks:</p> <ul> <li>Valid parameter types and formats</li> <li>Consistent use of serialization styles</li> </ul>"},{"location":"packages/validator/#schemadefinition-validation","title":"Schema/Definition Validation","text":"<p>Component schemas undergo structural validation.</p> <p>Checked Items:</p> <ul> <li>Valid <code>type</code> values when present</li> <li>Correct <code>format</code> for the specified <code>type</code></li> <li><code>$ref</code> targets must resolve to existing schemas</li> <li>Nested schema structures (allOf, oneOf, anyOf, properties)</li> </ul> <p>Reference Validation:</p> <ul> <li><code>$ref</code> uses correct path format for the OAS version</li> <li>Referenced schemas exist in components/definitions</li> <li>No circular references that would cause infinite loops</li> </ul>"},{"location":"packages/validator/#security-scheme-validation","title":"Security Scheme Validation","text":"<p>Security definitions are validated for completeness.</p> <p>Checked by Type:</p> <ul> <li><code>apiKey</code>: <code>name</code> and <code>in</code> are required</li> <li><code>http</code>: <code>scheme</code> is required</li> <li><code>oauth2</code>: <code>flows</code> object with required flow properties</li> <li><code>openIdConnect</code>: <code>openIdConnectUrl</code> is required and valid URL</li> </ul>"},{"location":"packages/validator/#server-validation-oas-3x","title":"Server Validation (OAS 3.x)","text":"<p>Server objects are checked for correct structure.</p> <p>Checked Items:</p> <ul> <li><code>url</code> is required and valid format</li> <li>Server variables have <code>default</code> values</li> <li>Variable placeholders in URL match defined variables</li> </ul> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#validation-result-structure","title":"Validation Result Structure","text":"<pre><code>type ValidationResult struct {\n    // Valid is true if no errors were found (warnings allowed)\n    Valid bool\n\n    // Version is the detected OAS version string (e.g., \"3.0.3\")\n    Version string\n\n    // OASVersion is the enumerated version\n    OASVersion parser.OASVersion\n\n    // Document contains the validated document (*parser.OAS2Document or *parser.OAS3Document)\n    Document any\n\n    // SourceFormat preserves the original document format for output\n    SourceFormat parser.SourceFormat\n\n    // SourcePath is the original source path from the parsed document\n    SourcePath string\n\n    // Errors contains all validation errors\n    Errors []ValidationError\n\n    // Warnings contains all validation warnings (if IncludeWarnings is true)\n    Warnings []ValidationError\n\n    // Counts\n    ErrorCount   int\n    WarningCount int\n\n    // Performance metrics\n    LoadTime   time.Duration\n    SourceSize int64\n\n    // Document statistics\n    Stats parser.DocumentStats\n}\n\n// ToParseResult converts the validation result to a ParseResult for use with other packages.\nfunc (r *ValidationResult) ToParseResult() *parser.ParseResult\n\ntype ValidationError struct {\n    // Path is the JSON path to the issue location\n    Path string\n\n    // Message describes the issue\n    Message string\n\n    // Severity indicates the issue level\n    Severity Severity\n\n    // SpecRef is a URL to the relevant specification section\n    SpecRef string\n\n    // Field is the specific field that has the issue (optional)\n    Field string\n\n    // Value is the problematic value (optional)\n    Value any\n\n    // OperationContext provides API operation context (optional)\n    OperationContext *issues.OperationContext\n}\n</code></pre>"},{"location":"packages/validator/#operation-context","title":"Operation Context","text":"<p>Validation errors now include operation context to help identify which API endpoint is affected. This makes debugging significantly easier, especially for errors in shared components where the connection to a specific endpoint isn't obvious from the error path alone.</p> <pre><code>// Operation-level errors include method, path, and operationId\nerr.OperationContext = &amp;issues.OperationContext{\n    Method:      \"GET\",\n    Path:        \"/users/{id}\",\n    OperationID: \"getUser\",\n}\n// Renders as: paths./users/{id}.get.parameters[0] (operationId: getUser): ...\n\n// Path-level errors show only the path\nerr.OperationContext = &amp;issues.OperationContext{\n    Path: \"/users/{id}\",\n}\n// Renders as: paths./users/{id}.parameters[0] (path: /users/{id}): ...\n\n// Shared component errors show referencing operations\nerr.OperationContext = &amp;issues.OperationContext{\n    Method:              \"GET\",\n    Path:                \"/users\",\n    OperationID:         \"listUsers\",\n    IsReusableComponent: true,\n    AdditionalRefs:      3,\n}\n// Renders as: components.schemas.User.properties.email (operationId: listUsers, +3 operations): ...\n</code></pre> <p>The operation context is automatically populated during validation. For programmatic access:</p> <pre><code>result, _ := validator.ValidateWithOptions(\n    validator.WithFilePath(\"api.yaml\"),\n)\nfor _, err := range result.Errors {\n    if err.OperationContext != nil {\n        fmt.Printf(\"Affected operation: %s %s\\n\",\n            err.OperationContext.Method,\n            err.OperationContext.Path)\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#configuration-reference","title":"Configuration Reference","text":""},{"location":"packages/validator/#validator-fields","title":"Validator Fields","text":"<pre><code>type Validator struct {\n    // IncludeWarnings determines whether to include best practice warnings\n    IncludeWarnings bool  // Default: true\n\n    // StrictMode treats warnings as errors\n    StrictMode bool  // Default: false\n\n    // ValidateStructure controls whether the parser performs basic structure validation\n    ValidateStructure bool  // Default: true\n\n    // UserAgent for HTTP requests when fetching URLs\n    UserAgent string\n\n    // SourceMap provides source location lookup for validation errors.\n    // When set, validation errors will include Line, Column, and File fields.\n    SourceMap *parser.SourceMap\n}\n</code></pre>"},{"location":"packages/validator/#available-options","title":"Available Options","text":"Option Description <code>WithFilePath(string)</code> Input file path or URL <code>WithParsed(ParseResult)</code> Pre-parsed document (30x faster) <code>WithIncludeWarnings(bool)</code> Include best practice warnings <code>WithStrictMode(bool)</code> Treat warnings as errors <code>WithValidateStructure(bool)</code> Enable/disable parser structure validation (default: true) <code>WithUserAgent(string)</code> Custom User-Agent for HTTP requests <code>WithSourceMap(sm *parser.SourceMap)</code> Source map for line/column info in errors <p>\u2191 Back to top</p>"},{"location":"packages/validator/#source-map-integration","title":"Source Map Integration","text":"<p>When you need line numbers for IDE-friendly error reporting, enable source maps during parsing and pass them to the validator:</p> <pre><code>parseResult, _ := parser.ParseWithOptions(\n    parser.WithFilePath(\"openapi.yaml\"),\n    parser.WithSourceMap(true),\n)\nresult, _ := validator.ValidateWithOptions(\n    validator.WithParsed(*parseResult),\n    validator.WithSourceMap(parseResult.SourceMap),\n)\nfor _, err := range result.Errors {\n    fmt.Printf(\"%s: %s\\n\", err.Location(), err.Message)\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#package-chaining","title":"Package Chaining","text":"<p>The <code>ToParseResult()</code> method enables seamless chaining with other oastools packages by converting <code>ValidationResult</code> to a <code>parser.ParseResult</code>:</p> <pre><code>// Validate then convert\nvalResult, err := validator.ValidateWithOptions(\n    validator.WithFilePath(\"openapi.yaml\"),\n    validator.WithIncludeWarnings(true),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nif valResult.Valid {\n    // Chain to converter\n    c := converter.New()\n    convResult, _ := c.ConvertParsed(*valResult.ToParseResult(), \"3.1.0\")\n\n    // Or chain to differ\n    diffResult, _ := differ.DiffWithOptions(\n        differ.WithSourceParsed(baseSpec),\n        differ.WithTargetParsed(*valResult.ToParseResult()),\n    )\n}\n</code></pre> <p>Note: Validation errors and warnings are converted to string warnings in the resulting ParseResult, preserving severity information in the format <code>[severity] message</code>.</p> <p>\u2191 Back to top</p>"},{"location":"packages/validator/#best-practices","title":"Best Practices","text":"<p>Always validate before using specifications for code generation, documentation, or gateway configuration. Invalid specifications can produce incorrect or broken outputs.</p> <p>Use strict mode in CI/CD pipelines to enforce both specification compliance and best practices from the start. It's easier to maintain quality than to fix accumulated issues later.</p> <p>Leverage the parse-once pattern when combining validation with other operations. Parse once, then pass the <code>ParseResult</code> to validator, fixer, converter, and other packages for significant performance improvements.</p> <p>Include spec references in error reports when building developer-facing tooling. The <code>SpecRef</code> field provides direct links to documentation that helps developers understand and fix issues.</p> <p>Categorize issues by severity in your reporting. Critical and Error issues must be fixed; Warnings should be addressed but don't block validity; Info messages are informational only.</p> <p>Consider validation as part of your API design workflow. Validating specifications early catches issues before they propagate to generated code, documentation, or runtime systems.</p> <p>Use warnings as guidance, not just rules. The best practice warnings reflect common patterns that improve API usability and tooling compatibility. Understanding why something is flagged helps you make informed decisions about whether to address it.</p>"},{"location":"packages/validator/#learn-more","title":"Learn More","text":"<p>For additional examples and complete API documentation:</p> <ul> <li>\ud83d\udce6 API Reference on pkg.go.dev - Complete API documentation with all examples</li> <li>\u2705 Basic example - Validate an OpenAPI specification</li> <li>\ud83d\udd12 Strict mode example - Enforce best practices</li> <li>\u2699\ufe0f Custom validation example - Process validation issues by severity</li> </ul>"},{"location":"packages/walker/","title":"Walker Package Deep Dive","text":"<p>The <code>walker</code> package provides a document traversal API for OpenAPI specifications, enabling single-pass traversal with typed handlers for analysis and mutation.</p>"},{"location":"packages/walker/#overview","title":"Overview","text":"<p>The walker visits all nodes in an OpenAPI document in a consistent order, calling registered handlers for each node type. This is useful for:</p> <ul> <li>Analysis: Collecting statistics, finding patterns, validating custom rules</li> <li>Transformation: Adding vendor extensions, modifying descriptions, normalizing formats</li> <li>Code Generation: Gathering type information across the document</li> </ul>"},{"location":"packages/walker/#core-concepts","title":"Core Concepts","text":""},{"location":"packages/walker/#action-based-flow-control","title":"Action-Based Flow Control","text":"<p>Handlers return an <code>Action</code> to control traversal:</p> <pre><code>type Action int\n\nconst (\n    Continue     Action = iota  // Continue to children and siblings\n    SkipChildren                // Skip children, continue to siblings\n    Stop                        // Stop walking entirely\n)\n</code></pre> <p>This provides cleaner flow control than error-based approaches.</p>"},{"location":"packages/walker/#continue","title":"Continue","text":"<p><code>Continue</code> tells the walker to proceed normally\u2014descend into children, then continue to siblings. This is the default behavior for most handlers.</p> <pre><code>// Count all schemas in the document\nvar schemaCount int\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        schemaCount++\n        return walker.Continue  // Visit nested schemas too\n    }),\n)\n</code></pre> <p>Use <code>Continue</code> when you want to:</p> <ul> <li>Visit every matching node in the document</li> <li>Collect comprehensive information (all operations, all schemas, etc.)</li> <li>Apply transformations uniformly across the entire document</li> </ul>"},{"location":"packages/walker/#skipchildren","title":"SkipChildren","text":"<p><code>SkipChildren</code> tells the walker to skip the current node's descendants but continue to siblings. The walker moves horizontally rather than descending.</p> <pre><code>// Find schemas but don't descend into their nested properties\nvar topLevelSchemas []string\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Only capture component-level schemas, not nested ones\n        if wc.IsComponent &amp;&amp; wc.Name != \"\" {\n            topLevelSchemas = append(topLevelSchemas, wc.JSONPath)\n        }\n        return walker.SkipChildren  // Don't walk into properties/items/etc.\n    }),\n)\n</code></pre> <p>Common use cases for <code>SkipChildren</code>:</p> <p>1. Skipping internal/private paths:</p> <pre><code>walker.Walk(result,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pi *parser.PathItem) walker.Action {\n        if strings.HasPrefix(wc.PathTemplate, \"/internal\") ||\n           strings.HasPrefix(wc.PathTemplate, \"/_\") {\n            return walker.SkipChildren  // Don't process internal endpoints\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>2. Processing only top-level schemas (ignoring nested):</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Process this schema...\n        processSchema(schema)\n        // But don't recurse into properties, items, allOf, etc.\n        return walker.SkipChildren\n    }),\n)\n</code></pre> <p>3. Conditional depth limiting:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        depth := strings.Count(wc.JSONPath, \".properties\")\n        if depth &gt;= 3 {\n            return walker.SkipChildren  // Stop at 3 levels of nesting\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>4. Skipping deprecated operations:</p> <pre><code>walker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        if op.Deprecated {\n            return walker.SkipChildren  // Skip parameters, responses of deprecated ops\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#stop","title":"Stop","text":"<p><code>Stop</code> immediately terminates the entire walk. No more nodes are visited\u2014the walker returns immediately.</p> <pre><code>// Find the first schema with a specific title\nvar targetSchema *parser.Schema\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if schema.Title == \"UserProfile\" {\n            targetSchema = schema\n            return walker.Stop  // Found it, no need to continue\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Common use cases for <code>Stop</code>:</p> <p>1. Search with early termination:</p> <pre><code>// Check if any operation uses a specific security scheme\nvar usesOAuth bool\nwalker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        for _, req := range op.Security {\n            if _, ok := req[\"oauth2\"]; ok {\n                usesOAuth = true\n                return walker.Stop  // Found one, that's enough\n            }\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>2. Validation with fail-fast:</p> <pre><code>// Stop on first validation error\nvar firstError error\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if err := validateCustomRule(schema); err != nil {\n            firstError = fmt.Errorf(\"%s: %w\", wc.JSONPath, err)\n            return walker.Stop  // Fail fast\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>3. Finding a specific node by path:</p> <pre><code>// Find operation at a specific path and method\nvar targetOp *parser.Operation\nwalker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        if wc.JSONPath == \"$.paths['/users/{id}'].get\" {\n            targetOp = op\n            return walker.Stop\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>4. Resource limits:</p> <pre><code>// Process at most N schemas\nconst maxSchemas = 1000\nvar processed int\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        processed++\n        if processed &gt;= maxSchemas {\n            return walker.Stop  // Resource limit reached\n        }\n        // Process schema...\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#combining-actions-across-handlers","title":"Combining Actions Across Handlers","text":"<p>Different handlers can return different actions to create sophisticated traversal patterns:</p> <pre><code>// Analyze public APIs only, stop if we find a critical issue\nvar criticalIssue error\nwalker.Walk(result,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pi *parser.PathItem) walker.Action {\n        if strings.HasPrefix(wc.PathTemplate, \"/internal\") {\n            return walker.SkipChildren  // Skip internal paths\n        }\n        return walker.Continue\n    }),\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        if op.Deprecated {\n            return walker.SkipChildren  // Skip deprecated operations\n        }\n        return walker.Continue\n    }),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if hasCriticalVulnerability(schema) {\n            criticalIssue = fmt.Errorf(\"critical issue at %s\", wc.JSONPath)\n            return walker.Stop  // Halt everything\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#handler-types","title":"Handler Types","text":"<p>Each OAS node type has a corresponding handler type:</p> Handler Called For OAS Version <code>DocumentHandler</code> Root document (any type) All <code>OAS2DocumentHandler</code> OAS 2.0 documents only 2.0 only <code>OAS3DocumentHandler</code> OAS 3.x documents only 3.x only <code>InfoHandler</code> API metadata All <code>ServerHandler</code> Server definitions 3.x only <code>TagHandler</code> Tag definitions All <code>PathHandler</code> Path entries All <code>PathItemHandler</code> Path items All <code>OperationHandler</code> Operations All <code>ParameterHandler</code> Parameters All <code>RequestBodyHandler</code> Request bodies 3.x only <code>ResponseHandler</code> Responses All <code>SchemaHandler</code> Schemas (including nested) All <code>SecuritySchemeHandler</code> Security schemes All <code>HeaderHandler</code> Headers All <code>MediaTypeHandler</code> Media types 3.x only <code>LinkHandler</code> Links 3.x only <code>CallbackHandler</code> Callbacks 3.x only <code>ExampleHandler</code> Examples All <code>ExternalDocsHandler</code> External docs All <code>SchemaSkippedHandler</code> Skipped schemas (depth/cycle) All <p>Each handler type has a corresponding registration option. Register handlers using these <code>Option</code> functions:</p> Option Called For OAS Version <code>WithDocumentHandler(fn)</code> Root document (any type) All <code>WithOAS2DocumentHandler(fn)</code> OAS 2.0 documents only 2.0 only <code>WithOAS3DocumentHandler(fn)</code> OAS 3.x documents only 3.x only <code>WithInfoHandler(fn)</code> API metadata All <code>WithServerHandler(fn)</code> Server definitions 3.x only <code>WithTagHandler(fn)</code> Tag definitions All <code>WithPathHandler(fn)</code> Path entries All <code>WithPathItemHandler(fn)</code> Path items All <code>WithOperationHandler(fn)</code> Operations All <code>WithParameterHandler(fn)</code> Parameters All <code>WithRequestBodyHandler(fn)</code> Request bodies 3.x only <code>WithResponseHandler(fn)</code> Responses All <code>WithSchemaHandler(fn)</code> Schemas (including nested) All <code>WithSecuritySchemeHandler(fn)</code> Security schemes All <code>WithHeaderHandler(fn)</code> Headers All <code>WithMediaTypeHandler(fn)</code> Media types 3.x only <code>WithLinkHandler(fn)</code> Links 3.x only <code>WithCallbackHandler(fn)</code> Callbacks 3.x only <code>WithExampleHandler(fn)</code> Examples All <code>WithExternalDocsHandler(fn)</code> External docs All <code>WithSchemaSkippedHandler(fn)</code> Skipped schemas (depth/cycle) All"},{"location":"packages/walker/#walkcontext","title":"WalkContext","text":"<p>Every handler receives a <code>*WalkContext</code> as its first parameter, providing contextual information about the current node.</p> <p>Important: WalkContext Pooling</p> <p>WalkContext instances are reused via <code>sync.Pool</code> for performance. Handlers must not retain references to WalkContext after returning. If you need to preserve context information, copy the needed fields:</p> <pre><code>// Wrong - retaining WalkContext reference\nvar saved []*WalkContext\nWithSchemaHandler(func(wc *WalkContext, s *parser.Schema) Action {\n    saved = append(saved, wc) // Don't do this!\n    return Continue\n})\n\n// Correct - copy needed fields\ntype Info struct { JSONPath, Name string }\nvar saved []Info\nWithSchemaHandler(func(wc *WalkContext, s *parser.Schema) Action {\n    saved = append(saved, Info{wc.JSONPath, wc.Name})\n    return Continue\n})\n</code></pre> Field Description <code>JSONPath</code> Full JSON path to the node (always populated) <code>PathTemplate</code> URL path template when in $.paths scope <code>Method</code> HTTP method when in operation scope (e.g., \"get\", \"post\") <code>StatusCode</code> Status code when in response scope (e.g., \"200\", \"default\") <code>Name</code> Map key for named items (headers, schemas, etc.) <code>IsComponent</code> True when in components/definitions section"},{"location":"packages/walker/#json-path-examples","title":"JSON Path Examples","text":"<pre><code>$                                    # Document root\n$.info                               # Info object\n$.paths['/pets/{petId}']             # Path entry\n$.paths['/pets'].get                 # Operation\n$.paths['/pets'].get.parameters[0]   # Parameter\n$.components.schemas['Pet']          # Schema\n$.components.schemas['Pet'].properties['name']  # Nested schema\n</code></pre>"},{"location":"packages/walker/#accessing-context","title":"Accessing Context","text":"<pre><code>walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n    if wc.IsComponent {\n        fmt.Printf(\"Component schema: %s\\n\", wc.Name)\n    } else if wc.InOperationScope() {\n        fmt.Printf(\"Inline schema in %s %s operation\\n\", wc.Method, wc.PathTemplate)\n    }\n    return walker.Continue\n})\n</code></pre>"},{"location":"packages/walker/#scope-helper-methods","title":"Scope Helper Methods","text":"<p>The <code>WalkContext</code> provides helper methods to check the current scope:</p> <pre><code>wc.InPathsScope()     // true when PathTemplate is set\nwc.InOperationScope() // true when Method is set\nwc.InResponseScope()  // true when StatusCode is set\n</code></pre>"},{"location":"packages/walker/#cancellation-support","title":"Cancellation Support","text":"<p>Pass a <code>context.Context</code> for cancellation and timeout support:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n\nwalker.Walk(result,\n    walker.WithContext(ctx),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Check if cancelled\n        if wc.Context().Err() != nil {\n            return walker.Stop\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#api-reference","title":"API Reference","text":""},{"location":"packages/walker/#choosing-an-api-walk-vs-walkwithoptions","title":"Choosing an API: Walk vs WalkWithOptions","text":"<p>The walker package provides two complementary APIs:</p> API Best For Input Error Handling <code>Walk</code> Pre-parsed documents <code>*parser.ParseResult</code> Handler registration never fails <code>WalkWithOptions</code> File paths or parsed documents Via options Option functions can return errors <p>Use <code>Walk</code> when:</p> <ul> <li>You already have a <code>ParseResult</code> from parsing</li> <li>You're walking multiple documents with the same handlers</li> <li>You want simpler handler registration (no error checking)</li> </ul> <pre><code>// Walk: Direct and simple\nresult, _ := parser.New().Parse(\"openapi.yaml\")\nwalker.Walk(result,\n    walker.WithSchemaHandler(handler),\n    walker.WithMaxSchemaDepth(50),\n)\n</code></pre> <p>Use <code>WalkWithOptions</code> when:</p> <ul> <li>You want to parse and walk in a single call</li> <li>You need error handling for configuration (e.g., invalid depth)</li> </ul> <pre><code>// WalkWithOptions: Parse and walk in one call\nerr := walker.WalkWithOptions(\n    walker.WithFilePath(\"openapi.yaml\"),\n    walker.WithSchemaHandler(handler),\n    walker.WithMaxSchemaDepth(50),  // Uses default (100) if not positive\n)\n</code></pre>"},{"location":"packages/walker/#primary-functions","title":"Primary Functions","text":"<pre><code>// Walk traverses a parsed document with registered handlers\nfunc Walk(result *parser.ParseResult, opts ...Option) error\n\n// WalkWithOptions provides functional options for input and configuration\nfunc WalkWithOptions(opts ...Option) error\n</code></pre>"},{"location":"packages/walker/#walk-options","title":"Walk Options","text":"<pre><code>// Pre-visit handler registration\nWithDocumentHandler(fn DocumentHandler)\nWithOAS2DocumentHandler(fn OAS2DocumentHandler)\nWithOAS3DocumentHandler(fn OAS3DocumentHandler)\nWithInfoHandler(fn InfoHandler)\nWithServerHandler(fn ServerHandler)\nWithTagHandler(fn TagHandler)\nWithPathHandler(fn PathHandler)\nWithPathItemHandler(fn PathItemHandler)\nWithOperationHandler(fn OperationHandler)\nWithParameterHandler(fn ParameterHandler)\nWithRequestBodyHandler(fn RequestBodyHandler)\nWithResponseHandler(fn ResponseHandler)\nWithSchemaHandler(fn SchemaHandler)\nWithSecuritySchemeHandler(fn SecuritySchemeHandler)\nWithHeaderHandler(fn HeaderHandler)\nWithMediaTypeHandler(fn MediaTypeHandler)\nWithLinkHandler(fn LinkHandler)\nWithCallbackHandler(fn CallbackHandler)\nWithExampleHandler(fn ExampleHandler)\nWithExternalDocsHandler(fn ExternalDocsHandler)\nWithSchemaSkippedHandler(fn SchemaSkippedHandler)\n\n// Post-visit handler registration\nWithSchemaPostHandler(fn SchemaPostHandler)\nWithOperationPostHandler(fn OperationPostHandler)\nWithPathItemPostHandler(fn PathItemPostHandler)\nWithResponsePostHandler(fn ResponsePostHandler)\nWithRequestBodyPostHandler(fn RequestBodyPostHandler)\nWithCallbackPostHandler(fn CallbackPostHandler)\nWithOAS2DocumentPostHandler(fn OAS2DocumentPostHandler)\nWithOAS3DocumentPostHandler(fn OAS3DocumentPostHandler)\n\n// Reference and parent tracking\nWithRefHandler(fn RefHandler)\nWithRefTracking()\nWithMapRefTracking()\nWithParentTracking()\n\n// Configuration\nWithMaxSchemaDepth(depth int)  // Limit schema recursion depth (default: 100)\nWithMaxDepth(depth int)        // Deprecated: use WithMaxSchemaDepth instead\nWithContext(ctx context.Context)\n</code></pre>"},{"location":"packages/walker/#walkwithoptions-input-options","title":"WalkWithOptions Input Options","text":"<pre><code>WithFilePath(path string)               // Parse and walk a file\nWithParsed(result *parser.ParseResult)  // Walk pre-parsed document\nWithMaxSchemaDepth(depth int)           // Silently ignored if not positive (uses default 100)\nWithContext(ctx context.Context)        // Context for cancellation\n</code></pre> Option Description <code>WithFilePath(path)</code> Parse and walk a file <code>WithParsed(result)</code> Walk a pre-parsed <code>*parser.ParseResult</code> <code>WithMaxSchemaDepth(depth)</code> Maximum depth for recursive schema traversal (default: 100) <code>WithContext(ctx)</code> Set context for cancellation and deadline propagation <p>All handler options (e.g., <code>WithSchemaHandler</code>, <code>WithOperationHandler</code>) work directly with both <code>Walk</code> and <code>WalkWithOptions</code>.</p>"},{"location":"packages/walker/#walk-order","title":"Walk Order","text":""},{"location":"packages/walker/#oas-3x-documents","title":"OAS 3.x Documents","text":"<ol> <li>Document root</li> <li>Info</li> <li>ExternalDocs (root level)</li> <li>Servers</li> <li>Paths \u2192 PathItems \u2192 Operations \u2192 Parameters, RequestBody, Responses, Callbacks</li> <li>Webhooks (OAS 3.1+)</li> <li>Components (schemas, responses, parameters, requestBodies, headers, securitySchemes, links, callbacks, examples, pathItems)</li> <li>Tags</li> </ol>"},{"location":"packages/walker/#oas-20-documents","title":"OAS 2.0 Documents","text":"<ol> <li>Document root</li> <li>Info</li> <li>ExternalDocs (root level)</li> <li>Paths \u2192 PathItems \u2192 Operations \u2192 Parameters, Responses</li> <li>Definitions (schemas)</li> <li>Parameters (reusable)</li> <li>Responses (reusable)</li> <li>SecurityDefinitions</li> <li>Tags</li> </ol>"},{"location":"packages/walker/#schema-walking","title":"Schema Walking","text":"<p>The walker recursively visits all nested schemas:</p> <ul> <li><code>properties</code>, <code>patternProperties</code>, <code>dependentSchemas</code>, <code>$defs</code> (maps)</li> <li><code>allOf</code>, <code>anyOf</code>, <code>oneOf</code>, <code>prefixItems</code> (slices)</li> <li><code>items</code>, <code>additionalProperties</code>, <code>additionalItems</code>, <code>unevaluatedItems</code>, <code>unevaluatedProperties</code> (polymorphic)</li> <li><code>not</code>, <code>contains</code>, <code>propertyNames</code>, <code>contentSchema</code>, <code>if</code>, <code>then</code>, <code>else</code> (single)</li> </ul>"},{"location":"packages/walker/#cycle-detection","title":"Cycle Detection","text":"<p>The walker uses pointer-based cycle detection to prevent infinite loops in circular schema references. Visited schemas are tracked and skipped on subsequent encounters.</p> <pre><code>// Circular reference example\nschema := &amp;parser.Schema{Type: \"object\"}\nschema.Properties = map[string]*parser.Schema{\n    \"self\": schema,  // Points back to itself\n}\n// The walker will visit 'schema' once, then skip 'self'\n// since it's already been visited\n</code></pre>"},{"location":"packages/walker/#depth-limiting","title":"Depth Limiting","text":"<p>Use <code>WithMaxSchemaDepth(n)</code> to limit schema recursion depth (default: 100). The older <code>WithMaxDepth(n)</code> is deprecated but still works.</p> <pre><code>// Limit to 10 levels of nesting\nwalker.Walk(result,\n    walker.WithSchemaHandler(handler),\n    walker.WithMaxSchemaDepth(10),\n)\n</code></pre> <p>Behavior:</p> <ul> <li>The depth counter starts at 0 for component/definition schemas</li> <li>Each nested schema (properties, items, allOf, etc.) increments the depth</li> <li>When depth reaches the limit, nested schemas are skipped</li> <li>The handler is not called for schemas beyond the depth limit</li> </ul>"},{"location":"packages/walker/#schema-skipped-callbacks","title":"Schema Skipped Callbacks","text":"<p>Use <code>WithSchemaSkippedHandler</code> to receive notifications when schemas are skipped due to depth limits or cycle detection:</p> <pre><code>walker.Walk(result,\n    walker.WithMaxSchemaDepth(10),\n    walker.WithSchemaSkippedHandler(func(wc *walker.WalkContext, reason string, schema *parser.Schema) {\n        switch reason {\n        case \"depth\":\n            fmt.Printf(\"Skipped due to depth limit: %s\\n\", wc.JSONPath)\n        case \"cycle\":\n            fmt.Printf(\"Skipped due to circular reference: %s\\n\", wc.JSONPath)\n        }\n    }),\n)\n</code></pre> <p>Reason values:</p> <ul> <li><code>\"depth\"</code> - Schema exceeded the configured <code>maxDepth</code> limit</li> <li><code>\"cycle\"</code> - Schema was already visited (circular reference detected)</li> </ul> <p>This is useful for:</p> <ul> <li>Debugging: Understanding why certain schemas weren't processed</li> <li>Logging: Recording when circular references are encountered</li> <li>Validation: Detecting overly deep or circular schema structures</li> </ul> <p>With <code>WalkWithOptions</code>:</p> <pre><code>walker.WalkWithOptions(\n    walker.WithFilePath(\"openapi.yaml\"),\n    walker.WithMaxSchemaDepth(10),\n    walker.WithSchemaSkippedHandler(func(wc *walker.WalkContext, reason string, schema *parser.Schema) {\n        log.Printf(\"Schema skipped (%s): %s\", reason, wc.JSONPath)\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#usage-patterns","title":"Usage Patterns","text":""},{"location":"packages/walker/#mutation","title":"Mutation","text":"<p>Handlers receive pointers to the actual document nodes, allowing in-place modification:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Add vendor extension to all schemas\n        if schema.Extra == nil {\n            schema.Extra = make(map[string]any)\n        }\n        schema.Extra[\"x-visited\"] = true\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#version-specific-handling","title":"Version-Specific Handling","text":"<p>For type-safe version-specific handling, use the typed document handlers:</p> <pre><code>walker.Walk(result,\n    walker.WithOAS2DocumentHandler(func(wc *walker.WalkContext, doc *parser.OAS2Document) walker.Action {\n        // Called only for OAS 2.0 documents - doc is already typed\n        fmt.Printf(\"OAS 2.0: %s (host: %s)\\n\", doc.Info.Title, doc.Host)\n        return walker.Continue\n    }),\n    walker.WithOAS3DocumentHandler(func(wc *walker.WalkContext, doc *parser.OAS3Document) walker.Action {\n        // Called only for OAS 3.x documents - doc is already typed\n        fmt.Printf(\"OAS 3.x: %s (servers: %d)\\n\", doc.Info.Title, len(doc.Servers))\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Handler Order: When both typed and generic handlers are registered:</p> <ol> <li>The typed handler (<code>OAS2DocumentHandler</code> or <code>OAS3DocumentHandler</code>) is called first</li> <li>If it returns <code>Continue</code> or <code>SkipChildren</code>, the generic <code>DocumentHandler</code> is called</li> <li>If it returns <code>Stop</code>, the generic handler is skipped and the walk stops</li> </ol> <p>Alternatively, use a type switch with the generic handler:</p> <pre><code>walker.Walk(result,\n    walker.WithDocumentHandler(func(wc *walker.WalkContext, doc any) walker.Action {\n        switch d := doc.(type) {\n        case *parser.OAS2Document:\n            fmt.Printf(\"OAS 2.0: %s\\n\", d.Info.Title)\n        case *parser.OAS3Document:\n            fmt.Printf(\"OAS 3.x: %s\\n\", d.Info.Title)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#multiple-handlers","title":"Multiple Handlers","text":"<p>Register multiple handlers to build up analysis in a single pass:</p> <pre><code>var (\n    pathCount      int\n    operationCount int\n    schemaCount    int\n)\n\nwalker.Walk(result,\n    walker.WithPathHandler(func(wc *walker.WalkContext, pi *parser.PathItem) walker.Action {\n        pathCount++\n        return walker.Continue\n    }),\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        operationCount++\n        return walker.Continue\n    }),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        schemaCount++\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#using-walkcontext-for-location-aware-processing","title":"Using WalkContext for Location-Aware Processing","text":"<p>The <code>WalkContext</code> enables location-aware processing using both structured fields and the JSON path:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Use structured fields for cleaner logic\n        if wc.IsComponent {\n            // Component schema - wc.Name has the schema name\n            fmt.Printf(\"Component: %s\\n\", wc.Name)\n        } else if wc.InOperationScope() {\n            // Inline schema in an operation\n            fmt.Printf(\"Inline in %s %s\\n\", wc.Method, wc.PathTemplate)\n        }\n\n        // Or use JSON path for more specific matching\n        switch {\n        case strings.HasPrefix(wc.JSONPath, \"$.components.schemas\"):\n            // Component schema\n        case strings.Contains(wc.JSONPath, \".requestBody\"):\n            // Request body schema\n        case strings.Contains(wc.JSONPath, \".responses\"):\n            // Response schema\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#walkwithoptions-api","title":"WalkWithOptions API","text":"<p>For parsing and walking in one call:</p> <pre><code>err := walker.WalkWithOptions(\n    walker.WithFilePath(\"openapi.yaml\"),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        fmt.Println(wc.JSONPath)\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#performance","title":"Performance","text":"<ul> <li>Parse-Once Pattern: Pass pre-parsed <code>ParseResult</code> instead of file paths</li> <li>Minimal Allocations: Handler function calls have minimal overhead</li> <li>Deterministic Order: Map keys are sorted for consistent traversal</li> <li>Early Exit: Use <code>Stop</code> to terminate as soon as you find what you need</li> </ul>"},{"location":"packages/walker/#thread-safety","title":"Thread Safety","text":"<p>\u26a0\ufe0f The Walker is NOT thread-safe. Each walk maintains internal state (visited schemas, stopped flag) that is not protected by locks.</p> <p>Safe patterns:</p> <pre><code>// \u2705 Sequential walks (same or different documents)\nwalker.Walk(result1, opts...)\nwalker.Walk(result2, opts...)\n\n// \u2705 Parallel walks with separate documents\nvar wg sync.WaitGroup\nfor _, doc := range documents {\n    wg.Add(1)\n    go func(d *parser.ParseResult) {\n        defer wg.Done()\n        walker.Walk(d, opts...)  // Each goroutine has its own walk state\n    }(doc)\n}\nwg.Wait()\n</code></pre> <p>Unsafe patterns:</p> <pre><code>// \u274c Shared mutable state in handlers without synchronization\nvar count int  // Race condition!\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, s *parser.Schema) walker.Action {\n        count++  // Not thread-safe\n        return walker.Continue\n    }),\n)\n\n// \u2705 Use atomic operations or mutexes for shared state\nvar count atomic.Int64\nwalker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, s *parser.Schema) walker.Action {\n        count.Add(1)  // Thread-safe\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Document mutation: If handlers modify the document, ensure the document is not shared across concurrent walks.</p>"},{"location":"packages/walker/#oas-32-support","title":"OAS 3.2 Support","text":"<p>The walker supports OAS 3.2 features:</p> <ul> <li><code>PathItem.Query</code> operation (QUERY method)</li> <li><code>PathItem.AdditionalOperations</code> for custom methods</li> <li><code>Components.MediaTypes</code> for reusable media types</li> </ul>"},{"location":"packages/walker/#reference-tracking","title":"Reference Tracking","text":"<p>The walker provides optional <code>$ref</code> tracking to detect and process references during traversal without separate passes.</p>"},{"location":"packages/walker/#enabling-reference-tracking","title":"Enabling Reference Tracking","text":"<p>Use <code>WithRefHandler</code> to receive callbacks when references are encountered:</p> <pre><code>walker.Walk(result,\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        fmt.Printf(\"Found ref: %s at %s (type: %s)\\n\", ref.Ref, ref.SourcePath, ref.NodeType)\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#refinfo-structure","title":"RefInfo Structure","text":"<p>The <code>RefInfo</code> struct contains:</p> Field Description <code>Ref</code> The $ref value (e.g., <code>#/components/schemas/User</code>) <code>SourcePath</code> JSON path where the ref was encountered <code>NodeType</code> Type of node containing the ref"},{"location":"packages/walker/#supported-node-types","title":"Supported Node Types","text":"<p>References are tracked in:</p> Node Type Description <code>schema</code> Schema references <code>parameter</code> Parameter references <code>response</code> Response references <code>requestBody</code> Request body references <code>header</code> Header references <code>pathItem</code> Path item references <code>link</code> Link references <code>example</code> Example references <code>securityScheme</code> Security scheme references"},{"location":"packages/walker/#use-cases","title":"Use Cases","text":"<p>Collecting all references:</p> <pre><code>var refs []string\nwalker.Walk(result,\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        refs = append(refs, ref.Ref)\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Finding broken references:</p> <pre><code>walker.Walk(result,\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        if !isValidRef(ref.Ref) {\n            fmt.Printf(\"Broken ref at %s: %s\\n\", ref.SourcePath, ref.Ref)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Stop on first external reference:</p> <pre><code>var hasExternal bool\nwalker.Walk(result,\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        if strings.HasPrefix(ref.Ref, \"http\") {\n            hasExternal = true\n            return walker.Stop\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#withreftracking-option","title":"WithRefTracking Option","text":"<p><code>WithRefTracking()</code> enables internal reference tracking for statistics and debugging purposes, but it does not populate <code>CurrentRef</code> in node handlers. The <code>CurrentRef</code> field is only set when you register a <code>RefHandler</code> via <code>WithRefHandler()</code>.</p> <p>To check for references in node handlers, examine the node's <code>Ref</code> field directly:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if schema.Ref != \"\" {\n            // This schema is a $ref - check schema.Ref directly\n            fmt.Printf(\"Schema ref at %s: %s\\n\", wc.JSONPath, schema.Ref)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>If you need the dedicated <code>RefInfo</code> structure with <code>NodeType</code> classification, use <code>WithRefHandler()</code> instead:</p> <pre><code>walker.Walk(result,\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        // RefInfo provides: Ref, SourcePath, NodeType\n        fmt.Printf(\"Ref %s at %s (type: %s)\\n\", ref.Ref, ref.SourcePath, ref.NodeType)\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#map-reference-tracking","title":"Map Reference Tracking","text":"<p>Some polymorphic schema fields (<code>Items</code>, <code>AdditionalItems</code>, <code>AdditionalProperties</code>, <code>UnevaluatedItems</code>, <code>UnevaluatedProperties</code>) can contain either <code>*parser.Schema</code> or <code>map[string]any</code>. When a document is parsed with certain configurations or when schemas aren't fully resolved, these fields may contain raw maps with <code>$ref</code> values that the standard ref tracking wouldn't detect.</p> <p>Use <code>WithMapRefTracking()</code> to enable detection of <code>$ref</code> values stored in these map structures:</p> <pre><code>walker.Walk(result,\n    walker.WithMapRefTracking(),\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        fmt.Printf(\"Found ref: %s at %s\\n\", ref.Ref, ref.SourcePath)\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Key behaviors:</p> <ul> <li><code>WithMapRefTracking()</code> implicitly enables standard ref tracking</li> <li>The walker checks for <code>$ref</code> keys in <code>map[string]any</code> values in polymorphic fields</li> <li>Empty strings and non-string <code>$ref</code> values are ignored</li> <li>Map-stored refs receive <code>RefNodeSchema</code> as their node type</li> </ul> <p>Affected fields:</p> Field Description <code>Items</code> Array items schema <code>AdditionalItems</code> Additional array items schema <code>UnevaluatedItems</code> Unevaluated array items schema (OAS 3.1+) <code>AdditionalProperties</code> Additional object properties schema <code>UnevaluatedProperties</code> Unevaluated object properties schema (OAS 3.1+) <p>Example with mixed schemas:</p> <pre><code>// Schema with both *Schema and map refs\ndoc := &amp;parser.OAS3Document{\n    Components: &amp;parser.Components{\n        Schemas: map[string]*parser.Schema{\n            \"Container\": {\n                Type: \"object\",\n                Properties: map[string]*parser.Schema{\n                    \"items\": {\n                        Type: \"array\",\n                        Items: map[string]any{\n                            \"$ref\": \"#/components/schemas/Item\",\n                        },\n                    },\n                    \"regular\": {Ref: \"#/components/schemas/Regular\"},\n                },\n            },\n        },\n    },\n}\n\n// Wrap in ParseResult for walking\nresult := &amp;parser.ParseResult{Document: doc, OASVersion: parser.OASVersion310}\n\n// Both refs will be tracked with WithMapRefTracking()\nwalker.Walk(result,\n    walker.WithMapRefTracking(),\n    walker.WithRefHandler(func(wc *walker.WalkContext, ref *walker.RefInfo) walker.Action {\n        // Called for both the map-stored ref and the regular ref\n        return walker.Continue\n    }),\n)\n</code></pre> <p>When to use:</p> <ul> <li>Parsing documents where polymorphic fields weren't fully resolved</li> <li>Working with documents from external sources that use map representations</li> <li>Comprehensive reference analysis that needs to catch all <code>$ref</code> values</li> </ul> <p>Performance note: Map ref tracking adds a small overhead for type assertions on polymorphic fields. Only enable when needed.</p>"},{"location":"packages/walker/#examples","title":"Examples","text":"<p>The <code>examples/walker/</code> directory contains runnable examples demonstrating walker patterns:</p> Example Category Description api-statistics Analysis Collect API statistics in single pass security-audit Validation Audit for security issues vendor-extensions Mutation Add vendor extensions public-api-filter Filtering Extract public API only api-documentation Reporting Generate Markdown docs reference-collector Integration Analyze schema references <p>Each example includes a README with detailed explanations and expected output.</p>"},{"location":"packages/walker/#built-in-collectors","title":"Built-in Collectors","text":"<p>The walker package provides convenience functions for common collection patterns, reducing boilerplate when you need to gather spec elements.</p> <p>Five collectors are available: <code>CollectSchemas</code>, <code>CollectOperations</code>, <code>CollectParameters</code>, <code>CollectResponses</code>, and <code>CollectSecuritySchemes</code>.</p>"},{"location":"packages/walker/#when-to-use-collectors-vs-custom-handlers","title":"When to Use Collectors vs Custom Handlers","text":"<p>Use built-in collectors when:</p> <ul> <li>You need all elements of one type in one pass</li> <li>You want ready-made lookup maps (by name, path, method, tag, status code, location)</li> <li>The standard collection fields meet your needs</li> </ul> <p>Use custom handlers when:</p> <ul> <li>You need to filter during collection (e.g., only deprecated operations)</li> <li>You want to collect multiple node types in a single pass</li> <li>You need custom organization or aggregation logic</li> </ul>"},{"location":"packages/walker/#schemacollector","title":"SchemaCollector","text":"<p><code>CollectSchemas</code> walks a document and collects all schemas:</p> <pre><code>collector, err := walker.CollectSchemas(result)\nif err != nil {\n    return err\n}\n\n// All schemas in traversal order\nfor _, info := range collector.All {\n    fmt.Printf(\"%s: %s\\n\", info.JSONPath, info.Schema.Type)\n}\n\n// Component schemas only\nfor _, info := range collector.Components {\n    fmt.Printf(\"Component %s at %s\\n\", info.Name, info.JSONPath)\n}\n\n// Inline schemas only (not in components)\nfor _, info := range collector.Inline {\n    fmt.Printf(\"Inline schema at %s\\n\", info.JSONPath)\n}\n\n// Lookup by JSON path\nif schema, ok := collector.ByPath[\"$.components.schemas['Pet']\"]; ok {\n    fmt.Printf(\"Pet: %v\\n\", schema.Schema.Type)\n}\n\n// Lookup by component name\nif schema, ok := collector.ByName[\"Pet\"]; ok {\n    fmt.Printf(\"Found Pet schema\\n\")\n}\n</code></pre> <p>SchemaInfo fields:</p> Field Type Description <code>Schema</code> <code>*parser.Schema</code> The collected schema <code>Name</code> <code>string</code> Component name (empty for inline schemas) <code>JSONPath</code> <code>string</code> Full JSON path to the schema <code>IsComponent</code> <code>bool</code> True when in components/definitions section"},{"location":"packages/walker/#operationcollector","title":"OperationCollector","text":"<p><code>CollectOperations</code> walks a document and collects all operations:</p> <pre><code>collector, err := walker.CollectOperations(result)\nif err != nil {\n    return err\n}\n\n// All operations in traversal order\nfor _, info := range collector.All {\n    fmt.Printf(\"%s %s (%s)\\n\", info.Method, info.PathTemplate, info.Operation.OperationID)\n}\n\n// Group by path template\nfor path, ops := range collector.ByPath {\n    fmt.Printf(\"%s has %d operations\\n\", path, len(ops))\n}\n\n// Group by HTTP method\nfor method, ops := range collector.ByMethod {\n    fmt.Printf(\"%s: %d operations\\n\", method, len(ops))\n}\n\n// Group by tag\nfor tag, ops := range collector.ByTag {\n    fmt.Printf(\"Tag '%s': %d operations\\n\", tag, len(ops))\n}\n</code></pre> <p>OperationInfo fields:</p> Field Type Description <code>Operation</code> <code>*parser.Operation</code> The collected operation <code>PathTemplate</code> <code>string</code> URL path template (e.g., \"/pets/{petId}\") <code>Method</code> <code>string</code> HTTP method (e.g., \"get\", \"post\") <code>JSONPath</code> <code>string</code> Full JSON path to the operation"},{"location":"packages/walker/#parametercollector","title":"ParameterCollector","text":"<p><code>CollectParameters</code> walks a document and collects all parameters:</p> <pre><code>collector, err := walker.CollectParameters(result)\nif err != nil {\n    return err\n}\n\n// All parameters in traversal order\nfor _, info := range collector.All {\n    fmt.Printf(\"%s (%s) at %s\\n\", info.Name, info.In, info.JSONPath)\n}\n\n// Group by location\nfor location, params := range collector.ByLocation {\n    fmt.Printf(\"%s: %d parameters\\n\", location, len(params))\n}\n\n// Group by path template\nfor path, params := range collector.ByPath {\n    fmt.Printf(\"%s has %d parameters\\n\", path, len(params))\n}\n</code></pre> <p>ParameterInfo fields:</p> Field Type Description <code>Parameter</code> <code>*parser.Parameter</code> The collected parameter <code>Name</code> <code>string</code> Parameter name <code>In</code> <code>string</code> Location: query, header, path, cookie <code>JSONPath</code> <code>string</code> Full JSON path to the parameter <code>PathTemplate</code> <code>string</code> Owning path template <code>Method</code> <code>string</code> Owning operation method (empty if path-level) <code>IsComponent</code> <code>bool</code> True when in components/parameters"},{"location":"packages/walker/#responsecollector","title":"ResponseCollector","text":"<p><code>CollectResponses</code> walks a document and collects all responses:</p> <pre><code>collector, err := walker.CollectResponses(result)\nif err != nil {\n    return err\n}\n\n// All responses in traversal order\nfor _, info := range collector.All {\n    fmt.Printf(\"%s %s -&gt; %s\\n\", info.Method, info.PathTemplate, info.StatusCode)\n}\n\n// Group by status code\nfor code, responses := range collector.ByStatusCode {\n    fmt.Printf(\"Status %s: %d responses\\n\", code, len(responses))\n}\n</code></pre> <p>ResponseInfo fields:</p> Field Type Description <code>Response</code> <code>*parser.Response</code> The collected response <code>StatusCode</code> <code>string</code> HTTP status code (e.g., \"200\", \"default\") <code>JSONPath</code> <code>string</code> Full JSON path to the response <code>PathTemplate</code> <code>string</code> Owning path template <code>Method</code> <code>string</code> Owning operation method <code>IsComponent</code> <code>bool</code> True when in components/responses"},{"location":"packages/walker/#securityschemecollector","title":"SecuritySchemeCollector","text":"<p><code>CollectSecuritySchemes</code> walks a document and collects all security schemes:</p> <pre><code>collector, err := walker.CollectSecuritySchemes(result)\nif err != nil {\n    return err\n}\n\n// All security schemes\nfor _, info := range collector.All {\n    fmt.Printf(\"%s: type=%s\\n\", info.Name, info.SecurityScheme.Type)\n}\n\n// Lookup by name\nif bearer, ok := collector.ByName[\"bearerAuth\"]; ok {\n    fmt.Printf(\"Bearer scheme: %s\\n\", bearer.SecurityScheme.Scheme)\n}\n</code></pre> <p>SecuritySchemeInfo fields:</p> Field Type Description <code>SecurityScheme</code> <code>*parser.SecurityScheme</code> The collected security scheme <code>Name</code> <code>string</code> Security scheme name from components map key <code>JSONPath</code> <code>string</code> Full JSON path to the security scheme"},{"location":"packages/walker/#example-api-coverage-report","title":"Example: API Coverage Report","text":"<pre><code>func generateCoverageReport(result *parser.ParseResult) {\n    schemas, _ := walker.CollectSchemas(result)\n    ops, _ := walker.CollectOperations(result)\n\n    fmt.Printf(\"API Coverage Report\\n\")\n    fmt.Printf(\"==================\\n\\n\")\n\n    fmt.Printf(\"Schemas: %d total (%d component, %d inline)\\n\",\n        len(schemas.All), len(schemas.Components), len(schemas.Inline))\n\n    fmt.Printf(\"Operations: %d total\\n\", len(ops.All))\n\n    fmt.Printf(\"\\nOperations by Method:\\n\")\n    for method, methodOps := range ops.ByMethod {\n        fmt.Printf(\"  %s: %d\\n\", strings.ToUpper(method), len(methodOps))\n    }\n\n    fmt.Printf(\"\\nOperations by Tag:\\n\")\n    for tag, tagOps := range ops.ByTag {\n        fmt.Printf(\"  %s: %d\\n\", tag, len(tagOps))\n    }\n}\n</code></pre>"},{"location":"packages/walker/#parent-tracking","title":"Parent Tracking","text":"<p>The walker supports optional parent/ancestor tracking, providing type-safe access to ancestor nodes during traversal. This is useful for context-aware processing where you need to know what contains the current node.</p>"},{"location":"packages/walker/#enabling-parent-tracking","title":"Enabling Parent Tracking","text":"<p>Use <code>WithParentTracking()</code> to enable ancestor tracking:</p> <pre><code>walker.Walk(result,\n    walker.WithParentTracking(),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // wc.Parent is now populated\n        return walker.Continue\n    }),\n)\n</code></pre> <p>Note: Parent tracking is disabled by default to avoid overhead when not needed. Enable it only when you need ancestor access.</p>"},{"location":"packages/walker/#parentinfo-structure","title":"ParentInfo Structure","text":"<p>The <code>wc.Parent</code> field provides a linked list of ancestors:</p> <pre><code>type ParentInfo struct {\n    Node     any         // The parent node (*parser.Schema, *parser.Operation, etc.)\n    JSONPath string      // JSON path to this parent\n    Parent   *ParentInfo // Grandparent (or nil at root)\n}\n</code></pre>"},{"location":"packages/walker/#helper-methods","title":"Helper Methods","text":"<p>Type-safe helper methods make ancestor access convenient:</p> Method Returns Description <code>ParentSchema()</code> <code>(*parser.Schema, bool)</code> Nearest ancestor schema <code>ParentOperation()</code> <code>(*parser.Operation, bool)</code> Nearest ancestor operation <code>ParentPathItem()</code> <code>(*parser.PathItem, bool)</code> Nearest ancestor path item <code>ParentResponse()</code> <code>(*parser.Response, bool)</code> Nearest ancestor response <code>ParentRequestBody()</code> <code>(*parser.RequestBody, bool)</code> Nearest ancestor request body <code>Ancestors()</code> <code>[]*ParentInfo</code> All ancestors (parent to root) <code>Depth()</code> <code>int</code> Number of ancestors"},{"location":"packages/walker/#use-cases_1","title":"Use Cases","text":"<p>1. Determining schema context:</p> <pre><code>walker.Walk(result,\n    walker.WithParentTracking(),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Is this schema in a request or response?\n        if _, ok := wc.ParentRequestBody(); ok {\n            fmt.Printf(\"Request schema: %s\\n\", wc.JSONPath)\n        } else if _, ok := wc.ParentResponse(); ok {\n            fmt.Printf(\"Response schema: %s\\n\", wc.JSONPath)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>2. Finding the containing operation:</p> <pre><code>walker.Walk(result,\n    walker.WithParentTracking(),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if op, ok := wc.ParentOperation(); ok {\n            fmt.Printf(\"Schema in %s: %s\\n\", op.OperationID, wc.JSONPath)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>3. Detecting nested schemas:</p> <pre><code>walker.Walk(result,\n    walker.WithParentTracking(),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if parentSchema, ok := wc.ParentSchema(); ok {\n            // This schema is nested within another schema\n            fmt.Printf(\"Nested in type: %v\\n\", parentSchema.Type)\n        } else if wc.IsComponent {\n            // This is a top-level component schema\n            fmt.Printf(\"Component schema: %s\\n\", wc.Name)\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>4. Limiting depth based on ancestor count:</p> <pre><code>walker.Walk(result,\n    walker.WithParentTracking(),\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        if wc.Depth() &gt; 5 {\n            // Skip deeply nested schemas\n            return walker.SkipChildren\n        }\n        return walker.Continue\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#performance-considerations","title":"Performance Considerations","text":"<p>Parent tracking adds overhead:</p> <ul> <li>~15-20% increase in traversal time</li> <li>Additional allocations for ParentInfo structs</li> </ul> <p>Only enable <code>WithParentTracking()</code> when you need ancestor access. If you only need the current node's context (JSONPath, Method, PathTemplate, etc.), the standard <code>WalkContext</code> fields are sufficient without parent tracking.</p>"},{"location":"packages/walker/#post-visit-hooks","title":"Post-Visit Hooks","text":"<p>Post-visit handlers fire after a node's children have been processed, enabling bottom-up processing patterns like aggregation and validation.</p>"},{"location":"packages/walker/#available-post-visit-handlers","title":"Available Post-Visit Handlers","text":"Option Called After <code>WithSchemaPostHandler</code> Schema's children (properties, items, allOf, etc.) processed <code>WithOperationPostHandler</code> Operation's children (parameters, requestBody, responses, callbacks) processed <code>WithPathItemPostHandler</code> Path item's children (parameters, operations) processed <code>WithResponsePostHandler</code> Response's children (headers, content, links) processed <code>WithRequestBodyPostHandler</code> Request body's children (content) processed <code>WithCallbackPostHandler</code> Callback's children (path items) processed <code>WithOAS2DocumentPostHandler</code> OAS 2.0 document's children (all nodes) processed <code>WithOAS3DocumentPostHandler</code> OAS 3.x document's children (all nodes) processed"},{"location":"packages/walker/#when-post-handlers-are-called","title":"When Post Handlers Are Called","text":"<p>Post handlers are called:</p> <ul> <li>AFTER all children are walked</li> <li>BEFORE the parent is popped (if parent tracking is enabled)</li> <li>NOT called if the pre-visit handler returned <code>SkipChildren</code> or <code>Stop</code></li> </ul>"},{"location":"packages/walker/#execution-order","title":"Execution Order","text":"<p>For nested schemas:</p> <pre><code>Pre-visit A (parent)\n  Pre-visit B (child)\n    Pre-visit C (grandchild)\n    Post-visit C\n  Post-visit B\nPost-visit A\n</code></pre>"},{"location":"packages/walker/#use-cases_2","title":"Use Cases","text":"<p>1. Counting child nodes:</p> <pre><code>propertyCounts := make(map[string]int)\n\nwalker.Walk(result,\n    walker.WithSchemaPostHandler(func(wc *walker.WalkContext, schema *parser.Schema) {\n        if wc.IsComponent &amp;&amp; wc.Name != \"\" {\n            propertyCounts[wc.Name] = len(schema.Properties)\n        }\n    }),\n)\n</code></pre> <p>2. Bottom-up validation:</p> <pre><code>var issues []string\n\nwalker.Walk(result,\n    walker.WithOperationPostHandler(func(wc *walker.WalkContext, op *parser.Operation) {\n        // Validate after all parameters and responses are processed\n        if op.OperationID == \"\" {\n            issues = append(issues, fmt.Sprintf(\"%s: missing operationId\", wc.JSONPath))\n        }\n    }),\n)\n</code></pre> <p>3. Aggregating statistics:</p> <pre><code>schemaStats := make(map[string]struct {\n    PropertyCount int\n    RequiredCount int\n})\n\nwalker.Walk(result,\n    walker.WithSchemaPostHandler(func(wc *walker.WalkContext, schema *parser.Schema) {\n        if wc.IsComponent &amp;&amp; wc.Name != \"\" &amp;&amp; !strings.Contains(wc.JSONPath, \".properties\") {\n            schemaStats[wc.Name] = struct {\n                PropertyCount int\n                RequiredCount int\n            }{\n                PropertyCount: len(schema.Properties),\n                RequiredCount: len(schema.Required),\n            }\n        }\n    }),\n)\n</code></pre> <p>4. Building summary data after traversal:</p> <pre><code>var operationsByPath = make(map[string]int)\n\nwalker.Walk(result,\n    walker.WithPathItemPostHandler(func(wc *walker.WalkContext, pathItem *parser.PathItem) {\n        // Count operations in this path item\n        count := 0\n        if pathItem.Get != nil { count++ }\n        if pathItem.Post != nil { count++ }\n        if pathItem.Put != nil { count++ }\n        if pathItem.Delete != nil { count++ }\n        if pathItem.Patch != nil { count++ }\n        operationsByPath[wc.PathTemplate] = count\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#combining-pre-and-post-handlers","title":"Combining Pre and Post Handlers","text":"<p>You can use both pre and post handlers together:</p> <pre><code>walker.Walk(result,\n    walker.WithSchemaHandler(func(wc *walker.WalkContext, schema *parser.Schema) walker.Action {\n        // Pre-visit: mark schema as being processed\n        fmt.Printf(\"Entering %s\\n\", wc.JSONPath)\n        return walker.Continue\n    }),\n    walker.WithSchemaPostHandler(func(wc *walker.WalkContext, schema *parser.Schema) {\n        // Post-visit: mark schema as complete\n        fmt.Printf(\"Leaving %s\\n\", wc.JSONPath)\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#using-post-handlers-alone","title":"Using Post Handlers Alone","text":"<p>Post handlers work without pre-handlers:</p> <pre><code>// Only register post handler\nwalker.Walk(result,\n    walker.WithSchemaPostHandler(func(wc *walker.WalkContext, schema *parser.Schema) {\n        // Called for every schema after its children are processed\n    }),\n)\n</code></pre>"},{"location":"packages/walker/#document-post-handlers-single-walk-aggregation","title":"Document Post Handlers: Single-Walk Aggregation","text":"<p>Document post handlers (<code>WithOAS2DocumentPostHandler</code>, <code>WithOAS3DocumentPostHandler</code>) enable single-walk patterns where you collect information from child nodes and then modify the document root based on that collection.</p> <p>Use case: Adding security definitions based on operation analysis</p> <p>Without document post handlers, you'd need two walks:</p> <pre><code>// Old approach: Two walks required\nneedsOAuth2 := false\nneedsAPIKey := false\n\n// Walk 1: Collect security requirements from operations\nerr := walker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        authType := getAuthType(op)\n        if authType == \"oauth2\" {\n            needsOAuth2 = true\n        } else if authType == \"apiKey\" {\n            needsAPIKey = true\n        }\n        return walker.Continue\n    }),\n)\n\n// Walk 2: Add security definitions based on collected info\nerr = walker.Walk(result,\n    walker.WithOAS3DocumentHandler(func(_ *walker.WalkContext, doc *parser.OAS3Document) walker.Action {\n        if needsOAuth2 {\n            doc.Components.SecuritySchemes[\"oauth2\"] = &amp;parser.SecurityScheme{...}\n        }\n        return walker.Continue\n    }),\n)\n</code></pre> <p>With document post handlers (single walk):</p> <pre><code>// New approach: Single walk with document post handler\nneedsOAuth2 := false\nneedsAPIKey := false\nscopes := make(map[string][]string)\n\nerr := walker.Walk(result,\n    walker.WithOperationHandler(func(wc *walker.WalkContext, op *parser.Operation) walker.Action {\n        authType := getAuthType(op)\n        if authType == \"oauth2\" {\n            needsOAuth2 = true\n            scopes[op.OperationID] = buildScopes(op)\n        } else if authType == \"apiKey\" {\n            needsAPIKey = true\n        }\n        return walker.Continue\n    }),\n    walker.WithOAS3DocumentPostHandler(func(_ *walker.WalkContext, doc *parser.OAS3Document) {\n        // Called AFTER all operations have been visited\n        if needsOAuth2 {\n            doc.Components.SecuritySchemes[\"oauth2\"] = &amp;parser.SecurityScheme{\n                Type:  \"oauth2\",\n                Flows: buildOAuthFlows(scopes),\n            }\n        }\n        if needsAPIKey {\n            doc.Components.SecuritySchemes[\"api_key\"] = &amp;parser.SecurityScheme{\n                Type: \"apiKey\",\n                In:   \"header\",\n                Name: \"X-API-Key\",\n            }\n        }\n    }),\n)\n</code></pre> <p>This pattern is useful for:</p> <ul> <li>Adding security schemes based on operation requirements</li> <li>Generating documentation tags from operation tags</li> <li>Adding components discovered during traversal</li> <li>Validating document-wide constraints after seeing all nodes</li> </ul>"},{"location":"packages/walker/#performance-considerations_1","title":"Performance Considerations","text":"<p>Post handlers add minimal overhead since they reuse the existing WalkContext. The primary cost is the function call itself.</p>"}]}