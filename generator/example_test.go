package generator_test

import (
	"fmt"
	"log"

	"github.com/erraggy/oastools/generator"
)

// Example demonstrates basic code generation using functional options
func Example() {
	// Generate types and client from an OAS 3.0 specification
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("testdata/petstore-3.0.yaml"),
		generator.WithPackageName("petstore"),
		generator.WithClient(true),
	)
	if err != nil {
		log.Fatal(err)
	}

	// Check for critical issues
	if result.HasCriticalIssues() {
		fmt.Printf("Generation completed with %d critical issue(s)\n", result.CriticalCount)
		return
	}

	fmt.Printf("Successfully generated %d files\n", len(result.Files))
	fmt.Printf("Types: %d, Operations: %d\n", result.GeneratedTypes, result.GeneratedOperations)
	fmt.Printf("Issues: %d info, %d warnings, %d critical\n",
		result.InfoCount, result.WarningCount, result.CriticalCount)
}

// Example_typesOnly demonstrates generating only type definitions
func Example_typesOnly() {
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("myapi"),
		generator.WithTypes(true),
		generator.WithClient(false),
		generator.WithServer(false),
	)
	if err != nil {
		log.Fatal(err)
	}

	// Access generated types
	if typesFile := result.GetFile("types.go"); typesFile != nil {
		fmt.Printf("Generated types.go with %d bytes\n", len(typesFile.Content))
	}
}

// Example_clientAndServer demonstrates generating both client and server code
func Example_clientAndServer() {
	g := generator.New()
	g.PackageName = "petstore"
	g.GenerateClient = true
	g.GenerateServer = true
	g.UsePointers = true
	g.IncludeValidation = true

	result, err := g.Generate("testdata/petstore-3.0.yaml")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated %d files:\n", len(result.Files))
	for _, file := range result.Files {
		fmt.Printf("  - %s (%d bytes)\n", file.Name, len(file.Content))
	}

	// Write files to output directory
	if err := result.WriteFiles("./generated/petstore"); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Files written to ./generated/petstore")
}

// Example_handleIssues demonstrates processing generation issues
func Example_handleIssues() {
	result, _ := generator.GenerateWithOptions(
		generator.WithFilePath("complex-api.yaml"),
		generator.WithPackageName("api"),
		generator.WithClient(true),
	)

	// Categorize issues by severity
	for _, issue := range result.Issues {
		switch issue.Severity {
		case generator.SeverityCritical:
			fmt.Printf("CRITICAL [%s]: %s\n", issue.Path, issue.Message)
		case generator.SeverityError:
			fmt.Printf("ERROR [%s]: %s\n", issue.Path, issue.Message)
		case generator.SeverityWarning:
			fmt.Printf("WARNING [%s]: %s\n", issue.Path, issue.Message)
		case generator.SeverityInfo:
			fmt.Printf("INFO [%s]: %s\n", issue.Path, issue.Message)
		}
	}

	fmt.Printf("\nSummary: %d critical, %d warnings, %d info\n",
		result.CriticalCount, result.WarningCount, result.InfoCount)
}

// Example_withParsedDocument demonstrates using a pre-parsed document
func Example_withParsedDocument() {
	// This example shows how to use a pre-parsed document
	// Useful when you need to parse once and generate multiple times
	// or when integrating with other oastools packages

	// First, parse the document using the parser package
	// parsed, _ := parser.ParseWithOptions(parser.WithFilePath("openapi.yaml"))

	// Then generate using the parsed result
	// result, _ := generator.GenerateWithOptions(
	//     generator.WithParsed(*parsed),
	//     generator.WithPackageName("api"),
	//     generator.WithClient(true),
	// )

	fmt.Println("Pre-parsed document can be used with WithParsed option")
}

// Example_withSecurityHelpers demonstrates generating security authentication helpers
func Example_withSecurityHelpers() {
	// Generate a client with security helpers for all defined security schemes
	// Security helpers are generated by default with WithClient(true)
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithClient(true),
		generator.WithSecurity(true), // Enabled by default with client
	)
	if err != nil {
		log.Fatal(err)
	}

	// Check for security_helpers.go in generated files
	if secFile := result.GetFile("security_helpers.go"); secFile != nil {
		fmt.Printf("Generated security helpers: %d bytes\n", len(secFile.Content))
	}

	// Generated helpers include:
	// - WithAPIKeyAuth(key string) for apiKey schemes
	// - WithBasicAuth(username, password string) for HTTP basic
	// - WithBearerToken(token string) for HTTP bearer
	// - WithOAuth2Token(token string) for OAuth2 schemes
	fmt.Println("Security helpers provide ClientOption functions for authentication")
}

// Example_withOAuth2Flows demonstrates generating full OAuth2 client implementations
func Example_withOAuth2Flows() {
	// Generate a client with full OAuth2 flow support including PKCE
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithClient(true),
		generator.WithOAuth2Flows(true),
	)
	if err != nil {
		log.Fatal(err)
	}

	// OAuth2 files are generated for each OAuth2 security scheme
	// Named: {schemeName}_oauth2.go
	fmt.Printf("Generated %d files with OAuth2 support\n", len(result.Files))

	// Generated OAuth2 code includes:
	// - OAuth2Config for client configuration
	// - OAuth2Client with flow methods:
	//   - GetAuthorizationURL() for authorization code flow
	//   - ExchangeCode() to exchange auth codes for tokens
	//   - GeneratePKCEChallenge() for PKCE (RFC 7636)
	//   - GetClientCredentialsToken() for client credentials
	//   - RefreshToken() for token refresh
	// - WithOAuth2AutoRefresh() for automatic token refresh
	fmt.Println("OAuth2 flows include PKCE support for enhanced security")
}

// Example_withFileSplitting demonstrates splitting large APIs into multiple files
func Example_withFileSplitting() {
	// For large APIs, split output across multiple files by tag or path prefix
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("large-api.yaml"),
		generator.WithPackageName("api"),
		generator.WithClient(true),
		generator.WithServer(true),
		generator.WithMaxOperationsPerFile(100), // Split when >100 operations per group
		generator.WithSplitByTag(true),          // Group by operation tags
	)
	if err != nil {
		log.Fatal(err)
	}

	// Files are split by tag: client_users.go, client_orders.go, etc.
	fmt.Printf("Generated %d files for large API\n", len(result.Files))
	for _, file := range result.Files {
		fmt.Printf("  - %s\n", file.Name)
	}
}

// Example_withServerExtensions demonstrates generating server code with all extensions
func Example_withServerExtensions() {
	// Generate a complete server framework with validation, routing, and testing support
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithServer(true),
		generator.WithServerAll(), // Enable all server extensions at once
	)
	if err != nil {
		log.Fatal(err)
	}

	// WithServerAll() enables:
	// - WithServerResponses(true): Typed response writers with Status*() methods
	// - WithServerBinder(true): Request parameter binding via httpvalidator
	// - WithServerMiddleware(true): Validation middleware for request/response
	// - WithServerRouter("stdlib"): HTTP router with path matching
	// - WithServerStubs(true): Stub implementations for testing

	fmt.Printf("Generated %d files with server extensions\n", len(result.Files))

	// Generated files include:
	// - server.go: ServerInterface and request types
	// - server_responses.go: Per-operation response types
	// - server_binder.go: RequestBinder with Bind{Op}Request() methods
	// - server_middleware.go: ValidationMiddleware configuration
	// - server_router.go: ServerRouter implementing http.Handler
	// - server_stubs.go: StubServer for testing

	for _, file := range result.Files {
		if file.Name[:7] == "server_" {
			fmt.Printf("  - %s\n", file.Name)
		}
	}
}

// Example_withServerRouter demonstrates generating a server router with custom options
func Example_withServerRouter() {
	// Generate server with just the router extension
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithServer(true),
		generator.WithServerRouter("stdlib"), // Generate stdlib-based router
		generator.WithServerResponses(true),  // Include typed response writers
	)
	if err != nil {
		log.Fatal(err)
	}

	// The generated server_router.go provides:
	// - NewServerRouter(server ServerInterface, parsed *parser.ParseResult, opts ...RouterOption)
	// - WithMiddleware(mw ...func(http.Handler) http.Handler) for adding middleware
	// - WithErrorHandler(func(r *http.Request, err error)) for logging handler errors
	// - PathParam(r *http.Request, name string) for accessing path parameters

	// Example usage of generated router:
	//
	//   parsed, _ := parser.ParseWithOptions(parser.WithFilePath("openapi.yaml"))
	//   middleware, _ := ValidationMiddleware(parsed)
	//   router, _ := NewServerRouter(myServer, parsed,
	//       WithMiddleware(middleware),
	//       WithErrorHandler(func(r *http.Request, err error) {
	//           log.Printf("Error: %s %s: %v", r.Method, r.URL.Path, err)
	//       }),
	//   )
	//   http.ListenAndServe(":8080", router)

	if routerFile := result.GetFile("server_router.go"); routerFile != nil {
		fmt.Printf("Generated server_router.go: %d bytes\n", len(routerFile.Content))
	}
}

// Example_withChiRouter demonstrates generating a server with chi router
func Example_withChiRouter() {
	// Generate server with chi router for better path parameter handling
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithServer(true),
		generator.WithServerRouter("chi"), // Generate chi-based router
		generator.WithServerResponses(true),
	)
	if err != nil {
		log.Fatal(err)
	}

	// The chi router provides:
	// - Native path parameter extraction via chi.URLParam()
	// - Middleware chaining with chi.Use()
	// - Direct OpenAPI path pattern support ({param} syntax)
	// - Better integration with existing chi-based applications

	// Example usage of generated chi router:
	//
	//   import "github.com/go-chi/chi/v5"
	//
	//   parsed, _ := parser.ParseWithOptions(parser.WithFilePath("openapi.yaml"))
	//   middleware, _ := ValidationMiddleware(parsed)
	//   router, _ := NewChiRouter(myServer, parsed,
	//       WithMiddleware(middleware),
	//       WithErrorHandler(func(r *http.Request, err error) {
	//           log.Printf("Error: %s %s: %v", r.Method, r.URL.Path, err)
	//       }),
	//   )
	//   http.ListenAndServe(":8080", router)

	if routerFile := result.GetFile("server_router.go"); routerFile != nil {
		fmt.Printf("Generated server_router.go with chi: %d bytes\n", len(routerFile.Content))
	}
}

// Example_withServerStubs demonstrates generating stub implementations for testing
func Example_withServerStubs() {
	// Generate server with stub implementations for unit testing
	result, err := generator.GenerateWithOptions(
		generator.WithFilePath("openapi.yaml"),
		generator.WithPackageName("api"),
		generator.WithServer(true),
		generator.WithServerStubs(true),
	)
	if err != nil {
		log.Fatal(err)
	}

	// The generated server_stubs.go provides:
	// - StubServer struct with configurable function fields
	// - Each operation has a field: Get{Op}Func, Create{Op}Func, etc.
	// - Set fields to custom handlers for testing specific scenarios

	// Example usage of generated stubs:
	//
	//   stub := &StubServer{}
	//   stub.ListPetsFunc = func(ctx context.Context, req *ListPetsRequest) (*ListPetsResponse, error) {
	//       return &ListPetsResponse{...}, nil
	//   }
	//   // Use stub as ServerInterface in tests

	if stubsFile := result.GetFile("server_stubs.go"); stubsFile != nil {
		fmt.Printf("Generated server_stubs.go: %d bytes\n", len(stubsFile.Content))
	}
}
