package generator

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestNewReadmeGenerator(t *testing.T) {
	g := NewReadmeGenerator()
	assert.NotNil(t, g, "expected non-nil generator")
}

func TestReadmeGenerator_GenerateReadme_Basic(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:       time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		OastoolsVersion: "1.0.0",
		SourcePath:      "api.yaml",
		OASVersion:      "3.0.3",
		APITitle:        "My Test API",
		APIVersion:      "v1.2.3",
		APIDescription:  "A test API for demonstration.",
		CLICommand:      "oastools generate api.yaml --package myapi",
		PackageName:     "myapi",
		GeneratedFiles: []GeneratedFileSummary{
			{FileName: "client.go", Description: "HTTP client implementation", LineCount: 500},
			{FileName: "types.go", Description: "Data types and models", LineCount: 300},
		},
	}

	result := g.GenerateReadme(ctx)

	// Check header
	assert.Contains(t, result, "# My Test API", "expected API title header")
	assert.Contains(t, result, "A test API for demonstration.", "expected API description")

	// Check overview table
	assert.Contains(t, result, "| API Version | v1.2.3 |", "expected API version in table")
	assert.Contains(t, result, "| OpenAPI Version | 3.0.3 |", "expected OAS version in table")
	assert.Contains(t, result, "| Package | `myapi` |", "expected package name in table")
	assert.Contains(t, result, "| Generator Version | 1.0.0 |", "expected generator version in table")

	// Check files section
	assert.Contains(t, result, "## Generated Files", "expected Generated Files section")
	assert.Contains(t, result, "| `client.go` | HTTP client implementation (500 lines) |", "expected client.go in files table")
	assert.Contains(t, result, "| `types.go` | Data types and models (300 lines) |", "expected types.go in files table")

	// Check usage section
	assert.Contains(t, result, "## Usage", "expected Usage section")
	assert.Contains(t, result, "### Creating a Client", "expected Creating a Client section")
	assert.Contains(t, result, "NewClient(\"https://api.example.com\")", "expected client creation example")

	// Check regeneration section
	assert.Contains(t, result, "## Regeneration", "expected Regeneration section")
	assert.Contains(t, result, "oastools generate api.yaml --package myapi", "expected CLI command")

	// Check footer
	assert.Contains(t, result, "Generated by [oastools]", "expected footer")
	assert.Contains(t, result, "v1.0.0", "expected version in footer")
}

func TestReadmeGenerator_GenerateReadme_WithSecurity(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "Secure API",
		SecuritySchemes: []SecuritySchemeSummary{
			{
				Name:        "api_key",
				Type:        "apiKey",
				Description: "API key authentication",
				Location:    "header",
			},
			{
				Name:   "basic_auth",
				Type:   "http",
				Scheme: "basic",
			},
			{
				Name:   "bearer_auth",
				Type:   "http",
				Scheme: "bearer",
			},
			{
				Name:  "oauth2",
				Type:  "oauth2",
				Flows: []string{"authorization_code", "client_credentials"},
			},
			{
				Name:             "openid",
				Type:             "openIdConnect",
				OpenIDConnectURL: "https://auth.example.com/.well-known/openid-configuration",
			},
		},
	}

	result := g.GenerateReadme(ctx)

	// Check security section exists
	assert.Contains(t, result, "## Security", "expected Security section")

	// Check API key auth
	assert.Contains(t, result, "### api_key", "expected api_key section")
	assert.Contains(t, result, "- **Type:** apiKey", "expected apiKey type")
	assert.Contains(t, result, "- **Location:** header", "expected header location")
	assert.Contains(t, result, "WithApiKeyAPIKey(\"your-api-key\")", "expected API key usage example")

	// Check basic auth
	assert.Contains(t, result, "### basic_auth", "expected basic_auth section")
	assert.Contains(t, result, "- **Scheme:** basic", "expected basic scheme")
	assert.Contains(t, result, "WithBasicAuthBasicAuth(\"username\", \"password\")", "expected basic auth usage example")

	// Check bearer auth
	assert.Contains(t, result, "### bearer_auth", "expected bearer_auth section")
	assert.Contains(t, result, "WithBearerAuthBearerToken(\"your-token\")", "expected bearer token usage example")

	// Check OAuth2
	assert.Contains(t, result, "### oauth2", "expected oauth2 section")
	assert.Contains(t, result, "- **Flows:** authorization_code, client_credentials", "expected OAuth2 flows")
	assert.Contains(t, result, "WithOauth2OAuth2Token(\"your-access-token\")", "expected OAuth2 usage example")

	// Check OpenID Connect
	assert.Contains(t, result, "### openid", "expected openid section")
	assert.Contains(t, result, "- **Discovery URL:** https://auth.example.com/.well-known/openid-configuration", "expected discovery URL")
}

func TestReadmeGenerator_GenerateReadme_WithSplitInfo(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "Large API",
		GeneratedFiles: []GeneratedFileSummary{
			{FileName: "client.go", Description: "HTTP client"},
			{FileName: "types_shared.go", Description: "Shared types"},
			{FileName: "operations_users.go", Description: "User operations"},
			{FileName: "operations_orders.go", Description: "Order operations"},
		},
		SplitInfo: &SplitSummary{
			WasSplit:        true,
			Strategy:        "by operation tags",
			Groups:          []string{"users", "orders"},
			SharedTypesFile: "types_shared.go",
		},
	}

	result := g.GenerateReadme(ctx)

	// Check split info section
	assert.Contains(t, result, "### File Organization", "expected File Organization section")
	assert.Contains(t, result, "Files were split by operation tags", "expected split strategy")
	assert.Contains(t, result, "**Groups:**", "expected groups heading")
	assert.Contains(t, result, "- users", "expected users group")
	assert.Contains(t, result, "- orders", "expected orders group")
	assert.Contains(t, result, "**Shared types:** `types_shared.go`", "expected shared types file")
}

func TestReadmeGenerator_GenerateReadme_WithCredentialMgmt(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API with Credentials",
		Config: &GeneratorConfigSummary{
			GenerateCredentialMgmt: true,
		},
	}

	result := g.GenerateReadme(ctx)

	// Check credential provider section
	assert.Contains(t, result, "### Credential Providers", "expected Credential Providers section")
	assert.Contains(t, result, "NewEnvCredentialProvider", "expected env credential provider example")
	assert.Contains(t, result, "NewMemoryCredentialProvider", "expected memory credential provider example")
	assert.Contains(t, result, "NewCredentialChain", "expected credential chain example")
}

func TestReadmeGenerator_GenerateReadme_WithSecurityEnforce(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API with Enforcement",
		Config: &GeneratorConfigSummary{
			GenerateSecurityEnforce: true,
		},
	}

	result := g.GenerateReadme(ctx)

	// Check security validation section
	assert.Contains(t, result, "### Security Validation", "expected Security Validation section")
	assert.Contains(t, result, "NewSecurityValidator", "expected security validator example")
	assert.Contains(t, result, "ConfigureScheme", "expected ConfigureScheme example")
	assert.Contains(t, result, "ValidateOperation", "expected ValidateOperation example")
}

func TestReadmeGenerator_GenerateReadme_NoAPITitle(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		// No APITitle
	}

	result := g.GenerateReadme(ctx)

	// Should use default title
	assert.Contains(t, result, "# Generated API Client", "expected default title")
}

func TestReadmeGenerator_GenerateReadme_NoCLICommand(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "myapi",
		SourcePath:  "openapi.yaml",
		// No CLICommand
	}

	result := g.GenerateReadme(ctx)

	// Should generate default command
	assert.Contains(t, result, "oastools generate openapi.yaml --package myapi", "expected generated command")
}

func TestExtractSecuritySchemeSummaries(t *testing.T) {
	schemes := map[string]*SecurityScheme{
		"api_key": {
			Type:        "apiKey",
			Description: "API Key",
			In:          "header",
		},
		"oauth2": {
			Type: "oauth2",
			Flows: &OAuthFlows{
				AuthorizationCode: &OAuthFlow{
					AuthorizationURL: "https://example.com/authorize",
					TokenURL:         "https://example.com/token",
				},
			},
		},
		"basic": {
			Type:   "http",
			Scheme: "basic",
		},
	}

	result := ExtractSecuritySchemeSummaries(schemes)

	assert.Len(t, result, 3, "expected 3 summaries")

	// Check sorted order (alphabetical by name)
	assert.Equal(t, "api_key", result[0].Name, "expected first scheme 'api_key'")
	assert.Equal(t, "basic", result[1].Name, "expected second scheme 'basic'")
	assert.Equal(t, "oauth2", result[2].Name, "expected third scheme 'oauth2'")

	// Check api_key details
	assert.Equal(t, "header", result[0].Location, "expected header location for api_key")

	// Check basic details
	assert.Equal(t, "basic", result[1].Scheme, "expected basic scheme")

	// Check oauth2 flows
	assert.Len(t, result[2].Flows, 1, "expected 1 flow for oauth2")
	assert.Equal(t, "authorization_code", result[2].Flows[0], "expected authorization_code flow for oauth2")
}

func TestExtractSecuritySchemeSummaries_Empty(t *testing.T) {
	result := ExtractSecuritySchemeSummaries(nil)
	assert.Nil(t, result, "expected nil for empty schemes")

	result = ExtractSecuritySchemeSummaries(map[string]*SecurityScheme{})
	assert.Nil(t, result, "expected nil for empty map")
}

func TestExtractOAuth2FlowNames_OAS3(t *testing.T) {
	flows := &OAuthFlows{
		AuthorizationCode: &OAuthFlow{},
		ClientCredentials: &OAuthFlow{},
	}

	names := extractOAuth2FlowNames(flows, "")

	assert.Len(t, names, 2, "expected 2 flow names")
	// Order depends on implementation, check both exist
	assert.Contains(t, names, "authorization_code", "expected authorization_code flow")
	assert.Contains(t, names, "client_credentials", "expected client_credentials flow")
}

func TestExtractOAuth2FlowNames_OAS2(t *testing.T) {
	tests := []struct {
		flow     string
		expected string
	}{
		{"accessCode", "authorization_code"},
		{"authorizationCode", "authorization_code"},
		{"application", "client_credentials"},
		{"clientCredentials", "client_credentials"},
		{"password", "password"},
		{"implicit", "implicit"},
	}

	for _, tt := range tests {
		names := extractOAuth2FlowNames(nil, tt.flow)
		assert.Len(t, names, 1, "expected 1 flow name for %s", tt.flow)
		if len(names) == 1 {
			assert.Equal(t, tt.expected, names[0], "for %s", tt.flow)
		}
	}
}

func TestReadmeGenerator_GenerateReadme_QueryAndCookieAPIKey(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API",
		SecuritySchemes: []SecuritySchemeSummary{
			{Name: "query_key", Type: "apiKey", Location: "query"},
			{Name: "cookie_key", Type: "apiKey", Location: "cookie"},
		},
	}

	result := g.GenerateReadme(ctx)

	assert.Contains(t, result, "WithQueryKeyAPIKeyQuery(\"your-api-key\")", "expected query API key usage example")
	assert.Contains(t, result, "WithCookieKeyAPIKeyCookie(\"your-api-key\")", "expected cookie API key usage example")
}
