package generator

import (
	"strings"
	"testing"
	"time"
)

func TestNewReadmeGenerator(t *testing.T) {
	g := NewReadmeGenerator()
	if g == nil {
		t.Error("expected non-nil generator")
	}
}

func TestReadmeGenerator_GenerateReadme_Basic(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:       time.Date(2024, 1, 15, 10, 30, 0, 0, time.UTC),
		OastoolsVersion: "1.0.0",
		SourcePath:      "api.yaml",
		OASVersion:      "3.0.3",
		APITitle:        "My Test API",
		APIVersion:      "v1.2.3",
		APIDescription:  "A test API for demonstration.",
		CLICommand:      "oastools generate api.yaml --package myapi",
		PackageName:     "myapi",
		GeneratedFiles: []GeneratedFileSummary{
			{FileName: "client.go", Description: "HTTP client implementation", LineCount: 500},
			{FileName: "types.go", Description: "Data types and models", LineCount: 300},
		},
	}

	result := g.GenerateReadme(ctx)

	// Check header
	if !strings.Contains(result, "# My Test API") {
		t.Error("expected API title header")
	}
	if !strings.Contains(result, "A test API for demonstration.") {
		t.Error("expected API description")
	}

	// Check overview table
	if !strings.Contains(result, "| API Version | v1.2.3 |") {
		t.Error("expected API version in table")
	}
	if !strings.Contains(result, "| OpenAPI Version | 3.0.3 |") {
		t.Error("expected OAS version in table")
	}
	if !strings.Contains(result, "| Package | `myapi` |") {
		t.Error("expected package name in table")
	}
	if !strings.Contains(result, "| Generator Version | 1.0.0 |") {
		t.Error("expected generator version in table")
	}

	// Check files section
	if !strings.Contains(result, "## Generated Files") {
		t.Error("expected Generated Files section")
	}
	if !strings.Contains(result, "| `client.go` | HTTP client implementation (500 lines) |") {
		t.Error("expected client.go in files table")
	}
	if !strings.Contains(result, "| `types.go` | Data types and models (300 lines) |") {
		t.Error("expected types.go in files table")
	}

	// Check usage section
	if !strings.Contains(result, "## Usage") {
		t.Error("expected Usage section")
	}
	if !strings.Contains(result, "### Creating a Client") {
		t.Error("expected Creating a Client section")
	}
	if !strings.Contains(result, "NewClient(\"https://api.example.com\")") {
		t.Error("expected client creation example")
	}

	// Check regeneration section
	if !strings.Contains(result, "## Regeneration") {
		t.Error("expected Regeneration section")
	}
	if !strings.Contains(result, "oastools generate api.yaml --package myapi") {
		t.Error("expected CLI command")
	}

	// Check footer
	if !strings.Contains(result, "Generated by [oastools]") {
		t.Error("expected footer")
	}
	if !strings.Contains(result, "v1.0.0") {
		t.Error("expected version in footer")
	}
}

func TestReadmeGenerator_GenerateReadme_WithSecurity(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "Secure API",
		SecuritySchemes: []SecuritySchemeSummary{
			{
				Name:        "api_key",
				Type:        "apiKey",
				Description: "API key authentication",
				Location:    "header",
			},
			{
				Name:   "basic_auth",
				Type:   "http",
				Scheme: "basic",
			},
			{
				Name:   "bearer_auth",
				Type:   "http",
				Scheme: "bearer",
			},
			{
				Name:  "oauth2",
				Type:  "oauth2",
				Flows: []string{"authorization_code", "client_credentials"},
			},
			{
				Name:             "openid",
				Type:             "openIdConnect",
				OpenIDConnectURL: "https://auth.example.com/.well-known/openid-configuration",
			},
		},
	}

	result := g.GenerateReadme(ctx)

	// Check security section exists
	if !strings.Contains(result, "## Security") {
		t.Error("expected Security section")
	}

	// Check API key auth
	if !strings.Contains(result, "### api_key") {
		t.Error("expected api_key section")
	}
	if !strings.Contains(result, "- **Type:** apiKey") {
		t.Error("expected apiKey type")
	}
	if !strings.Contains(result, "- **Location:** header") {
		t.Error("expected header location")
	}
	if !strings.Contains(result, "WithApiKeyAPIKey(\"your-api-key\")") {
		t.Error("expected API key usage example")
	}

	// Check basic auth
	if !strings.Contains(result, "### basic_auth") {
		t.Error("expected basic_auth section")
	}
	if !strings.Contains(result, "- **Scheme:** basic") {
		t.Error("expected basic scheme")
	}
	if !strings.Contains(result, "WithBasicAuthBasicAuth(\"username\", \"password\")") {
		t.Error("expected basic auth usage example")
	}

	// Check bearer auth
	if !strings.Contains(result, "### bearer_auth") {
		t.Error("expected bearer_auth section")
	}
	if !strings.Contains(result, "WithBearerAuthBearerToken(\"your-token\")") {
		t.Error("expected bearer token usage example")
	}

	// Check OAuth2
	if !strings.Contains(result, "### oauth2") {
		t.Error("expected oauth2 section")
	}
	if !strings.Contains(result, "- **Flows:** authorization_code, client_credentials") {
		t.Error("expected OAuth2 flows")
	}
	if !strings.Contains(result, "WithOauth2OAuth2Token(\"your-access-token\")") {
		t.Error("expected OAuth2 usage example")
	}

	// Check OpenID Connect
	if !strings.Contains(result, "### openid") {
		t.Error("expected openid section")
	}
	if !strings.Contains(result, "- **Discovery URL:** https://auth.example.com/.well-known/openid-configuration") {
		t.Error("expected discovery URL")
	}
}

func TestReadmeGenerator_GenerateReadme_WithSplitInfo(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "Large API",
		GeneratedFiles: []GeneratedFileSummary{
			{FileName: "client.go", Description: "HTTP client"},
			{FileName: "types_shared.go", Description: "Shared types"},
			{FileName: "operations_users.go", Description: "User operations"},
			{FileName: "operations_orders.go", Description: "Order operations"},
		},
		SplitInfo: &SplitSummary{
			WasSplit:        true,
			Strategy:        "by operation tags",
			Groups:          []string{"users", "orders"},
			SharedTypesFile: "types_shared.go",
		},
	}

	result := g.GenerateReadme(ctx)

	// Check split info section
	if !strings.Contains(result, "### File Organization") {
		t.Error("expected File Organization section")
	}
	if !strings.Contains(result, "Files were split by operation tags") {
		t.Error("expected split strategy")
	}
	if !strings.Contains(result, "**Groups:**") {
		t.Error("expected groups heading")
	}
	if !strings.Contains(result, "- users") {
		t.Error("expected users group")
	}
	if !strings.Contains(result, "- orders") {
		t.Error("expected orders group")
	}
	if !strings.Contains(result, "**Shared types:** `types_shared.go`") {
		t.Error("expected shared types file")
	}
}

func TestReadmeGenerator_GenerateReadme_WithCredentialMgmt(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API with Credentials",
		Config: &GeneratorConfigSummary{
			GenerateCredentialMgmt: true,
		},
	}

	result := g.GenerateReadme(ctx)

	// Check credential provider section
	if !strings.Contains(result, "### Credential Providers") {
		t.Error("expected Credential Providers section")
	}
	if !strings.Contains(result, "NewEnvCredentialProvider") {
		t.Error("expected env credential provider example")
	}
	if !strings.Contains(result, "NewMemoryCredentialProvider") {
		t.Error("expected memory credential provider example")
	}
	if !strings.Contains(result, "NewCredentialChain") {
		t.Error("expected credential chain example")
	}
}

func TestReadmeGenerator_GenerateReadme_WithSecurityEnforce(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API with Enforcement",
		Config: &GeneratorConfigSummary{
			GenerateSecurityEnforce: true,
		},
	}

	result := g.GenerateReadme(ctx)

	// Check security validation section
	if !strings.Contains(result, "### Security Validation") {
		t.Error("expected Security Validation section")
	}
	if !strings.Contains(result, "NewSecurityValidator") {
		t.Error("expected security validator example")
	}
	if !strings.Contains(result, "ConfigureScheme") {
		t.Error("expected ConfigureScheme example")
	}
	if !strings.Contains(result, "ValidateOperation") {
		t.Error("expected ValidateOperation example")
	}
}

func TestReadmeGenerator_GenerateReadme_NoAPITitle(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		// No APITitle
	}

	result := g.GenerateReadme(ctx)

	// Should use default title
	if !strings.Contains(result, "# Generated API Client") {
		t.Error("expected default title")
	}
}

func TestReadmeGenerator_GenerateReadme_NoCLICommand(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "myapi",
		SourcePath:  "openapi.yaml",
		// No CLICommand
	}

	result := g.GenerateReadme(ctx)

	// Should generate default command
	if !strings.Contains(result, "oastools generate openapi.yaml --package myapi") {
		t.Error("expected generated command")
	}
}

func TestExtractSecuritySchemeSummaries(t *testing.T) {
	schemes := map[string]*SecurityScheme{
		"api_key": {
			Type:        "apiKey",
			Description: "API Key",
			In:          "header",
		},
		"oauth2": {
			Type: "oauth2",
			Flows: &OAuthFlows{
				AuthorizationCode: &OAuthFlow{
					AuthorizationURL: "https://example.com/authorize",
					TokenURL:         "https://example.com/token",
				},
			},
		},
		"basic": {
			Type:   "http",
			Scheme: "basic",
		},
	}

	result := ExtractSecuritySchemeSummaries(schemes)

	if len(result) != 3 {
		t.Errorf("expected 3 summaries, got %d", len(result))
	}

	// Check sorted order (alphabetical by name)
	if result[0].Name != "api_key" {
		t.Errorf("expected first scheme 'api_key', got %s", result[0].Name)
	}
	if result[1].Name != "basic" {
		t.Errorf("expected second scheme 'basic', got %s", result[1].Name)
	}
	if result[2].Name != "oauth2" {
		t.Errorf("expected third scheme 'oauth2', got %s", result[2].Name)
	}

	// Check api_key details
	if result[0].Location != "header" {
		t.Error("expected header location for api_key")
	}

	// Check basic details
	if result[1].Scheme != "basic" {
		t.Error("expected basic scheme")
	}

	// Check oauth2 flows
	if len(result[2].Flows) != 1 || result[2].Flows[0] != "authorization_code" {
		t.Error("expected authorization_code flow for oauth2")
	}
}

func TestExtractSecuritySchemeSummaries_Empty(t *testing.T) {
	result := ExtractSecuritySchemeSummaries(nil)
	if result != nil {
		t.Error("expected nil for empty schemes")
	}

	result = ExtractSecuritySchemeSummaries(map[string]*SecurityScheme{})
	if result != nil {
		t.Error("expected nil for empty map")
	}
}

func TestExtractOAuth2FlowNames_OAS3(t *testing.T) {
	flows := &OAuthFlows{
		AuthorizationCode: &OAuthFlow{},
		ClientCredentials: &OAuthFlow{},
	}

	names := extractOAuth2FlowNames(flows, "")

	if len(names) != 2 {
		t.Errorf("expected 2 flow names, got %d", len(names))
	}
	// Order depends on implementation, check both exist
	hasAuthCode := false
	hasClientCreds := false
	for _, n := range names {
		if n == "authorization_code" {
			hasAuthCode = true
		}
		if n == "client_credentials" {
			hasClientCreds = true
		}
	}
	if !hasAuthCode {
		t.Error("expected authorization_code flow")
	}
	if !hasClientCreds {
		t.Error("expected client_credentials flow")
	}
}

func TestExtractOAuth2FlowNames_OAS2(t *testing.T) {
	tests := []struct {
		flow     string
		expected string
	}{
		{"accessCode", "authorization_code"},
		{"authorizationCode", "authorization_code"},
		{"application", "client_credentials"},
		{"clientCredentials", "client_credentials"},
		{"password", "password"},
		{"implicit", "implicit"},
	}

	for _, tt := range tests {
		names := extractOAuth2FlowNames(nil, tt.flow)
		if len(names) != 1 {
			t.Errorf("expected 1 flow name for %s, got %d", tt.flow, len(names))
			continue
		}
		if names[0] != tt.expected {
			t.Errorf("for %s expected %s, got %s", tt.flow, tt.expected, names[0])
		}
	}
}

func TestReadmeGenerator_GenerateReadme_QueryAndCookieAPIKey(t *testing.T) {
	g := NewReadmeGenerator()

	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: "api",
		APITitle:    "API",
		SecuritySchemes: []SecuritySchemeSummary{
			{Name: "query_key", Type: "apiKey", Location: "query"},
			{Name: "cookie_key", Type: "apiKey", Location: "cookie"},
		},
	}

	result := g.GenerateReadme(ctx)

	if !strings.Contains(result, "WithQueryKeyAPIKeyQuery(\"your-api-key\")") {
		t.Error("expected query API key usage example")
	}
	if !strings.Contains(result, "WithCookieKeyAPIKeyCookie(\"your-api-key\")") {
		t.Error("expected cookie API key usage example")
	}
}
