package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"unicode"

	"github.com/erraggy/oastools/parser"
)

// SecurityHelperGenerator generates security helper code for a client.
type SecurityHelperGenerator struct {
	// PackageName is the Go package name for generated code.
	PackageName string
}

// NewSecurityHelperGenerator creates a new SecurityHelperGenerator.
func NewSecurityHelperGenerator(packageName string) *SecurityHelperGenerator {
	return &SecurityHelperGenerator{
		PackageName: packageName,
	}
}

// GenerateSecurityHelpers generates ClientOption functions for all security schemes.
// Returns a complete Go source file with package declaration and imports.
func (g *SecurityHelperGenerator) GenerateSecurityHelpers(schemes map[string]*parser.SecurityScheme) string {
	if len(schemes) == 0 {
		return ""
	}

	var buf bytes.Buffer

	// Header and imports
	fmt.Fprintf(&buf, `// Code generated by oastools. DO NOT EDIT.

package %s

import (
	"context"
	"encoding/base64"
	"net/http"
)

`, g.PackageName)

	buf.WriteString("// Security scheme helpers\n")
	buf.WriteString("// These ClientOption functions configure authentication for API requests.\n\n")

	// Sort scheme names for deterministic output
	schemeNames := make([]string, 0, len(schemes))
	for name := range schemes {
		schemeNames = append(schemeNames, name)
	}
	sort.Strings(schemeNames)

	for _, name := range schemeNames {
		scheme := schemes[name]
		if scheme == nil {
			continue
		}

		helper := g.generateSchemeHelper(name, scheme)
		if helper != "" {
			buf.WriteString(helper)
			buf.WriteString("\n")
		}
	}

	return buf.String()
}

// generateSchemeHelper generates a ClientOption function for a single security scheme.
func (g *SecurityHelperGenerator) generateSchemeHelper(name string, scheme *parser.SecurityScheme) string {
	switch scheme.Type {
	case schemeTypeAPIKey:
		return g.generateAPIKeyHelper(name, scheme)
	case schemeTypeHTTP:
		return g.generateHTTPAuthHelper(name, scheme)
	case "basic":
		// OAS 2.0 basic auth type - treat as HTTP basic auth
		return g.generateBasicAuthHelper(name, scheme)
	case schemeTypeOAuth2:
		return g.generateOAuth2Helper(name, scheme)
	case schemeTypeOpenIDConnect:
		return g.generateOpenIDConnectHelper(name, scheme)
	default:
		return ""
	}
}

// generateAPIKeyHelper generates a ClientOption for API key authentication.
func (g *SecurityHelperGenerator) generateAPIKeyHelper(name string, scheme *parser.SecurityScheme) string {
	funcName := sanitizeSecurityFunctionName(name)
	keyName := scheme.Name
	description := scheme.Description
	if description == "" {
		description = fmt.Sprintf("API key authentication via %s", scheme.In)
	}

	var buf bytes.Buffer

	switch scheme.In {
	case "header":
		fmt.Fprintf(&buf, `// With%sAPIKey sets the %s header for API key authentication.
`, funcName, keyName)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sAPIKey(key string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.Header.Set(%q, key)
			return nil
		})
		return nil
	}
}
`, funcName, keyName)

	case "query":
		fmt.Fprintf(&buf, `// With%sAPIKeyQuery sets the %s query parameter for API key authentication.
`, funcName, keyName)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sAPIKeyQuery(key string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			q := req.URL.Query()
			q.Set(%q, key)
			req.URL.RawQuery = q.Encode()
			return nil
		})
		return nil
	}
}
`, funcName, keyName)

	case "cookie":
		fmt.Fprintf(&buf, `// With%sAPIKeyCookie sets the %s cookie for API key authentication.
`, funcName, keyName)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sAPIKeyCookie(key string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.AddCookie(&http.Cookie{Name: %q, Value: key})
			return nil
		})
		return nil
	}
}
`, funcName, keyName)
	}

	return buf.String()
}

// generateHTTPAuthHelper generates a ClientOption for HTTP authentication.
func (g *SecurityHelperGenerator) generateHTTPAuthHelper(name string, scheme *parser.SecurityScheme) string {
	funcName := sanitizeSecurityFunctionName(name)
	description := scheme.Description

	var buf bytes.Buffer

	switch strings.ToLower(scheme.Scheme) {
	case "basic":
		fmt.Fprintf(&buf, `// With%sBasicAuth sets Basic authentication credentials.
`, funcName)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sBasicAuth(username, password string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.SetBasicAuth(username, password)
			return nil
		})
		return nil
	}
}
`, funcName)

	case "bearer":
		bearerFormat := scheme.BearerFormat
		formatComment := ""
		if bearerFormat != "" {
			formatComment = fmt.Sprintf("\n// Bearer format: %s", bearerFormat)
		}
		fmt.Fprintf(&buf, `// With%sBearerToken sets the Bearer token for authentication.%s
`, funcName, formatComment)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sBearerToken(token string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.Header.Set("Authorization", "Bearer "+token)
			return nil
		})
		return nil
	}
}
`, funcName)

	default:
		// Generic HTTP auth scheme
		schemeName := scheme.Scheme
		if schemeName == "" {
			schemeName = "Custom"
		}
		fmt.Fprintf(&buf, `// With%sHTTPAuth sets the %s authentication header.
`, funcName, schemeName)
		if description != "" {
			fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
		}
		fmt.Fprintf(&buf, `func With%sHTTPAuth(credentials string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.Header.Set("Authorization", %q+" "+credentials)
			return nil
		})
		return nil
	}
}
`, funcName, schemeName)
	}

	return buf.String()
}

// generateBasicAuthHelper generates a ClientOption for OAS 2.0 basic authentication.
func (g *SecurityHelperGenerator) generateBasicAuthHelper(name string, scheme *parser.SecurityScheme) string {
	funcName := sanitizeSecurityFunctionName(name)
	description := scheme.Description

	var buf bytes.Buffer

	fmt.Fprintf(&buf, `// With%sBasicAuth sets Basic authentication credentials.
`, funcName)
	if description != "" {
		fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
	}
	fmt.Fprintf(&buf, `func With%sBasicAuth(username, password string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.SetBasicAuth(username, password)
			return nil
		})
		return nil
	}
}
`, funcName)

	return buf.String()
}

// generateOAuth2Helper generates a ClientOption for OAuth2 authentication.
func (g *SecurityHelperGenerator) generateOAuth2Helper(name string, scheme *parser.SecurityScheme) string {
	funcName := sanitizeSecurityFunctionName(name)
	description := scheme.Description

	// Collect available scopes for documentation
	scopes := g.collectOAuth2Scopes(scheme)
	scopesComment := ""
	if len(scopes) > 0 {
		scopesComment = "\n// Available scopes: " + strings.Join(scopes, ", ")
	}

	var buf bytes.Buffer

	fmt.Fprintf(&buf, `// With%sOAuth2Token sets the OAuth2 bearer token for authentication.%s
`, funcName, scopesComment)
	if description != "" {
		fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
	}
	fmt.Fprintf(&buf, `func With%sOAuth2Token(token string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.Header.Set("Authorization", "Bearer "+token)
			return nil
		})
		return nil
	}
}
`, funcName)

	return buf.String()
}

// collectOAuth2Scopes collects all scopes from OAuth2 flows.
func (g *SecurityHelperGenerator) collectOAuth2Scopes(scheme *parser.SecurityScheme) []string {
	return collectScopesFromFlows(scheme.Scopes, scheme.Flows)
}

// generateOpenIDConnectHelper generates a ClientOption for OpenID Connect authentication.
func (g *SecurityHelperGenerator) generateOpenIDConnectHelper(name string, scheme *parser.SecurityScheme) string {
	funcName := sanitizeSecurityFunctionName(name)
	description := scheme.Description
	discoveryURL := scheme.OpenIDConnectURL

	var buf bytes.Buffer

	urlComment := ""
	if discoveryURL != "" {
		urlComment = fmt.Sprintf("\n// OpenID Connect Discovery URL: %s", discoveryURL)
	}

	fmt.Fprintf(&buf, `// With%sToken sets the OpenID Connect token for authentication.%s
`, funcName, urlComment)
	if description != "" {
		fmt.Fprintf(&buf, "// %s\n", cleanDescription(description))
	}
	fmt.Fprintf(&buf, `func With%sToken(token string) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			req.Header.Set("Authorization", "Bearer "+token)
			return nil
		})
		return nil
	}
}
`, funcName)

	return buf.String()
}

// sanitizeSecurityFunctionName converts a security scheme name to a valid Go function name suffix.
// Examples: "api_key" -> "ApiKey", "bearer-auth" -> "BearerAuth", "OAuth2" -> "OAuth2"
func sanitizeSecurityFunctionName(name string) string {
	if name == "" {
		return "Default"
	}

	// Convert to title case, handling separators
	var result strings.Builder
	capitalizeNext := true

	for _, r := range name {
		if r == '_' || r == '-' || r == ' ' || r == '.' {
			capitalizeNext = true
			continue
		}

		if !unicode.IsLetter(r) && !unicode.IsDigit(r) {
			// Skip non-alphanumeric characters
			continue
		}

		if capitalizeNext {
			result.WriteRune(unicode.ToUpper(r))
			capitalizeNext = false
		} else {
			result.WriteRune(r)
		}
	}

	s := result.String()
	if s == "" {
		return "Default"
	}

	// Ensure first character is uppercase
	runes := []rune(s)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// GenerateSecurityImports returns the imports needed for security helpers.
func (g *SecurityHelperGenerator) GenerateSecurityImports() []string {
	return []string{
		"context",
		"net/http",
	}
}

// SecuritySchemeInfo contains information about a security scheme for documentation.
type SecuritySchemeInfo struct {
	Name         string
	Type         string
	Scheme       string // For HTTP auth
	In           string // For API key
	Description  string
	Scopes       []string // For OAuth2
	FlowTypes    []string // For OAuth2
	DiscoveryURL string   // For OpenID Connect
}

// GetSecuritySchemeInfo extracts information about security schemes for documentation.
func GetSecuritySchemeInfo(schemes map[string]*parser.SecurityScheme) []SecuritySchemeInfo {
	if len(schemes) == 0 {
		return nil
	}

	result := make([]SecuritySchemeInfo, 0, len(schemes))

	// Sort scheme names for deterministic output
	schemeNames := make([]string, 0, len(schemes))
	for name := range schemes {
		schemeNames = append(schemeNames, name)
	}
	sort.Strings(schemeNames)

	for _, name := range schemeNames {
		scheme := schemes[name]
		if scheme == nil {
			continue
		}

		info := SecuritySchemeInfo{
			Name:        name,
			Type:        scheme.Type,
			Description: scheme.Description,
		}

		switch scheme.Type {
		case schemeTypeAPIKey:
			info.In = scheme.In
		case schemeTypeHTTP:
			info.Scheme = scheme.Scheme
		case schemeTypeOAuth2:
			g := NewSecurityHelperGenerator("")
			info.Scopes = g.collectOAuth2Scopes(scheme)
			info.FlowTypes = getOAuth2FlowTypes(scheme)
		case schemeTypeOpenIDConnect:
			info.DiscoveryURL = scheme.OpenIDConnectURL
		}

		result = append(result, info)
	}

	return result
}

// getOAuth2FlowTypes returns the list of OAuth2 flow types defined in a scheme.
func getOAuth2FlowTypes(scheme *parser.SecurityScheme) []string {
	var flows []string

	// OAS 2.0 style
	if scheme.Flow != "" {
		flows = append(flows, scheme.Flow)
	}

	// OAS 3.0+ style
	if scheme.Flows != nil {
		if scheme.Flows.Implicit != nil {
			flows = append(flows, "implicit")
		}
		if scheme.Flows.Password != nil {
			flows = append(flows, "password")
		}
		if scheme.Flows.ClientCredentials != nil {
			flows = append(flows, "clientCredentials")
		}
		if scheme.Flows.AuthorizationCode != nil {
			flows = append(flows, "authorizationCode")
		}
	}

	return flows
}
