package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/erraggy/oastools/parser"
)

// SecurityEnforceGenerator generates security enforcement code.
type SecurityEnforceGenerator struct {
	// PackageName is the Go package name for generated code.
	PackageName string
}

// NewSecurityEnforceGenerator creates a new SecurityEnforceGenerator.
func NewSecurityEnforceGenerator(packageName string) *SecurityEnforceGenerator {
	return &SecurityEnforceGenerator{
		PackageName: packageName,
	}
}

// OperationSecurityRequirements maps operation IDs to their security requirements.
type OperationSecurityRequirements map[string][]parser.SecurityRequirement

// writeSecurityRequirement writes a single security requirement entry to the buffer.
// The indent parameter controls the leading tabs (e.g., "\t\t" for nested entries).
func writeSecurityRequirement(buf *bytes.Buffer, schemeName string, scopes []string, indent string) {
	_, _ = fmt.Fprintf(buf, "%s{Scheme: %q", indent, schemeName)
	if len(scopes) > 0 {
		_, _ = fmt.Fprintf(buf, ", Scopes: []string{%s}", quotedStrings(scopes))
	}
	buf.WriteString("},\n")
}

// GenerateSecurityEnforceFile generates the security_enforce.go file.
func (g *SecurityEnforceGenerator) GenerateSecurityEnforceFile(opSecurity OperationSecurityRequirements, globalSecurity []parser.SecurityRequirement) string {
	var buf bytes.Buffer

	// Header and imports
	_, _ = fmt.Fprintf(&buf, `// Code generated by oastools. DO NOT EDIT.

package %s

import (
	"fmt"
)

`, g.PackageName)

	// SecurityRequirement type
	buf.WriteString(g.generateSecurityRequirementType())

	// Operation security map
	buf.WriteString(g.generateOperationSecurityMap(opSecurity, globalSecurity))

	// Security validator
	buf.WriteString(g.generateSecurityValidator())

	return buf.String()
}

// GenerateBaseSecurityEnforceFile generates the base security_enforce.go file for split generation.
// This file contains shared types and an empty OperationSecurity map that will be populated
// by init() functions in group-specific files.
func (g *SecurityEnforceGenerator) GenerateBaseSecurityEnforceFile(globalSecurity []parser.SecurityRequirement) string {
	var buf bytes.Buffer

	// Header and imports
	_, _ = fmt.Fprintf(&buf, `// Code generated by oastools. DO NOT EDIT.

package %s

import (
	"fmt"
)

`, g.PackageName)

	// SecurityRequirement type
	buf.WriteString(g.generateSecurityRequirementType())

	// Empty operation security map (populated by init() functions in group files)
	buf.WriteString(`// OperationSecurity maps operation IDs to their security requirements.
// Each operation may have multiple alternative security requirements (OR relationship).
// Within each requirement, multiple schemes may be required (AND relationship).
// NOTE: This map is populated by init() functions in security_enforce_*.go files.
var OperationSecurity = make(map[string][]SecurityRequirement)

`)

	// Generate global security if present
	if len(globalSecurity) > 0 {
		buf.WriteString(`// GlobalSecurity defines the default security requirements for operations
// that don't have operation-specific security defined.
var GlobalSecurity = []SecurityRequirement{
`)
		for _, req := range globalSecurity {
			for schemeName, scopes := range req {
				writeSecurityRequirement(&buf, schemeName, scopes, "\t")
			}
		}
		buf.WriteString(`}

`)
	}

	// Security validator
	buf.WriteString(g.generateSecurityValidator())

	return buf.String()
}

// GenerateSecurityEnforceGroupFile generates a security_enforce_{group}.go file.
// This file contains an init() function that populates the shared OperationSecurity map
// with the security requirements for operations in this group.
func (g *SecurityEnforceGenerator) GenerateSecurityEnforceGroupFile(_, groupDisplayName string, groupOpSecurity OperationSecurityRequirements) string {
	var buf bytes.Buffer

	// Header (no imports needed - init() just populates the map)
	_, _ = fmt.Fprintf(&buf, `// Code generated by oastools. DO NOT EDIT.
// Security requirements for %s operations.

package %s

`, groupDisplayName, g.PackageName)

	// Generate init() function to populate the map
	buf.WriteString("func init() {\n")

	// Sort operation IDs for deterministic output
	opIDs := make([]string, 0, len(groupOpSecurity))
	for opID := range groupOpSecurity {
		opIDs = append(opIDs, opID)
	}
	sort.Strings(opIDs)

	for _, opID := range opIDs {
		reqs := groupOpSecurity[opID]
		if len(reqs) == 0 {
			continue
		}

		_, _ = fmt.Fprintf(&buf, "\tOperationSecurity[%q] = []SecurityRequirement{\n", opID)
		for _, req := range reqs {
			for schemeName, scopes := range req {
				writeSecurityRequirement(&buf, schemeName, scopes, "\t\t")
			}
		}
		buf.WriteString("\t}\n")
	}

	buf.WriteString("}\n")

	return buf.String()
}

// generateSecurityRequirementType generates the SecurityRequirement struct.
func (g *SecurityEnforceGenerator) generateSecurityRequirementType() string {
	return `// SecurityRequirement represents a security requirement for an operation.
type SecurityRequirement struct {
	// Scheme is the name of the security scheme.
	Scheme string
	// Scopes are the required OAuth2 scopes (empty for non-OAuth2 schemes).
	Scopes []string
}

`
}

// generateOperationSecurityMap generates the operation security requirements map.
func (g *SecurityEnforceGenerator) generateOperationSecurityMap(opSecurity OperationSecurityRequirements, globalSecurity []parser.SecurityRequirement) string {
	var buf bytes.Buffer

	buf.WriteString(`// OperationSecurity maps operation IDs to their security requirements.
// Each operation may have multiple alternative security requirements (OR relationship).
// Within each requirement, multiple schemes may be required (AND relationship).
var OperationSecurity = map[string][]SecurityRequirement{
`)

	// Sort operation IDs for deterministic output
	opIDs := make([]string, 0, len(opSecurity))
	for opID := range opSecurity {
		opIDs = append(opIDs, opID)
	}
	sort.Strings(opIDs)

	for _, opID := range opIDs {
		reqs := opSecurity[opID]
		if len(reqs) == 0 {
			continue
		}

		_, _ = fmt.Fprintf(&buf, "\t%q: {\n", opID)
		for _, req := range reqs {
			for schemeName, scopes := range req {
				writeSecurityRequirement(&buf, schemeName, scopes, "\t\t")
			}
		}
		buf.WriteString("\t},\n")
	}

	buf.WriteString(`}

`)

	// Generate global security if present
	if len(globalSecurity) > 0 {
		buf.WriteString(`// GlobalSecurity defines the default security requirements for operations
// that don't have operation-specific security defined.
var GlobalSecurity = []SecurityRequirement{
`)
		for _, req := range globalSecurity {
			for schemeName, scopes := range req {
				writeSecurityRequirement(&buf, schemeName, scopes, "\t")
			}
		}
		buf.WriteString(`}

`)
	}

	return buf.String()
}

// generateSecurityValidator generates the SecurityValidator struct and methods.
func (g *SecurityEnforceGenerator) generateSecurityValidator() string {
	return `// SecurityValidator validates that required security is configured.
type SecurityValidator struct {
	configuredSchemes map[string]bool
	configuredScopes  map[string]map[string]bool
}

// NewSecurityValidator creates a new security validator.
func NewSecurityValidator() *SecurityValidator {
	return &SecurityValidator{
		configuredSchemes: make(map[string]bool),
		configuredScopes:  make(map[string]map[string]bool),
	}
}

// ConfigureScheme marks a security scheme as configured with optional scopes.
func (v *SecurityValidator) ConfigureScheme(scheme string, scopes ...string) {
	v.configuredSchemes[scheme] = true
	if v.configuredScopes[scheme] == nil {
		v.configuredScopes[scheme] = make(map[string]bool)
	}
	for _, scope := range scopes {
		v.configuredScopes[scheme][scope] = true
	}
}

// ValidateOperation checks if the required security for an operation is configured.
// Returns nil if security is properly configured, or an error describing what's missing.
func (v *SecurityValidator) ValidateOperation(operationID string) error {
	reqs, ok := OperationSecurity[operationID]
	if !ok || len(reqs) == 0 {
		// No security required for this operation
		return nil
	}

	// Check if ANY of the security requirements are satisfied (OR relationship)
	for _, req := range reqs {
		if v.configuredSchemes[req.Scheme] {
			if len(req.Scopes) == 0 {
				// Scheme configured, no scopes required
				return nil
			}
			// Check if all required scopes are configured
			allScopes := true
			for _, scope := range req.Scopes {
				if !v.configuredScopes[req.Scheme][scope] {
					allScopes = false
					break
				}
			}
			if allScopes {
				return nil
			}
		}
	}

	return fmt.Errorf("operation %q requires one of: %v", operationID, formatRequirements(reqs))
}

// formatRequirements formats security requirements for error messages.
func formatRequirements(reqs []SecurityRequirement) string {
	var parts []string
	for _, req := range reqs {
		if len(req.Scopes) > 0 {
			parts = append(parts, fmt.Sprintf("%s (scopes: %v)", req.Scheme, req.Scopes))
		} else {
			parts = append(parts, req.Scheme)
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}
`
}

// quotedStrings returns a comma-separated list of quoted strings.
func quotedStrings(strs []string) string {
	quoted := make([]string, len(strs))
	for i, s := range strs {
		quoted[i] = fmt.Sprintf("%q", s)
	}
	return strings.Join(quoted, ", ")
}

// ExtractOperationSecurityOAS3 extracts security requirements from an OAS 3.x document.
func ExtractOperationSecurityOAS3(doc *parser.OAS3Document) OperationSecurityRequirements {
	result := make(OperationSecurityRequirements)

	if doc.Paths == nil {
		return result
	}

	for path, pathItem := range doc.Paths {
		if pathItem == nil {
			continue
		}

		methodOps := map[string]*parser.Operation{
			"get":     pathItem.Get,
			"put":     pathItem.Put,
			"post":    pathItem.Post,
			"delete":  pathItem.Delete,
			"options": pathItem.Options,
			"head":    pathItem.Head,
			"patch":   pathItem.Patch,
			"trace":   pathItem.Trace,
		}

		for method, op := range methodOps {
			if op == nil {
				continue
			}

			// Always use operationToMethodName for consistency with code generator.
			// This ensures the key matches what's stored in group.Operations.
			opID := operationToMethodName(op, path, method)

			// Use operation-level security if defined, otherwise fall back to global
			if op.Security != nil {
				result[opID] = op.Security
			} else if doc.Security != nil {
				result[opID] = doc.Security
			}
		}
	}

	return result
}

// ExtractOperationSecurityOAS2 extracts security requirements from an OAS 2.0 document.
func ExtractOperationSecurityOAS2(doc *parser.OAS2Document) OperationSecurityRequirements {
	result := make(OperationSecurityRequirements)

	if doc.Paths == nil {
		return result
	}

	for path, pathItem := range doc.Paths {
		if pathItem == nil {
			continue
		}

		methodOps := map[string]*parser.Operation{
			"get":     pathItem.Get,
			"put":     pathItem.Put,
			"post":    pathItem.Post,
			"delete":  pathItem.Delete,
			"options": pathItem.Options,
			"head":    pathItem.Head,
			"patch":   pathItem.Patch,
		}

		for method, op := range methodOps {
			if op == nil {
				continue
			}

			// Always use operationToMethodName for consistency with code generator.
			// This ensures the key matches what's stored in group.Operations.
			opID := operationToMethodName(op, path, method)

			// Use operation-level security if defined, otherwise fall back to global
			if op.Security != nil {
				result[opID] = op.Security
			} else if doc.Security != nil {
				result[opID] = doc.Security
			}
		}
	}

	return result
}
