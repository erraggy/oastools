// Code generated by oastools. DO NOT EDIT.

package {{.Header.PackageName}}

import (
	"fmt"
	"net/http"

	"github.com/erraggy/oastools/httpvalidator"
	"github.com/erraggy/oastools/parser"
)

// RequestBinder validates and binds HTTP requests to typed request structs.
type RequestBinder struct {
	validator *httpvalidator.Validator
}

// NewRequestBinder creates a new RequestBinder from a parsed OpenAPI specification.
func NewRequestBinder(parsed *parser.ParseResult) (*RequestBinder, error) {
	v, err := httpvalidator.New(parsed)
	if err != nil {
		return nil, fmt.Errorf("failed to create validator: %w", err)
	}
	return &RequestBinder{validator: v}, nil
}

// NewRequestBinderFromValidator creates a new RequestBinder from an existing validator.
func NewRequestBinderFromValidator(v *httpvalidator.Validator) *RequestBinder {
	return &RequestBinder{validator: v}
}

// BindingError represents a request binding failure.
type BindingError struct {
	ValidationResult *httpvalidator.RequestValidationResult
	Message          string
}

func (e *BindingError) Error() string {
	if e.Message != "" {
		return e.Message
	}
	if e.ValidationResult != nil && len(e.ValidationResult.Errors) > 0 {
		return e.ValidationResult.Errors[0].Message
	}
	return "request binding failed"
}

// ValidationErrors returns the validation errors if any.
func (e *BindingError) ValidationErrors() []httpvalidator.ValidationError {
	if e.ValidationResult != nil {
		return e.ValidationResult.Errors
	}
	return nil
}

{{range .Operations}}
// Bind{{.MethodName}}Request validates and binds an HTTP request to a {{.RequestType}}.
func (b *RequestBinder) Bind{{.MethodName}}Request(r *http.Request) (*{{.RequestType}}, error) {
	result, err := b.validator.ValidateRequest(r)
	if err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}
	if !result.Valid {
		return nil, &BindingError{ValidationResult: result}
	}

	req := &{{.RequestType}}{
		HTTPRequest: r,
	}

{{range .PathParams}}
	// Bind path parameter: {{.Name}}
	if v, ok := result.PathParams["{{.Name}}"]; ok {
		{{- if eq .SchemaType "integer"}}
		if val, ok := v.(float64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		} else if val, ok := v.(int); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		} else if val, ok := v.(int64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		}
		{{- else if eq .SchemaType "number"}}
		if val, ok := v.(float64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		}
		{{- else if eq .SchemaType "boolean"}}
		if val, ok := v.(bool); ok {
			req.{{.FieldName}} = val
		}
		{{- else}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = val
		}
		{{- end}}
	}
{{end}}

{{range .QueryParams}}
	// Bind query parameter: {{.Name}}
	if v, ok := result.QueryParams["{{.Name}}"]; ok && v != nil {
		{{- if .IsPointer}}
		{{- if eq .SchemaType "integer"}}
		if val, ok := v.(float64); ok {
			converted := {{.GoType | trimPointer}}(val)
			req.{{.FieldName}} = &converted
		} else if val, ok := v.(int); ok {
			converted := {{.GoType | trimPointer}}(val)
			req.{{.FieldName}} = &converted
		} else if val, ok := v.(int64); ok {
			converted := {{.GoType | trimPointer}}(val)
			req.{{.FieldName}} = &converted
		}
		{{- else if eq .SchemaType "number"}}
		if val, ok := v.(float64); ok {
			converted := {{.GoType | trimPointer}}(val)
			req.{{.FieldName}} = &converted
		}
		{{- else if eq .SchemaType "boolean"}}
		if val, ok := v.(bool); ok {
			req.{{.FieldName}} = &val
		}
		{{- else if eq .SchemaType "array"}}
		if val, ok := v.([]any); ok {
			arr := make({{.GoType | trimPointer}}, len(val))
			for i, item := range val {
				if s, ok := item.(string); ok {
					arr[i] = s
				}
			}
			req.{{.FieldName}} = &arr
		}
		{{- else}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = &val
		}
		{{- end}}
		{{- else}}
		{{- if eq .SchemaType "integer"}}
		if val, ok := v.(float64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		} else if val, ok := v.(int); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		} else if val, ok := v.(int64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		}
		{{- else if eq .SchemaType "number"}}
		if val, ok := v.(float64); ok {
			req.{{.FieldName}} = {{.GoType}}(val)
		}
		{{- else if eq .SchemaType "boolean"}}
		if val, ok := v.(bool); ok {
			req.{{.FieldName}} = val
		}
		{{- else if eq .SchemaType "array"}}
		if val, ok := v.([]any); ok {
			arr := make({{.GoType}}, len(val))
			for i, item := range val {
				if s, ok := item.(string); ok {
					arr[i] = s
				}
			}
			req.{{.FieldName}} = arr
		}
		{{- else}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = val
		}
		{{- end}}
		{{- end}}
	}
{{end}}

{{range .HeaderParams}}
	// Bind header parameter: {{.Name}}
	if v, ok := result.HeaderParams["{{.Name}}"]; ok && v != nil {
		{{- if .IsPointer}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = &val
		}
		{{- else}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = val
		}
		{{- end}}
	}
{{end}}

{{range .CookieParams}}
	// Bind cookie parameter: {{.Name}}
	if v, ok := result.CookieParams["{{.Name}}"]; ok && v != nil {
		{{- if .IsPointer}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = &val
		}
		{{- else}}
		if val, ok := v.(string); ok {
			req.{{.FieldName}} = val
		}
		{{- end}}
	}
{{end}}

	return req, nil
}

{{end}}
