// Code generated by oastools. DO NOT EDIT.

package {{.Header.PackageName}}

import (
	"context"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
)

// RouterOption configures the chi router.
type RouterOption func(chi.Router)

// NewChiRouter creates a chi.Router that dispatches requests to the server.
// Unlike the stdlib router, chi handles path parameter extraction natively.
func NewChiRouter(server ServerInterface, opts ...RouterOption) chi.Router {
	r := chi.NewRouter()

	// Apply router options (middleware, etc.)
	for _, opt := range opts {
		opt(r)
	}

	// Register routes
{{range .Operations}}
	{{- $chiMethod := .Method | methodToChiFunc}}
	{{- if $chiMethod}}
	r.{{$chiMethod}}("{{.Path}}", func(w http.ResponseWriter, req *http.Request) {
		handle{{.MethodName}}Chi(server, w, req)
	})
	{{- else}}
	r.Method("{{.Method | upper}}", "{{.Path}}", http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		handle{{.MethodName}}Chi(server, w, req)
	}))
	{{- end}}
{{end}}

	return r
}

// WithMiddleware returns a RouterOption that adds middleware to the router.
// Middleware is applied in order (first added = outermost).
func WithMiddleware(mw ...func(http.Handler) http.Handler) RouterOption {
	return func(r chi.Router) {
		r.Use(mw...)
	}
}

// ErrorHandler is a function that handles errors from server handlers.
// It receives the request and error for logging purposes.
type ErrorHandler func(r *http.Request, err error)

// errorHandlerKey is used to store the error handler in the request context.
type errorHandlerKey struct{}

// WithErrorHandler returns a RouterOption that sets an error handler.
// The handler is called when a server method returns an error.
// The error is NOT sent to the client - a generic message is returned instead.
func WithErrorHandler(handler ErrorHandler) RouterOption {
	return func(r chi.Router) {
		r.Use(func(next http.Handler) http.Handler {
			return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
				ctx := context.WithValue(req.Context(), errorHandlerKey{}, handler)
				next.ServeHTTP(w, req.WithContext(ctx))
			})
		})
	}
}

// getErrorHandler retrieves the error handler from the request context.
func getErrorHandler(req *http.Request) ErrorHandler {
	if handler, ok := req.Context().Value(errorHandlerKey{}).(ErrorHandler); ok {
		return handler
	}
	return nil
}

{{range .Operations}}
func handle{{.MethodName}}Chi(server ServerInterface, w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &{{.RequestType}}{
		HTTPRequest: req,
	}

{{range .PathParams}}
	// Extract path parameter: {{.Name}}
	{{- if eq .SchemaType "integer"}}
	if v, err := strconv.ParseInt(chi.URLParam(req, "{{.Name}}"), 10, 64); err == nil {
		srvReq.{{.FieldName}} = {{.GoType}}(v)
	}
	{{- else if eq .SchemaType "number"}}
	if v, err := strconv.ParseFloat(chi.URLParam(req, "{{.Name}}"), 64); err == nil {
		srvReq.{{.FieldName}} = {{.GoType}}(v)
	}
	{{- else if eq .SchemaType "boolean"}}
	if v, err := strconv.ParseBool(chi.URLParam(req, "{{.Name}}")); err == nil {
		srvReq.{{.FieldName}} = v
	}
	{{- else}}
	srvReq.{{.FieldName}} = chi.URLParam(req, "{{.Name}}")
	{{- end}}
{{end}}

	// Call the server implementation
	resp, err := server.{{.MethodName}}(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if handler := getErrorHandler(req); handler != nil {
			handler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface{ WriteTo(http.ResponseWriter) error }); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

{{end}}
