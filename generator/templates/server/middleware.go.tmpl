// Code generated by oastools. DO NOT EDIT.

package {{.Header.PackageName}}

import (
	"encoding/json"
	"net/http"

	"github.com/erraggy/oastools/httpvalidator"
	"github.com/erraggy/oastools/parser"
)

// ValidationMiddleware creates middleware that validates HTTP requests against the OpenAPI spec.
func ValidationMiddleware(parsed *parser.ParseResult) (func(http.Handler) http.Handler, error) {
	return ValidationMiddlewareWithConfig(parsed, DefaultValidationConfig())
}

// ValidationMiddlewareWithConfig creates validation middleware with custom configuration.
func ValidationMiddlewareWithConfig(parsed *parser.ParseResult, cfg ValidationConfig) (func(http.Handler) http.Handler, error) {
	v, err := httpvalidator.New(parsed)
	if err != nil {
		return nil, err
	}
	return validationMiddleware(v, cfg), nil
}

// ValidationConfig configures the validation middleware behavior.
type ValidationConfig struct {
	// IncludeRequestValidation enables request validation (default: true)
	IncludeRequestValidation bool

	// IncludeResponseValidation enables response validation (default: false)
	// Enable in development for debugging; disable in production for performance.
	IncludeResponseValidation bool

	// StrictMode treats warnings as errors (default: false)
	StrictMode bool

	// OnValidationError is called when validation fails.
	// If nil, a default JSON error response is written.
	OnValidationError func(w http.ResponseWriter, r *http.Request, result *httpvalidator.RequestValidationResult)
}

// DefaultValidationConfig returns the default validation configuration.
func DefaultValidationConfig() ValidationConfig {
	return ValidationConfig{
		IncludeRequestValidation:  true,
		IncludeResponseValidation: false,
		StrictMode:                false,
		OnValidationError:         nil,
	}
}

// validationMiddleware returns the actual middleware handler.
func validationMiddleware(v *httpvalidator.Validator, cfg ValidationConfig) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if cfg.IncludeRequestValidation {
				result, err := v.ValidateRequest(r)
				if err != nil {
					writeValidationErrorResponse(w, http.StatusInternalServerError, "validation error: "+err.Error())
					return
				}

				hasErrors := len(result.Errors) > 0
				hasWarnings := len(result.Warnings) > 0 && cfg.StrictMode

				if hasErrors || hasWarnings {
					if cfg.OnValidationError != nil {
						cfg.OnValidationError(w, r, result)
						return
					}
					writeValidationResult(w, result)
					return
				}
			}

			if cfg.IncludeResponseValidation {
				// Wrap the response writer to capture the response for validation
				rw := &responseRecorder{
					ResponseWriter: w,
					statusCode:     http.StatusOK,
				}
				next.ServeHTTP(rw, r)

				// Validate the response using ValidateResponseData
				result, err := v.ValidateResponseData(r, rw.statusCode, rw.Header(), rw.body)
				if err != nil {
					// Log response validation error but don't modify the response
					// since it's already been sent
					return
				}
				if !result.Valid {
					// In development mode, you might want to log this
					// The response has already been sent, so we can't modify it
					_ = result // silence unused warning; implement logging as needed
				}
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// responseRecorder captures response data for validation.
type responseRecorder struct {
	http.ResponseWriter
	statusCode int
	body       []byte
}

func (rw *responseRecorder) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseRecorder) Write(b []byte) (int, error) {
	rw.body = append(rw.body, b...)
	return rw.ResponseWriter.Write(b)
}

// ValidationErrorResponse is the structure returned for validation errors.
type ValidationErrorResponse struct {
	Error   string                          `json:"error"`
	Details []httpvalidator.ValidationError `json:"details,omitempty"`
}

// writeValidationResult writes the validation result as a JSON error response.
func writeValidationResult(w http.ResponseWriter, result *httpvalidator.RequestValidationResult) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)

	resp := ValidationErrorResponse{
		Error:   "request validation failed",
		Details: result.Errors,
	}
	_ = json.NewEncoder(w).Encode(resp)
}

// writeValidationErrorResponse writes a simple error response.
func writeValidationErrorResponse(w http.ResponseWriter, statusCode int, message string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	_ = json.NewEncoder(w).Encode(map[string]string{"error": message})
}
