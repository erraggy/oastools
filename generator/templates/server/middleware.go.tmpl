// Code generated by oastools. DO NOT EDIT.

package {{.Header.PackageName}}

import (
	"encoding/json"
	"net/http"

	"github.com/erraggy/oastools/httpvalidator"
	"github.com/erraggy/oastools/parser"
)

// ValidationMiddleware creates middleware that validates HTTP requests against the OpenAPI spec.
func ValidationMiddleware(parsed *parser.ParseResult) (func(http.Handler) http.Handler, error) {
	return ValidationMiddlewareWithConfig(parsed, DefaultValidationConfig())
}

// ValidationMiddlewareWithConfig creates validation middleware with custom configuration.
func ValidationMiddlewareWithConfig(parsed *parser.ParseResult, cfg ValidationConfig) (func(http.Handler) http.Handler, error) {
	v, err := httpvalidator.New(parsed)
	if err != nil {
		return nil, err
	}
	return validationMiddleware(v, cfg), nil
}

// ValidationConfig configures the validation middleware behavior.
type ValidationConfig struct {
	// IncludeRequestValidation enables request validation (default: true)
	IncludeRequestValidation bool

	// IncludeResponseValidation enables response validation (default: false)
	// Enable in development for debugging; disable in production for performance.
	IncludeResponseValidation bool

	// StrictMode treats warnings as errors (default: false)
	StrictMode bool

	// OnValidationError is called when validation fails.
	// If nil, a default JSON error response is written.
	OnValidationError func(w http.ResponseWriter, r *http.Request, result *httpvalidator.RequestValidationResult)
}

// DefaultValidationConfig returns the default validation configuration.
func DefaultValidationConfig() ValidationConfig {
	return ValidationConfig{
		IncludeRequestValidation:  true,
		IncludeResponseValidation: false,
		StrictMode:                false,
		OnValidationError:         nil,
	}
}

// validationMiddleware returns the actual middleware handler.
func validationMiddleware(v *httpvalidator.Validator, cfg ValidationConfig) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if cfg.IncludeRequestValidation {
				result, err := v.ValidateRequest(r)
				if err != nil {
					writeValidationErrorResponse(w, http.StatusInternalServerError, "validation error: "+err.Error())
					return
				}

				hasErrors := len(result.Errors) > 0
				hasWarnings := len(result.Warnings) > 0 && cfg.StrictMode

				if hasErrors || hasWarnings {
					if cfg.OnValidationError != nil {
						cfg.OnValidationError(w, r, result)
						return
					}
					writeValidationResult(w, result)
					return
				}
			}

			if cfg.IncludeResponseValidation {
				// Wrap the response writer to capture the response for validation
				rw := &responseRecorder{
					ResponseWriter: w,
					statusCode:     http.StatusOK,
				}
				next.ServeHTTP(rw, r)

				// Validate the response using ValidateResponseData.
				// NOTE: Response validation is intentionally performed AFTER the response
				// has been written to the client. This is a monitoring/logging feature for
				// development and testing - it cannot block or modify responses since they've
				// already been sent. For production use, consider:
				// 1. Using this for logging/alerting on response contract violations
				// 2. Implementing pre-serialization validation in your handlers
				// 3. Disabling response validation in production (IncludeResponseValidation=false)
				result, err := v.ValidateResponseData(r, rw.statusCode, rw.Header(), rw.body)
				if err != nil {
					// Validation infrastructure error - log and continue
					// Response already sent, cannot modify
					return
				}
				if !result.Valid && cfg.OnValidationError != nil {
					// Create a dummy response writer that discards writes since
					// the real response is already sent. This allows OnValidationError
					// to log the issue without affecting the client.
					// Wrap response errors in a RequestValidationResult for the callback.
					cfg.OnValidationError(&discardResponseWriter{}, r, &httpvalidator.RequestValidationResult{
						Errors: result.Errors,
					})
				}
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}

// responseRecorder captures response data for validation.
type responseRecorder struct {
	http.ResponseWriter
	statusCode int
	body       []byte
}

func (rw *responseRecorder) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseRecorder) Write(b []byte) (int, error) {
	rw.body = append(rw.body, b...)
	return rw.ResponseWriter.Write(b)
}

// discardResponseWriter is a no-op ResponseWriter used when logging response
// validation errors after the real response has already been sent.
type discardResponseWriter struct{}

func (discardResponseWriter) Header() http.Header         { return http.Header{} }
func (discardResponseWriter) Write([]byte) (int, error)   { return 0, nil }
func (discardResponseWriter) WriteHeader(int)             {}

// ValidationErrorResponse is the structure returned for validation errors.
type ValidationErrorResponse struct {
	Error   string                          `json:"error"`
	Details []httpvalidator.ValidationError `json:"details,omitempty"`
}

// writeValidationResult writes the validation result as a JSON error response.
func writeValidationResult(w http.ResponseWriter, result *httpvalidator.RequestValidationResult) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)

	resp := ValidationErrorResponse{
		Error:   "request validation failed",
		Details: result.Errors,
	}
	_ = json.NewEncoder(w).Encode(resp)
}

// writeValidationErrorResponse writes a simple error response.
func writeValidationErrorResponse(w http.ResponseWriter, statusCode int, message string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(statusCode)
	_ = json.NewEncoder(w).Encode(map[string]string{"error": message})
}
