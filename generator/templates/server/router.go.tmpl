// Code generated by oastools. DO NOT EDIT.

package {{.Header.PackageName}}

import (
	"context"
	"net/http"

	"github.com/erraggy/oastools/httpvalidator"
	"github.com/erraggy/oastools/parser"
)

// ServerRouter routes HTTP requests to ServerInterface handlers.
type ServerRouter struct {
	server       ServerInterface
	pathMatcher  *httpvalidator.PathMatcherSet
	middleware   []func(http.Handler) http.Handler
	errorHandler func(r *http.Request, err error) // called when handler returns error
}

// RouterOption configures the ServerRouter.
type RouterOption func(*ServerRouter) error

// NewServerRouter creates a new ServerRouter that dispatches requests to the server.
// The parsed OpenAPI specification is required for path matching.
func NewServerRouter(server ServerInterface, parsed *parser.ParseResult, opts ...RouterOption) (*ServerRouter, error) {
	// Extract path templates from the spec
	var paths []string
	if doc, ok := parsed.OAS3Document(); ok {
		for path := range doc.Paths {
			paths = append(paths, path)
		}
	} else if doc, ok := parsed.OAS2Document(); ok {
		for path := range doc.Paths {
			paths = append(paths, path)
		}
	}

	pathMatcher, err := httpvalidator.NewPathMatcherSet(paths)
	if err != nil {
		return nil, err
	}

	r := &ServerRouter{
		server:      server,
		pathMatcher: pathMatcher,
	}

	for _, opt := range opts {
		if err := opt(r); err != nil {
			return nil, err
		}
	}

	return r, nil
}

// WithMiddleware adds middleware to the router.
// Middleware is applied in order (first added = outermost).
func WithMiddleware(mw ...func(http.Handler) http.Handler) RouterOption {
	return func(r *ServerRouter) error {
		r.middleware = append(r.middleware, mw...)
		return nil
	}
}

// WithErrorHandler sets a callback for logging handler errors.
// The callback receives the request and error for logging purposes.
// The error is NOT sent to the client - a generic message is returned instead.
func WithErrorHandler(handler func(r *http.Request, err error)) RouterOption {
	return func(r *ServerRouter) error {
		r.errorHandler = handler
		return nil
	}
}

// Handler returns an http.Handler that routes requests.
func (r *ServerRouter) Handler() http.Handler {
	var handler http.Handler = http.HandlerFunc(r.serveHTTP)

	// Apply middleware in reverse order so first added is outermost
	for i := len(r.middleware) - 1; i >= 0; i-- {
		handler = r.middleware[i](handler)
	}

	return handler
}

// ServeHTTP implements http.Handler.
func (r *ServerRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	r.Handler().ServeHTTP(w, req)
}

// serveHTTP is the internal handler that performs routing.
func (r *ServerRouter) serveHTTP(w http.ResponseWriter, req *http.Request) {
	template, params, found := r.pathMatcher.Match(req.URL.Path)
	if !found {
		http.NotFound(w, req)
		return
	}

	// Store path params in request context for handler access
	ctx := req.Context()
	for k, v := range params {
		ctx = context.WithValue(ctx, pathParamKey(k), v)
	}
	req = req.WithContext(ctx)

	// Route to appropriate handler based on path and method
	r.routeRequest(w, req, template)
}

// pathParamKey is the context key type for path parameters.
type pathParamKey string

// PathParam retrieves a path parameter from the request context.
func PathParam(r *http.Request, name string) string {
	if v := r.Context().Value(pathParamKey(name)); v != nil {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

// routeRequest routes a matched request to the appropriate handler.
func (r *ServerRouter) routeRequest(w http.ResponseWriter, req *http.Request, template string) {
	switch template + ":" + req.Method {
{{range .Operations}}
	case "{{.Path}}:{{.Method}}":
		r.handle{{.MethodName}}(w, req)
{{end}}
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

{{range .Operations}}
func (r *ServerRouter) handle{{.MethodName}}(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &{{.RequestType}}{
		HTTPRequest: req,
	}

{{range .PathParams}}
	// Extract path parameter: {{.Name}}
	srvReq.{{.FieldName}} = PathParam(req, "{{.Name}}")
{{end}}

	// Call the server implementation
	resp, err := r.server.{{.MethodName}}(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface{ WriteTo(http.ResponseWriter) error }); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

{{end}}
