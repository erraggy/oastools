package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/erraggy/oastools/parser"
)

// OAuth2Generator generates OAuth2 token flow helpers.
type OAuth2Generator struct {
	// Name is the security scheme name (used for function naming).
	Name string

	// Flows contains the OAuth2 flow configurations.
	Flows *parser.OAuthFlows

	// OAS2Flow is the OAS 2.0 style flow type.
	OAS2Flow string

	// OAS2AuthURL is the OAS 2.0 style authorization URL.
	OAS2AuthURL string

	// OAS2TokenURL is the OAS 2.0 style token URL.
	OAS2TokenURL string

	// OAS2Scopes is the OAS 2.0 style scopes.
	OAS2Scopes map[string]string
}

// NewOAuth2Generator creates a new OAuth2Generator from a security scheme.
func NewOAuth2Generator(name string, scheme *parser.SecurityScheme) *OAuth2Generator {
	if scheme == nil || scheme.Type != "oauth2" {
		return nil
	}

	return &OAuth2Generator{
		Name:         name,
		Flows:        scheme.Flows,
		OAS2Flow:     scheme.Flow,
		OAS2AuthURL:  scheme.AuthorizationURL,
		OAS2TokenURL: scheme.TokenURL,
		OAS2Scopes:   scheme.Scopes,
	}
}

// GenerateOAuth2File generates a complete oauth2.go file with token management.
func (g *OAuth2Generator) GenerateOAuth2File(packageName string) string {
	var buf bytes.Buffer

	funcName := sanitizeSecurityFunctionName(g.Name)

	// Header
	buf.WriteString(fmt.Sprintf(`// Code generated by oastools. DO NOT EDIT.

package %s

import (
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"
)

`, packageName))

	// OAuth2 configuration
	buf.WriteString(g.generateOAuth2Config(funcName))

	// OAuth2 token
	buf.WriteString(g.generateOAuth2Token())

	// OAuth2 client
	buf.WriteString(g.generateOAuth2Client(funcName))

	// Generate flow-specific methods
	if g.hasAuthorizationCodeFlow() {
		buf.WriteString(g.generateAuthorizationCodeFlow(funcName))
		buf.WriteString(g.generatePKCEHelpers(funcName))
	}

	if g.hasClientCredentialsFlow() {
		buf.WriteString(g.generateClientCredentialsFlow(funcName))
	}

	if g.hasPasswordFlow() {
		buf.WriteString(g.generatePasswordFlow(funcName))
	}

	if g.hasImplicitFlow() {
		buf.WriteString(g.generateImplicitFlow(funcName))
	}

	// Token refresh
	buf.WriteString(g.generateTokenRefresh(funcName))

	// Auto-refresh option
	buf.WriteString(g.generateAutoRefreshOption(funcName))

	// Internal token request helper
	buf.WriteString(g.generateDoTokenRequest())

	return buf.String()
}

// generateOAuth2Config generates the OAuth2Config struct.
func (g *OAuth2Generator) generateOAuth2Config(funcName string) string {
	return fmt.Sprintf(`// %sOAuth2Config holds OAuth2 configuration.
type %sOAuth2Config struct {
	ClientID     string
	ClientSecret string
	RedirectURL  string
	Scopes       []string
}

`, funcName, funcName)
}

// generateOAuth2Token generates the OAuth2Token struct.
func (g *OAuth2Generator) generateOAuth2Token() string {
	return `// OAuth2Token represents an OAuth2 token response.
type OAuth2Token struct {
	AccessToken  string    ` + "`json:\"access_token\"`" + `
	TokenType    string    ` + "`json:\"token_type\"`" + `
	ExpiresIn    int       ` + "`json:\"expires_in\"`" + `
	RefreshToken string    ` + "`json:\"refresh_token,omitempty\"`" + `
	Scope        string    ` + "`json:\"scope,omitempty\"`" + `
	ExpiresAt    time.Time ` + "`json:\"-\"`" + `
}

// IsExpired returns true if the token is expired or will expire within the grace period.
func (t *OAuth2Token) IsExpired(grace time.Duration) bool {
	if t.ExpiresAt.IsZero() {
		return false
	}
	return time.Now().Add(grace).After(t.ExpiresAt)
}

`
}

// generateOAuth2Client generates the OAuth2Client struct and constructor.
func (g *OAuth2Generator) generateOAuth2Client(funcName string) string {
	authURL, tokenURL := g.getURLs()

	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf(`// %sOAuth2Client handles OAuth2 token operations.
type %sOAuth2Client struct {
	Config           %sOAuth2Config
	AuthorizationURL string
	TokenURL         string
	HTTPClient       *http.Client
}

`, funcName, funcName, funcName))

	buf.WriteString(fmt.Sprintf(`// New%sOAuth2Client creates a new OAuth2 client.
func New%sOAuth2Client(cfg %sOAuth2Config) *%sOAuth2Client {
	return &%sOAuth2Client{
		Config:           cfg,
		AuthorizationURL: %q,
		TokenURL:         %q,
		HTTPClient:       http.DefaultClient,
	}
}

`, funcName, funcName, funcName, funcName, funcName, authURL, tokenURL))

	return buf.String()
}

// generateAuthorizationCodeFlow generates authorization code flow methods.
func (g *OAuth2Generator) generateAuthorizationCodeFlow(funcName string) string {
	scopes := g.collectScopes()
	scopesComment := ""
	if len(scopes) > 0 {
		scopesComment = "// Available scopes: " + strings.Join(scopes, ", ") + "\n"
	}

	return fmt.Sprintf(`// GetAuthorizationURL returns the URL to redirect users for authorization.
%sfunc (c *%sOAuth2Client) GetAuthorizationURL(state string) string {
	params := url.Values{
		"client_id":     {c.Config.ClientID},
		"redirect_uri":  {c.Config.RedirectURL},
		"response_type": {"code"},
		"scope":         {strings.Join(c.Config.Scopes, " ")},
		"state":         {state},
	}
	return c.AuthorizationURL + "?" + params.Encode()
}

// ExchangeCode exchanges an authorization code for tokens.
func (c *%sOAuth2Client) ExchangeCode(ctx context.Context, code string) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"authorization_code"},
		"client_id":     {c.Config.ClientID},
		"client_secret": {c.Config.ClientSecret},
		"code":          {code},
		"redirect_uri":  {c.Config.RedirectURL},
	}
	return c.doTokenRequest(ctx, data)
}

`, scopesComment, funcName, funcName)
}

// generateClientCredentialsFlow generates client credentials flow methods.
func (g *OAuth2Generator) generateClientCredentialsFlow(funcName string) string {
	return fmt.Sprintf(`// GetClientCredentialsToken obtains a token using client credentials.
func (c *%sOAuth2Client) GetClientCredentialsToken(ctx context.Context) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"client_credentials"},
		"client_id":     {c.Config.ClientID},
		"client_secret": {c.Config.ClientSecret},
	}
	if len(c.Config.Scopes) > 0 {
		data.Set("scope", strings.Join(c.Config.Scopes, " "))
	}
	return c.doTokenRequest(ctx, data)
}

`, funcName)
}

// generatePasswordFlow generates password (resource owner) flow methods.
func (g *OAuth2Generator) generatePasswordFlow(funcName string) string {
	return fmt.Sprintf(`// GetPasswordToken obtains a token using resource owner password credentials.
// Note: This flow should only be used for trusted first-party applications.
func (c *%sOAuth2Client) GetPasswordToken(ctx context.Context, username, password string) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"password"},
		"client_id":     {c.Config.ClientID},
		"client_secret": {c.Config.ClientSecret},
		"username":      {username},
		"password":      {password},
	}
	if len(c.Config.Scopes) > 0 {
		data.Set("scope", strings.Join(c.Config.Scopes, " "))
	}
	return c.doTokenRequest(ctx, data)
}

`, funcName)
}

// generateImplicitFlow generates implicit flow methods (deprecated, but still supported).
func (g *OAuth2Generator) generateImplicitFlow(funcName string) string {
	return fmt.Sprintf(`// GetImplicitAuthorizationURL returns the URL for implicit flow authorization.
// Deprecated: The implicit flow is deprecated for security reasons.
// Consider using authorization code flow with PKCE instead.
func (c *%sOAuth2Client) GetImplicitAuthorizationURL(state string) string {
	params := url.Values{
		"client_id":     {c.Config.ClientID},
		"redirect_uri":  {c.Config.RedirectURL},
		"response_type": {"token"},
		"scope":         {strings.Join(c.Config.Scopes, " ")},
		"state":         {state},
	}
	return c.AuthorizationURL + "?" + params.Encode()
}

`, funcName)
}

// generateTokenRefresh generates the token refresh method.
func (g *OAuth2Generator) generateTokenRefresh(funcName string) string {
	return fmt.Sprintf(`// RefreshToken refreshes an access token using a refresh token.
func (c *%sOAuth2Client) RefreshToken(ctx context.Context, refreshToken string) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"refresh_token"},
		"client_id":     {c.Config.ClientID},
		"client_secret": {c.Config.ClientSecret},
		"refresh_token": {refreshToken},
	}
	return c.doTokenRequest(ctx, data)
}

`, funcName)
}

// generateAutoRefreshOption generates the auto-refresh client option.
func (g *OAuth2Generator) generateAutoRefreshOption(funcName string) string {
	return fmt.Sprintf(`// With%sOAuth2AutoRefresh configures automatic token refresh.
// The token will be refreshed when it expires or is within the grace period.
func With%sOAuth2AutoRefresh(oauth2Client *%sOAuth2Client, token *OAuth2Token, gracePeriod time.Duration) ClientOption {
	var mu sync.Mutex
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			mu.Lock()
			defer mu.Unlock()

			if token.IsExpired(gracePeriod) && token.RefreshToken != "" {
				newToken, err := oauth2Client.RefreshToken(ctx, token.RefreshToken)
				if err != nil {
					return fmt.Errorf("failed to refresh token: %%w", err)
				}
				*token = *newToken
			}

			req.Header.Set("Authorization", "Bearer "+token.AccessToken)
			return nil
		})
		return nil
	}
}

`, funcName, funcName, funcName)
}

// generateDoTokenRequest generates the internal token request helper.
func (g *OAuth2Generator) generateDoTokenRequest() string {
	// Use the first OAuth2 client name for the receiver type
	funcName := sanitizeSecurityFunctionName(g.Name)

	return fmt.Sprintf(`// doTokenRequest performs a token request and parses the response.
func (c *%sOAuth2Client) doTokenRequest(ctx context.Context, data url.Values) (*OAuth2Token, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.TokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("token request failed: %%s", resp.Status)
	}

	var token OAuth2Token
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, err
	}

	if token.ExpiresIn > 0 {
		token.ExpiresAt = time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)
	}

	return &token, nil
}
`, funcName)
}

// getURLs returns the authorization and token URLs.
func (g *OAuth2Generator) getURLs() (authURL, tokenURL string) {
	// OAS 3.0+ style
	if g.Flows != nil {
		if g.Flows.AuthorizationCode != nil {
			authURL = g.Flows.AuthorizationCode.AuthorizationURL
			tokenURL = g.Flows.AuthorizationCode.TokenURL
		} else if g.Flows.Implicit != nil {
			authURL = g.Flows.Implicit.AuthorizationURL
		} else if g.Flows.ClientCredentials != nil {
			tokenURL = g.Flows.ClientCredentials.TokenURL
		} else if g.Flows.Password != nil {
			tokenURL = g.Flows.Password.TokenURL
		}
	}

	// OAS 2.0 style fallback
	if authURL == "" {
		authURL = g.OAS2AuthURL
	}
	if tokenURL == "" {
		tokenURL = g.OAS2TokenURL
	}

	return authURL, tokenURL
}

// collectScopes collects all unique scopes from the OAuth2 configuration.
func (g *OAuth2Generator) collectScopes() []string {
	scopeSet := make(map[string]bool)

	// OAS 2.0 style
	for scope := range g.OAS2Scopes {
		scopeSet[scope] = true
	}

	// OAS 3.0+ style
	if g.Flows != nil {
		if g.Flows.Implicit != nil {
			for scope := range g.Flows.Implicit.Scopes {
				scopeSet[scope] = true
			}
		}
		if g.Flows.Password != nil {
			for scope := range g.Flows.Password.Scopes {
				scopeSet[scope] = true
			}
		}
		if g.Flows.ClientCredentials != nil {
			for scope := range g.Flows.ClientCredentials.Scopes {
				scopeSet[scope] = true
			}
		}
		if g.Flows.AuthorizationCode != nil {
			for scope := range g.Flows.AuthorizationCode.Scopes {
				scopeSet[scope] = true
			}
		}
	}

	scopes := make([]string, 0, len(scopeSet))
	for scope := range scopeSet {
		scopes = append(scopes, scope)
	}
	sort.Strings(scopes)
	return scopes
}

// Flow detection methods

func (g *OAuth2Generator) hasAuthorizationCodeFlow() bool {
	if g.Flows != nil && g.Flows.AuthorizationCode != nil {
		return true
	}
	return g.OAS2Flow == "accessCode" || g.OAS2Flow == "authorizationCode"
}

func (g *OAuth2Generator) hasClientCredentialsFlow() bool {
	if g.Flows != nil && g.Flows.ClientCredentials != nil {
		return true
	}
	return g.OAS2Flow == "application" || g.OAS2Flow == "clientCredentials"
}

func (g *OAuth2Generator) hasPasswordFlow() bool {
	if g.Flows != nil && g.Flows.Password != nil {
		return true
	}
	return g.OAS2Flow == "password"
}

func (g *OAuth2Generator) hasImplicitFlow() bool {
	if g.Flows != nil && g.Flows.Implicit != nil {
		return true
	}
	return g.OAS2Flow == "implicit"
}

// HasAnyFlow returns true if any OAuth2 flow is configured.
func (g *OAuth2Generator) HasAnyFlow() bool {
	return g.hasAuthorizationCodeFlow() || g.hasClientCredentialsFlow() ||
		g.hasPasswordFlow() || g.hasImplicitFlow()
}

// generatePKCEHelpers generates PKCE (Proof Key for Code Exchange) helper functions.
// PKCE is recommended for all OAuth2 authorization code flows and required for public clients.
func (g *OAuth2Generator) generatePKCEHelpers(funcName string) string {
	return fmt.Sprintf(`// PKCEChallenge contains the code verifier and challenge for PKCE.
type PKCEChallenge struct {
	// CodeVerifier is the random secret used to generate the challenge.
	// Must be kept secret and sent in the token exchange request.
	CodeVerifier string

	// CodeChallenge is the S256 hash of the CodeVerifier.
	// Sent in the authorization request.
	CodeChallenge string

	// CodeChallengeMethod is the hash method used (always "S256").
	CodeChallengeMethod string
}

// GeneratePKCEChallenge creates a new PKCE code verifier and challenge.
// Uses S256 (SHA-256) as the challenge method per RFC 7636.
func GeneratePKCEChallenge() (*PKCEChallenge, error) {
	// Generate a cryptographically random 32-byte verifier
	verifierBytes := make([]byte, 32)
	if _, err := rand.Read(verifierBytes); err != nil {
		return nil, fmt.Errorf("failed to generate random bytes: %%w", err)
	}

	// Encode to base64url without padding (per RFC 7636)
	verifier := base64.RawURLEncoding.EncodeToString(verifierBytes)

	// Generate S256 challenge: BASE64URL(SHA256(verifier))
	hash := sha256.Sum256([]byte(verifier))
	challenge := base64.RawURLEncoding.EncodeToString(hash[:])

	return &PKCEChallenge{
		CodeVerifier:        verifier,
		CodeChallenge:       challenge,
		CodeChallengeMethod: "S256",
	}, nil
}

// GetAuthorizationURLWithPKCE returns the authorization URL with PKCE parameters.
// This is the recommended method for all authorization code flows.
func (c *%sOAuth2Client) GetAuthorizationURLWithPKCE(state string, pkce *PKCEChallenge) string {
	params := url.Values{
		"client_id":             {c.Config.ClientID},
		"redirect_uri":          {c.Config.RedirectURL},
		"response_type":         {"code"},
		"scope":                 {strings.Join(c.Config.Scopes, " ")},
		"state":                 {state},
		"code_challenge":        {pkce.CodeChallenge},
		"code_challenge_method": {pkce.CodeChallengeMethod},
	}
	return c.AuthorizationURL + "?" + params.Encode()
}

// ExchangeCodeWithPKCE exchanges an authorization code for tokens using PKCE.
// The codeVerifier must match the one used to generate the challenge.
func (c *%sOAuth2Client) ExchangeCodeWithPKCE(ctx context.Context, code string, codeVerifier string) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"authorization_code"},
		"client_id":     {c.Config.ClientID},
		"code":          {code},
		"redirect_uri":  {c.Config.RedirectURL},
		"code_verifier": {codeVerifier},
	}
	// Note: client_secret is optional when using PKCE for public clients
	if c.Config.ClientSecret != "" {
		data.Set("client_secret", c.Config.ClientSecret)
	}
	return c.doTokenRequest(ctx, data)
}

`, funcName, funcName)
}
