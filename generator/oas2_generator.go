package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/erraggy/oastools/internal/httputil"
	"github.com/erraggy/oastools/parser"
)

// oas2CodeGenerator handles code generation for OAS 2.0 documents
type oas2CodeGenerator struct {
	baseCodeGenerator
	doc *parser.OAS2Document
}

func newOAS2CodeGenerator(g *Generator, doc *parser.OAS2Document, result *GenerateResult) *oas2CodeGenerator {
	cg := &oas2CodeGenerator{
		doc: doc,
	}
	cg.initBase(g, result)

	// Analyze document for file splitting
	splitter := &FileSplitter{
		MaxLinesPerFile:      g.MaxLinesPerFile,
		MaxTypesPerFile:      g.MaxTypesPerFile,
		MaxOperationsPerFile: g.MaxOperationsPerFile,
		SplitByTag:           g.SplitByTag,
		SplitByPathPrefix:    g.SplitByPathPrefix,
	}
	cg.splitPlan = splitter.AnalyzeOAS2(doc)

	return cg
}

// generateTypes generates type definitions from schemas
func (cg *oas2CodeGenerator) generateTypes() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitTypes()
	}

	return cg.generateSingleTypes()
}

// collectSchemas extracts all schemas from definitions and populates schemaNames mapping.
// Returns a sorted slice of schema entries for deterministic output.
// Duplicate type names (e.g., "user_profile" and "UserProfile" both becoming "UserProfile")
// are detected and skipped with a warning.
func (cg *oas2CodeGenerator) collectSchemas() []oas2SchemaEntry {
	var schemas []oas2SchemaEntry
	if cg.doc.Definitions != nil {
		for name, schema := range cg.doc.Definitions {
			if schema == nil {
				continue
			}
			// Check for duplicate type names (e.g., "user_profile" and "UserProfile" both become "UserProfile")
			typeName := toTypeName(name)
			if cg.generatedTypes[typeName] {
				cg.addIssue(fmt.Sprintf("definitions.%s", name),
					fmt.Sprintf("duplicate type name %s - skipping", typeName), SeverityWarning)
				continue
			}
			cg.generatedTypes[typeName] = true

			schemas = append(schemas, oas2SchemaEntry{name: name, schema: schema})
			cg.schemaNames["#/definitions/"+name] = typeName
		}
	}

	// Sort schemas for deterministic output
	sort.Slice(schemas, func(i, j int) bool {
		return schemas[i].name < schemas[j].name
	})

	return schemas
}

// generateSingleTypes generates all types in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleTypes() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Collect imports
	imports := make(map[string]bool)

	// Process schemas from definitions
	schemas := cg.collectSchemas()

	// Check for time imports
	for _, entry := range schemas {
		if needsTimeImport(entry.schema) {
			imports["time"] = true
			break
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		var importList []string
		for imp := range imports {
			importList = append(importList, imp)
		}
		sort.Strings(importList)
		for _, imp := range importList {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate each schema
	for _, entry := range schemas {
		code, err := cg.generateSchemaType(entry.name, entry.schema)
		if err != nil {
			cg.addIssue("definitions."+entry.name, fmt.Sprintf("failed to generate type: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		buf.WriteString("\n")
		cg.result.GeneratedTypes++
	}

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue("types.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "types.go",
		Content: formatted,
	})

	return nil
}

// generateSplitTypes generates types split across multiple files
func (cg *oas2CodeGenerator) generateSplitTypes() error {
	// Build set of shared types
	sharedTypes := make(map[string]bool)
	for _, typeName := range cg.splitPlan.SharedTypes {
		sharedTypes[typeName] = true
	}

	// Build set of types per group
	groupTypes := make(map[string]map[string]bool)
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue
		}
		groupTypes[group.Name] = make(map[string]bool)
		for _, typeName := range group.Types {
			groupTypes[group.Name][typeName] = true
		}
	}

	// Get all schemas
	allSchemas := cg.collectSchemas()

	// Generate shared types file (types.go)
	if err := cg.generateOAS2TypesFile("types.go", "Shared types used across multiple operations", allSchemas, sharedTypes); err != nil {
		return err
	}

	// Generate per-group type files
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue
		}

		types := groupTypes[group.Name]
		if len(types) == 0 {
			continue
		}

		fileName := fmt.Sprintf("types_%s.go", group.Name)
		comment := fmt.Sprintf("%s types", group.DisplayName)
		if err := cg.generateOAS2TypesFile(fileName, comment, allSchemas, types); err != nil {
			cg.addIssue(fileName, fmt.Sprintf("failed to generate: %v", err), SeverityWarning)
		}
	}

	return nil
}

// generateOAS2TypesFile generates a types file with only the specified types
func (cg *oas2CodeGenerator) generateOAS2TypesFile(fileName, comment string, allSchemas []oas2SchemaEntry, includeTypes map[string]bool) error {
	// Build filtered types list
	var filteredSchemas []oas2SchemaEntry
	for _, entry := range allSchemas {
		typeName := toTypeName(entry.name)
		if includeTypes[typeName] || includeTypes[entry.name] {
			filteredSchemas = append(filteredSchemas, entry)
		}
	}

	if len(filteredSchemas) == 0 {
		return nil // Skip empty files
	}

	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n")
	if comment != "" {
		buf.WriteString(fmt.Sprintf("// %s\n", comment))
	}
	buf.WriteString("\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Collect imports
	imports := make(map[string]bool)
	for _, entry := range filteredSchemas {
		if needsTimeImport(entry.schema) {
			imports["time"] = true
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range imports {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate type definitions
	for _, entry := range filteredSchemas {
		code, err := cg.generateSchemaType(entry.name, entry.schema)
		if err != nil {
			cg.addIssue(fmt.Sprintf("definitions.%s", entry.name), fmt.Sprintf("failed to generate type: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		cg.result.GeneratedTypes++
	}

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue(fileName, fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    fileName,
		Content: formatted,
	})

	return nil
}

// oas2SchemaEntry holds a schema name and its definition
type oas2SchemaEntry struct {
	name   string
	schema *parser.Schema
}

// generateSchemaType generates Go code for a schema type
func (cg *oas2CodeGenerator) generateSchemaType(name string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	typeName := toTypeName(name)

	// Handle $ref
	if schema.Ref != "" {
		refType := cg.resolveRef(schema.Ref)
		buf.WriteString(fmt.Sprintf("// %s is an alias for %s.\n", typeName, refType))
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, refType))
		return buf.String(), nil
	}

	// Write documentation
	if schema.Description != "" {
		buf.WriteString(fmt.Sprintf("// %s %s\n", typeName, cleanDescription(schema.Description)))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents the %s schema.\n", typeName, name))
	}

	// Determine schema type
	schemaType := getSchemaType(schema)

	switch schemaType {
	case "object":
		// Generate struct
		buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		if schema.Properties != nil {
			// Sort properties for deterministic output
			var propNames []string
			for propName := range schema.Properties {
				propNames = append(propNames, propName)
			}
			sort.Strings(propNames)

			for _, propName := range propNames {
				propSchema := schema.Properties[propName]
				if propSchema == nil {
					continue
				}

				goType := cg.schemaToGoType(propSchema, isRequired(schema.Required, propName))

				// Check for self-reference (recursive type) - needs pointer indirection
				// e.g., type UserGroup struct { Children UserGroup } is invalid, needs *UserGroup
				if isSelfReference(propSchema, typeName) &&
					!strings.HasPrefix(goType, "*") &&
					!strings.HasPrefix(goType, "[]") {
					goType = "*" + goType
				}

				fieldName := toFieldName(propName)
				jsonTag := propName
				if !isRequired(schema.Required, propName) {
					jsonTag += ",omitempty"
				}

				// Add field comment
				if propSchema.Description != "" {
					buf.WriteString(fmt.Sprintf("\t// %s\n", cleanDescription(propSchema.Description)))
				}

				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, jsonTag))
			}
		}
		buf.WriteString("}\n")

	case "array":
		// Generate type alias for array
		itemType := cg.getArrayItemType(schema)
		buf.WriteString(fmt.Sprintf("type %s []%s\n", typeName, itemType))

	case "string":
		// Check for enum
		if len(schema.Enum) > 0 {
			buf.WriteString(fmt.Sprintf("type %s string\n\n", typeName))
			buf.WriteString("const (\n")
			for _, e := range schema.Enum {
				enumVal := fmt.Sprintf("%v", e)
				enumName := typeName + toFieldName(enumVal)
				buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", enumName, typeName, enumVal))
			}
			buf.WriteString(")\n")
		} else {
			goType := stringFormatToGoType(schema.Format)
			buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))
		}

	case "integer":
		goType := integerFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "number":
		goType := numberFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "boolean":
		buf.WriteString(fmt.Sprintf("type %s = bool\n", typeName))

	default:
		// Handle allOf
		if len(schema.AllOf) > 0 {
			return cg.generateAllOfType(typeName, schema)
		}
		// Default to any
		buf.WriteString(fmt.Sprintf("type %s = any\n", typeName))
	}

	return buf.String(), nil
}

// generateAllOfType generates a type for allOf composition
func (cg *oas2CodeGenerator) generateAllOfType(typeName string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("// %s combines multiple schemas.\n", typeName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	for _, subSchema := range schema.AllOf {
		if subSchema.Ref != "" {
			refType := cg.resolveRef(subSchema.Ref)
			buf.WriteString(fmt.Sprintf("\t%s\n", refType))
		} else if subSchema.Properties != nil {
			// Inline properties
			var propNames []string
			for propName := range subSchema.Properties {
				propNames = append(propNames, propName)
			}
			sort.Strings(propNames)

			for _, propName := range propNames {
				propSchema := subSchema.Properties[propName]
				if propSchema == nil {
					continue
				}
				goType := cg.schemaToGoType(propSchema, isRequired(subSchema.Required, propName))

				// Check for self-reference (recursive type) - needs pointer indirection
				if isSelfReference(propSchema, typeName) &&
					!strings.HasPrefix(goType, "*") &&
					!strings.HasPrefix(goType, "[]") {
					goType = "*" + goType
				}

				fieldName := toFieldName(propName)
				jsonTag := propName
				if !isRequired(subSchema.Required, propName) {
					jsonTag += ",omitempty"
				}
				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, jsonTag))
			}
		}
	}

	buf.WriteString("}\n")
	return buf.String(), nil
}

// schemaToGoType converts a schema to a Go type string
func (cg *oas2CodeGenerator) schemaToGoType(schema *parser.Schema, required bool) string {
	// OAS 2.0 doesn't have nullable, so isNullable is always false
	return cg.schemaToGoTypeBase(schema, required, false, cg.schemaToGoType)
}

// getArrayItemType extracts the Go type for array items, handling $ref properly
func (cg *oas2CodeGenerator) getArrayItemType(schema *parser.Schema) string {
	return cg.baseCodeGenerator.getArrayItemType(schema, cg.schemaToGoType)
}

// generateClient generates HTTP client code for OAS 2.0
func (cg *oas2CodeGenerator) generateClient() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitClient()
	}

	return cg.generateSingleClient()
}

// generateSingleClient generates all client code in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleClient() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Write client struct, types, constructor, and options using shared boilerplate
	writeClientBoilerplate(&buf, cg.doc.Info)

	// Generate methods for each operation
	if cg.doc.Paths != nil {
		// Sort paths for deterministic output
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				code, err := cg.generateClientMethod(path, method, op)
				if err != nil {
					cg.addIssue(fmt.Sprintf("paths.%s.%s", path, method), fmt.Sprintf("failed to generate client method: %v", err), SeverityWarning)
					continue
				}
				buf.WriteString(code)
				cg.result.GeneratedOperations++
			}
		}
	}

	// Write helper functions
	buf.WriteString(clientHelpers)

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue("client.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "client.go",
		Content: formatted,
	})

	return nil
}

// generateSplitClient generates client code split across multiple files
func (cg *oas2CodeGenerator) generateSplitClient() error {
	// Generate the base client.go (struct, constructor, options, helpers - no operations)
	if err := cg.generateOAS2BaseClient(); err != nil {
		return err
	}

	// Build a map of operation ID to path/method for quick lookup
	opToPathMethod := make(map[string]struct {
		path   string
		method string
		op     *parser.Operation
	})

	if cg.doc.Paths != nil {
		for path, pathItem := range cg.doc.Paths {
			if pathItem == nil {
				continue
			}
			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}
				opID := operationToMethodName(op, path, method)
				opToPathMethod[opID] = struct {
					path   string
					method string
					op     *parser.Operation
				}{path, method, op}
			}
		}
	}

	// Generate a client file for each group
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue // Skip shared types group
		}

		if err := cg.generateOAS2ClientGroupFile(group, opToPathMethod); err != nil {
			cg.addIssue(fmt.Sprintf("client_%s.go", group.Name), fmt.Sprintf("failed to generate: %v", err), SeverityWarning)
		}
	}

	return nil
}

// generateOAS2BaseClient generates the base client.go with struct, constructor, and options (no operations)
func (cg *oas2CodeGenerator) generateOAS2BaseClient() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports (base client needs these imports for clientHelpers)
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Write client struct, types, constructor, and options using shared boilerplate
	writeClientBoilerplate(&buf, cg.doc.Info)

	// Write helper functions
	buf.WriteString(clientHelpers)

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue("client.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "client.go",
		Content: formatted,
	})

	return nil
}

// generateOAS2ClientGroupFile generates a client_{group}.go file with operations for a specific group
//
//nolint:unparam // error return kept for API consistency with other generate methods
func (cg *oas2CodeGenerator) generateOAS2ClientGroupFile(group FileGroup, opToPathMethod map[string]struct {
	path   string
	method string
	op     *parser.Operation
}) error {
	var buf bytes.Buffer

	// Write header with comment about the group
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// This file contains %s operations.\n\n", group.DisplayName))
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports (full set needed for operations)
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Generate each operation in this group
	for _, opID := range group.Operations {
		info, ok := opToPathMethod[opID]
		if !ok {
			continue
		}

		code, err := cg.generateClientMethod(info.path, info.method, info.op)
		if err != nil {
			cg.addIssue(fmt.Sprintf("paths.%s.%s", info.path, info.method), fmt.Sprintf("failed to generate client method: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		cg.result.GeneratedOperations++
	}

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue(fmt.Sprintf("client_%s.go", group.Name), fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    fmt.Sprintf("client_%s.go", group.Name),
		Content: formatted,
	})

	return nil
}

// generateClientMethod generates a client method for an operation
//
//nolint:unparam // error return kept for API consistency with interface requirements
func (cg *oas2CodeGenerator) generateClientMethod(path, method string, op *parser.Operation) (string, error) {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)

	// Build parameter list
	var params []string
	params = append(params, "ctx context.Context")

	// Process all parameters in a single pass
	var pathParams []pathParam
	var queryParams []*parser.Parameter
	var hasBody bool
	var bodyParamSchema *parser.Schema
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}
		switch param.In {
		case parser.ParamInPath:
			goType := cg.paramToGoType(param)
			paramName := toParamName(param.Name)
			params = append(params, fmt.Sprintf("%s %s", paramName, goType))
			pathParams = append(pathParams, pathParam{name: param.Name, varName: paramName})
		case parser.ParamInQuery:
			queryParams = append(queryParams, param)
		case parser.ParamInBody:
			if !hasBody { // Only use the first body param
				hasBody = true
				bodyParamSchema = param.Schema
			}
		}
	}
	if len(queryParams) > 0 {
		params = append(params, "params *"+methodName+"Params")
	}
	if hasBody {
		bodyType := "any"
		if bodyParamSchema != nil {
			bodyType = cg.schemaToGoType(bodyParamSchema, true)
		}
		params = append(params, "body "+bodyType)
	}

	// Write method documentation - handle multiline descriptions properly
	if op.Summary != "" {
		buf.WriteString(formatMultilineComment(op.Summary, methodName, ""))
	} else if op.Description != "" {
		buf.WriteString(formatMultilineComment(op.Description, methodName, ""))
	} else {
		buf.WriteString(fmt.Sprintf("// %s calls %s %s\n", methodName, strings.ToUpper(method), path))
	}
	if op.Deprecated {
		buf.WriteString("// Deprecated: This operation is deprecated.\n")
	}

	// Write method signature
	responseType := cg.getResponseType(op)
	buf.WriteString(fmt.Sprintf("func (c *Client) %s(%s) (%s, error) {\n", methodName, strings.Join(params, ", "), responseType))

	// Build URL
	buf.WriteString("\tpath := ")
	if len(pathParams) > 0 {
		buf.WriteString("fmt.Sprintf(\"")
		pathTemplate := path
		for _, pp := range pathParams {
			pathTemplate = strings.ReplaceAll(pathTemplate, "{"+pp.name+"}", "%v")
		}
		buf.WriteString(pathTemplate)
		buf.WriteString("\"")
		for _, pp := range pathParams {
			buf.WriteString(", " + pp.varName)
		}
		buf.WriteString(")\n")
	} else {
		buf.WriteString(fmt.Sprintf("%q\n", path))
	}

	// Build query string
	if len(queryParams) > 0 {
		buf.WriteString("\tquery := make(url.Values)\n")
		buf.WriteString("\tif params != nil {\n")
		for _, param := range queryParams {
			paramName := toFieldName(param.Name)
			if param.Required {
				buf.WriteString(fmt.Sprintf("\t\tquery.Set(%q, fmt.Sprintf(\"%%v\", params.%s))\n", param.Name, paramName))
			} else {
				buf.WriteString(fmt.Sprintf("\t\tif params.%s != nil {\n", paramName))
				buf.WriteString(fmt.Sprintf("\t\t\tquery.Set(%q, fmt.Sprintf(\"%%v\", *params.%s))\n", param.Name, paramName))
				buf.WriteString("\t\t}\n")
			}
		}
		buf.WriteString("\t}\n")
		buf.WriteString("\tif len(query) > 0 {\n")
		buf.WriteString("\t\tpath += \"?\" + query.Encode()\n")
		buf.WriteString("\t}\n")
	}

	// Create request
	if hasBody {
		buf.WriteString("\tbodyData, err := json.Marshal(body)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"marshal request body: %%w\", err)\n", zeroValue(responseType)))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, %q, c.BaseURL+path, bytes.NewReader(bodyData))\n", strings.ToUpper(method)))
	} else {
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, %q, c.BaseURL+path, nil)\n", strings.ToUpper(method)))
	}
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"create request: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")

	// Set content type
	if hasBody {
		buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}
	buf.WriteString("\treq.Header.Set(\"Accept\", \"application/json\")\n")
	buf.WriteString("\tif c.UserAgent != \"\" {\n")
	buf.WriteString("\t\treq.Header.Set(\"User-Agent\", c.UserAgent)\n")
	buf.WriteString("\t}\n")

	// Apply request editors
	buf.WriteString("\tfor _, editor := range c.RequestEditors {\n")
	buf.WriteString("\t\tif err := editor(ctx, req); err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\t\treturn %s, fmt.Errorf(\"request editor: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")

	// Execute request
	buf.WriteString("\tresp, err := c.HTTPClient.Do(req)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"execute request: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer resp.Body.Close()\n")

	// Handle response
	buf.WriteString("\tif resp.StatusCode >= 400 {\n")
	buf.WriteString("\t\tbody, _ := io.ReadAll(resp.Body)\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, &APIError{StatusCode: resp.StatusCode, Body: body}\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")

	// Parse response body
	if responseType != "" && responseType != httpResponseType {
		if strings.HasPrefix(responseType, "*") {
			buf.WriteString(fmt.Sprintf("\tvar result %s\n", responseType[1:]))
			buf.WriteString("\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"decode response: %%w\", err)\n", zeroValue(responseType)))
			buf.WriteString("\t}\n")
			buf.WriteString("\treturn &result, nil\n")
		} else {
			buf.WriteString(fmt.Sprintf("\tvar result %s\n", responseType))
			buf.WriteString("\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"decode response: %%w\", err)\n", zeroValue(responseType)))
			buf.WriteString("\t}\n")
			buf.WriteString("\treturn result, nil\n")
		}
	} else {
		buf.WriteString("\treturn resp, nil\n")
	}

	buf.WriteString("}\n\n")

	// Generate params struct if needed
	if len(queryParams) > 0 {
		buf.WriteString(fmt.Sprintf("// %sParams contains query parameters for %s.\n", methodName, methodName))
		buf.WriteString(fmt.Sprintf("type %sParams struct {\n", methodName))
		for _, param := range queryParams {
			goType := cg.paramToGoType(param)
			fieldName := toFieldName(param.Name)
			if param.Description != "" {
				buf.WriteString(fmt.Sprintf("\t// %s\n", cleanDescription(param.Description)))
			}
			if !param.Required {
				buf.WriteString(fmt.Sprintf("\t%s *%s `json:%q`\n", fieldName, goType, param.Name+",omitempty"))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, param.Name))
			}
		}
		buf.WriteString("}\n\n")
	}

	return buf.String(), nil
}

// paramToGoType converts a parameter to its Go type
func (cg *oas2CodeGenerator) paramToGoType(param *parser.Parameter) string {
	// OAS 2.0 uses type directly on parameter
	switch param.Type {
	case "string":
		return stringFormatToGoType(param.Format)
	case "integer":
		return integerFormatToGoType(param.Format)
	case "number":
		return numberFormatToGoType(param.Format)
	case "boolean":
		return "bool"
	case "array":
		return "[]string"
	default:
		return "string"
	}
}

// getResponseType determines the Go type for the success response
func (cg *oas2CodeGenerator) getResponseType(op *parser.Operation) string {
	if op.Responses == nil {
		return httpResponseType
	}

	// Check for 200, 201 responses
	for _, code := range []string{"200", "201"} {
		if resp := op.Responses.Codes[code]; resp != nil {
			// OAS 2.0 uses schema directly on response
			if resp.Schema != nil {
				goType := cg.schemaToGoType(resp.Schema, true)
				if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
					return "*" + goType
				}
				return goType
			}
		}
	}

	// Check default response
	if op.Responses.Default != nil && op.Responses.Default.Schema != nil {
		goType := cg.schemaToGoType(op.Responses.Default.Schema, true)
		if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
			return "*" + goType
		}
		return goType
	}

	return httpResponseType
}

// generateServer generates server interface code for OAS 2.0
func (cg *oas2CodeGenerator) generateServer() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitServer()
	}

	return cg.generateSingleServer()
}

// generateSingleServer generates all server code in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleServer() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString(")\n\n")

	// Track generated methods to avoid duplicates (can happen with duplicate operationIds).
	// NOTE: This map must be local per file generation to avoid stale data in split mode.
	generatedMethods := make(map[string]bool)

	// Generate server interface
	buf.WriteString("// ServerInterface represents the server API.\n")
	buf.WriteString("type ServerInterface interface {\n")

	if cg.doc.Paths != nil {
		// Sort paths for deterministic output
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				methodName := operationToMethodName(op, path, method)
				if generatedMethods[methodName] {
					cg.addIssue(fmt.Sprintf("paths.%s.%s", path, method),
						fmt.Sprintf("duplicate method name %s - skipping", methodName), SeverityWarning)
					continue
				}
				generatedMethods[methodName] = true

				sig := cg.generateServerMethodSignature(path, method, op)
				buf.WriteString(sig)
			}
		}
	}

	buf.WriteString("}\n\n")

	// Generate request types (use same tracking map since request types are named after methods)
	for _, path := range func() []string {
		var keys []string
		if cg.doc.Paths != nil {
			for k := range cg.doc.Paths {
				keys = append(keys, k)
			}
		}
		sort.Strings(keys)
		return keys
	}() {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range httpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			// Skip if method was not added to interface (was filtered as duplicate)
			if !generatedMethods[methodName] {
				continue
			}

			reqType := cg.generateRequestType(path, method, op)
			if reqType != "" {
				buf.WriteString(reqType)
			}
		}
	}

	// Write unimplemented server
	buf.WriteString("// UnimplementedServer provides default implementations that return errors.\n")
	buf.WriteString("type UnimplementedServer struct{}\n\n")

	// Track generated UnimplementedServer methods separately to avoid duplicates.
	// We can't reuse generatedMethods because it's used to check if a method was
	// added to the interface (i.e., wasn't filtered as duplicate).
	generatedUnimplemented := make(map[string]bool)

	// Generate unimplemented methods (methods already tracked from interface generation)
	if cg.doc.Paths != nil {
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				methodName := operationToMethodName(op, path, method)
				// Skip if not in generated methods (was a duplicate in interface)
				if !generatedMethods[methodName] {
					continue
				}
				// Skip if already generated for UnimplementedServer
				if generatedUnimplemented[methodName] {
					continue
				}
				generatedUnimplemented[methodName] = true

				responseType := cg.getResponseType(op)

				buf.WriteString(fmt.Sprintf("func (s *UnimplementedServer) %s(ctx context.Context, req *%sRequest) (%s, error) {\n",
					methodName, methodName, responseType))
				buf.WriteString(fmt.Sprintf("\treturn %s, ErrNotImplemented\n", zeroValue(responseType)))
				buf.WriteString("}\n\n")
			}
		}
	}

	// Write error type
	buf.WriteString("// ErrNotImplemented is returned by UnimplementedServer methods.\n")
	buf.WriteString("var ErrNotImplemented = &NotImplementedError{}\n\n")
	buf.WriteString("// NotImplementedError indicates an operation is not implemented.\n")
	buf.WriteString("type NotImplementedError struct{}\n\n")
	buf.WriteString("func (e *NotImplementedError) Error() string { return \"not implemented\" }\n\n")

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue("server.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server.go",
		Content: formatted,
	})

	return nil
}

// generateSplitServer generates server code split across multiple files
func (cg *oas2CodeGenerator) generateSplitServer() error {
	// Generate the base server.go (interface, unimplemented, error types)
	// Returns the set of methods that were actually generated (excludes duplicates)
	generatedMethods, err := cg.generateOAS2BaseServer()
	if err != nil {
		return err
	}

	// Build a map of operation ID to path/method for quick lookup
	opToPathMethod := make(map[string]struct {
		path   string
		method string
		op     *parser.Operation
	})

	if cg.doc.Paths != nil {
		for path, pathItem := range cg.doc.Paths {
			if pathItem == nil {
				continue
			}
			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}
				opID := operationToMethodName(op, path, method)
				opToPathMethod[opID] = struct {
					path   string
					method string
					op     *parser.Operation
				}{path, method, op}
			}
		}
	}

	// Generate a server file for each group (request types only)
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue // Skip shared types group
		}

		if err := cg.generateOAS2ServerGroupFile(group, opToPathMethod, generatedMethods); err != nil {
			cg.addIssue(fmt.Sprintf("server_%s.go", group.Name), fmt.Sprintf("failed to generate: %v", err), SeverityWarning)
		}
	}

	return nil
}

// generateOAS2BaseServer generates the base server.go with interface and unimplemented struct.
// Returns a map of generated method names (to exclude duplicates from request type generation).
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateOAS2BaseServer() (map[string]bool, error) {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString(")\n\n")

	// Track generated methods to avoid duplicates (can happen with duplicate operationIds).
	// NOTE: This map must be local per file generation to avoid stale data in split mode.
	generatedMethods := make(map[string]bool)

	// Generate server interface (must be complete)
	buf.WriteString("// ServerInterface represents the server API.\n")
	buf.WriteString("type ServerInterface interface {\n")

	if cg.doc.Paths != nil {
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				methodName := operationToMethodName(op, path, method)
				if generatedMethods[methodName] {
					cg.addIssue(fmt.Sprintf("paths.%s.%s", path, method),
						fmt.Sprintf("duplicate method name %s - skipping", methodName), SeverityWarning)
					continue
				}
				generatedMethods[methodName] = true

				sig := cg.generateServerMethodSignature(path, method, op)
				buf.WriteString(sig)
			}
		}
	}

	buf.WriteString("}\n\n")

	// Write unimplemented server (must be complete)
	buf.WriteString("// UnimplementedServer provides default implementations that return errors.\n")
	buf.WriteString("type UnimplementedServer struct{}\n\n")

	// Track generated UnimplementedServer methods separately to avoid duplicates.
	// We can't reuse generatedMethods because it's used to check if a method was
	// added to the interface (i.e., wasn't filtered as duplicate).
	generatedUnimplemented := make(map[string]bool)

	if cg.doc.Paths != nil {
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				methodName := operationToMethodName(op, path, method)
				// Only generate if the method was added to the interface (not a duplicate)
				if !generatedMethods[methodName] {
					continue
				}
				// Skip if already generated for UnimplementedServer
				if generatedUnimplemented[methodName] {
					continue
				}
				generatedUnimplemented[methodName] = true

				responseType := cg.getResponseType(op)

				buf.WriteString(fmt.Sprintf("func (s *UnimplementedServer) %s(ctx context.Context, req *%sRequest) (%s, error) {\n",
					methodName, methodName, responseType))
				buf.WriteString(fmt.Sprintf("\treturn %s, ErrNotImplemented\n", zeroValue(responseType)))
				buf.WriteString("}\n\n")
			}
		}
	}

	// Write error type
	buf.WriteString("// ErrNotImplemented is returned by UnimplementedServer methods.\n")
	buf.WriteString("var ErrNotImplemented = &NotImplementedError{}\n\n")
	buf.WriteString("// NotImplementedError indicates an operation is not implemented.\n")
	buf.WriteString("type NotImplementedError struct{}\n\n")
	buf.WriteString("func (e *NotImplementedError) Error() string { return \"not implemented\" }\n\n")

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue("server.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server.go",
		Content: formatted,
	})

	return generatedMethods, nil
}

// generateOAS2ServerGroupFile generates a server_{group}.go file with request types for a specific group.
// The generatedMethods map indicates which methods were added to the interface (duplicates excluded).
//
//nolint:unparam // error return kept for API consistency with other generate methods
func (cg *oas2CodeGenerator) generateOAS2ServerGroupFile(group FileGroup, opToPathMethod map[string]struct {
	path   string
	method string
	op     *parser.Operation
}, generatedMethods map[string]bool) error {
	var buf bytes.Buffer

	// Write header with comment about the group
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// This file contains %s server request types.\n\n", group.DisplayName))
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString(")\n\n")

	// Generate request types for each operation in this group
	for _, opID := range group.Operations {
		// Skip if method was not added to interface (was filtered as duplicate)
		if !generatedMethods[opID] {
			continue
		}

		info, ok := opToPathMethod[opID]
		if !ok {
			continue
		}

		reqType := cg.generateRequestType(info.path, info.method, info.op)
		if reqType != "" {
			buf.WriteString(reqType)
		}
	}

	// Format the code
	formatted, err := formatAndFixImports("generated.go", buf.Bytes())
	if err != nil {
		cg.addIssue(fmt.Sprintf("server_%s.go", group.Name), fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    fmt.Sprintf("server_%s.go", group.Name),
		Content: formatted,
	})

	return nil
}

// generateServerMethodSignature generates the interface method signature
func (cg *oas2CodeGenerator) generateServerMethodSignature(path, method string, op *parser.Operation) string {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)
	responseType := cg.getResponseType(op)

	// Write comment - handle multiline descriptions properly
	if op.Summary != "" {
		buf.WriteString(formatMultilineComment(op.Summary, methodName, "\t"))
	} else if op.Description != "" {
		buf.WriteString(formatMultilineComment(op.Description, methodName, "\t"))
	}
	if op.Deprecated {
		buf.WriteString("\t// Deprecated: This operation is deprecated.\n")
	}

	buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, req *%sRequest) (%s, error)\n", methodName, methodName, responseType))

	return buf.String()
}

// generateRequestType generates a request struct for an operation
func (cg *oas2CodeGenerator) generateRequestType(path, method string, op *parser.Operation) string {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)

	buf.WriteString(fmt.Sprintf("// %sRequest contains the request data for %s.\n", methodName, methodName))
	buf.WriteString(fmt.Sprintf("type %sRequest struct {\n", methodName))

	// Categorize parameters in a single pass
	var pathParams, queryParams, headerParams []*parser.Parameter
	var bodyParam *parser.Parameter
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}
		switch param.In {
		case parser.ParamInPath:
			pathParams = append(pathParams, param)
		case parser.ParamInQuery:
			queryParams = append(queryParams, param)
		case parser.ParamInHeader:
			headerParams = append(headerParams, param)
		case parser.ParamInBody:
			if bodyParam == nil { // OAS 2.0 allows only one body parameter
				bodyParam = param
			}
		}
	}

	// Path parameters
	for _, param := range pathParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
	}

	// Query parameters
	for _, param := range queryParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		if !param.Required {
			buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
	}

	// Header parameters
	for _, param := range headerParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		if !param.Required {
			buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
	}

	// Body parameter (OAS 2.0)
	if bodyParam != nil {
		bodyType := "any"
		if bodyParam.Schema != nil {
			bodyType = cg.schemaToGoType(bodyParam.Schema, true)
		}
		buf.WriteString(fmt.Sprintf("\tBody %s\n", bodyType))
	}

	// HTTP request
	buf.WriteString("\tHTTPRequest *http.Request\n")

	buf.WriteString("}\n\n")

	return buf.String()
}

// generateSecurityHelpers generates security helper code based on configuration
func (cg *oas2CodeGenerator) generateSecurityHelpers() error {
	// Check if client generation is enabled
	if !cg.g.GenerateClient {
		return nil
	}

	// Get security definitions from OAS 2.0 document
	schemes := cg.doc.SecurityDefinitions

	// Generate security helpers if enabled
	if cg.g.GenerateSecurity && len(schemes) > 0 {
		if err := cg.generateSecurityHelpersFile(schemes); err != nil {
			return fmt.Errorf("failed to generate security helpers: %w", err)
		}
	}

	// Generate OAuth2 flows if enabled
	if cg.g.GenerateOAuth2Flows && len(schemes) > 0 {
		if err := cg.generateOAuth2Files(schemes); err != nil {
			return fmt.Errorf("failed to generate OAuth2 flows: %w", err)
		}
	}

	// Generate credential management if enabled
	if cg.g.GenerateCredentialMgmt {
		if err := cg.generateCredentialsFile(); err != nil {
			return fmt.Errorf("failed to generate credentials: %w", err)
		}
	}

	// Generate security enforcement if enabled
	if cg.g.GenerateSecurityEnforce {
		if err := cg.generateSecurityEnforceFile(); err != nil {
			return fmt.Errorf("failed to generate security enforcement: %w", err)
		}
	}

	// Generate OIDC discovery if enabled (rare in OAS 2.0 but still possible)
	if cg.g.GenerateOIDCDiscovery && len(schemes) > 0 {
		if err := cg.generateOIDCDiscoveryFile(schemes); err != nil {
			return fmt.Errorf("failed to generate OIDC discovery: %w", err)
		}
	}

	// Generate README if enabled
	if cg.g.GenerateReadme {
		if err := cg.generateReadmeFile(schemes); err != nil {
			return fmt.Errorf("failed to generate README: %w", err)
		}
	}

	return nil
}

// generateSecurityHelpersFile generates the security_helpers.go file for OAS 2.0
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateSecurityHelpersFile(schemes map[string]*parser.SecurityScheme) error {
	g := NewSecurityHelperGenerator(cg.result.PackageName)
	code := g.GenerateSecurityHelpers(schemes)

	// Format the code
	formatted, err := formatAndFixImports("generated.go", []byte(code))
	if err != nil {
		cg.addIssue("security_helpers.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = []byte(code)
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "security_helpers.go",
		Content: formatted,
	})

	return nil
}

// generateOAuth2Files generates OAuth2 flow files for each OAuth2 security scheme
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateOAuth2Files(schemes map[string]*parser.SecurityScheme) error {
	for name, scheme := range schemes {
		if scheme == nil || scheme.Type != schemeTypeOAuth2 {
			continue
		}

		g := NewOAuth2Generator(name, scheme)
		if g == nil || !g.HasAnyFlow() {
			continue
		}

		code := g.GenerateOAuth2File(cg.result.PackageName)

		// Format the code
		formatted, err := formatAndFixImports("generated.go", []byte(code))
		if err != nil {
			cg.addIssue(fmt.Sprintf("oauth2_%s.go", name), fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
			formatted = []byte(code)
		}

		fileName := fmt.Sprintf("oauth2_%s.go", toFileName(name))
		cg.result.Files = append(cg.result.Files, GeneratedFile{
			Name:    fileName,
			Content: formatted,
		})
	}

	return nil
}

// generateCredentialsFile generates the credentials.go file
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateCredentialsFile() error {
	g := NewCredentialGenerator(cg.result.PackageName)
	code := g.GenerateCredentialsFile()

	// Format the code
	formatted, err := formatAndFixImports("generated.go", []byte(code))
	if err != nil {
		cg.addIssue("credentials.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = []byte(code)
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "credentials.go",
		Content: formatted,
	})

	return nil
}

// generateSecurityEnforceFile generates security enforcement code.
// If file splitting is enabled and needed, generates multiple files.
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateSecurityEnforceFile() error {
	// Check if we should split
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitSecurityEnforce()
	}
	return cg.generateSingleSecurityEnforce()
}

// generateSingleSecurityEnforce generates all security enforcement in a single file.
func (cg *oas2CodeGenerator) generateSingleSecurityEnforce() error {
	g := NewSecurityEnforceGenerator(cg.result.PackageName)

	// Extract operation security requirements for OAS 2.0
	opSecurity := ExtractOperationSecurityOAS2(cg.doc)

	code := g.GenerateSecurityEnforceFile(opSecurity, cg.doc.Security)

	// Format the code
	formatted, err := formatAndFixImports("generated.go", []byte(code))
	if err != nil {
		cg.addIssue("security_enforce.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = []byte(code)
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "security_enforce.go",
		Content: formatted,
	})

	return nil
}

// generateSplitSecurityEnforce generates security enforcement split across multiple files.
func (cg *oas2CodeGenerator) generateSplitSecurityEnforce() error {
	g := NewSecurityEnforceGenerator(cg.result.PackageName)

	// Generate base file with shared types and empty map
	baseCode := g.GenerateBaseSecurityEnforceFile(cg.doc.Security)
	formatted, err := formatAndFixImports("generated.go", []byte(baseCode))
	if err != nil {
		cg.addIssue("security_enforce.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = []byte(baseCode)
	}
	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "security_enforce.go",
		Content: formatted,
	})

	// Extract all operation security
	allOpSecurity := ExtractOperationSecurityOAS2(cg.doc)

	// Group operations by their file group
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue
		}

		// Filter operation security for this group
		groupOpSecurity := make(OperationSecurityRequirements)
		for _, opID := range group.Operations {
			if sec, ok := allOpSecurity[opID]; ok {
				groupOpSecurity[opID] = sec
			}
		}

		if len(groupOpSecurity) == 0 {
			continue
		}

		// Generate group file
		groupCode := g.GenerateSecurityEnforceGroupFile(group.Name, group.DisplayName, groupOpSecurity)
		formatted, err := formatAndFixImports("generated.go", []byte(groupCode))
		if err != nil {
			cg.addIssue(fmt.Sprintf("security_enforce_%s.go", group.Name),
				fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
			formatted = []byte(groupCode)
		}

		cg.result.Files = append(cg.result.Files, GeneratedFile{
			Name:    fmt.Sprintf("security_enforce_%s.go", group.Name),
			Content: formatted,
		})
	}

	return nil
}

// generateOIDCDiscoveryFile generates the oidc_discovery.go file
// Note: OIDC is not officially part of OAS 2.0 but some specs may use it
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateOIDCDiscoveryFile(schemes map[string]*parser.SecurityScheme) error {
	// Find the first OpenID Connect scheme to get the discovery URL
	var discoveryURL string
	for _, scheme := range schemes {
		if scheme != nil && scheme.Type == "openIdConnect" && scheme.OpenIDConnectURL != "" {
			discoveryURL = scheme.OpenIDConnectURL
			break
		}
	}

	g := NewOIDCDiscoveryGenerator(cg.result.PackageName)
	code := g.GenerateOIDCDiscoveryFile(discoveryURL)

	// Format the code
	formatted, err := formatAndFixImports("generated.go", []byte(code))
	if err != nil {
		cg.addIssue("oidc_discovery.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = []byte(code)
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "oidc_discovery.go",
		Content: formatted,
	})

	return nil
}

// generateReadmeFile generates the README.md file
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateReadmeFile(schemes map[string]*parser.SecurityScheme) error {
	g := NewReadmeGenerator()

	// Build security scheme summaries
	var secSummaries []SecuritySchemeSummary
	if len(schemes) > 0 {
		// Sort scheme names for deterministic output
		names := make([]string, 0, len(schemes))
		for name := range schemes {
			names = append(names, name)
		}
		sort.Strings(names)

		for _, name := range names {
			scheme := schemes[name]
			if scheme == nil {
				continue
			}

			summary := SecuritySchemeSummary{
				Name:        name,
				Type:        scheme.Type,
				Description: scheme.Description,
			}

			switch scheme.Type {
			case schemeTypeAPIKey:
				summary.Location = scheme.In
			case schemeTypeBasic:
				summary.Type = schemeTypeHTTP
				summary.Scheme = schemeTypeBasic
			case schemeTypeOAuth2:
				summary.Flows = extractOAuth2FlowNames(nil, scheme.Flow)
			}

			secSummaries = append(secSummaries, summary)
		}
	}

	// Build generated file summaries
	fileSummaries := make([]GeneratedFileSummary, 0, len(cg.result.Files))
	for _, f := range cg.result.Files {
		lineCount := strings.Count(string(f.Content), "\n")
		desc := getFileDescription(f.Name)
		fileSummaries = append(fileSummaries, GeneratedFileSummary{
			FileName:    f.Name,
			Description: desc,
			LineCount:   lineCount,
		})
	}

	// Build split summary if applicable
	var splitSummary *SplitSummary
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		strategy := "by tag"
		if !cg.g.SplitByTag {
			strategy = "by path prefix"
		}
		groups := make([]string, 0, len(cg.splitPlan.Groups))
		for _, grp := range cg.splitPlan.Groups {
			groups = append(groups, grp.DisplayName)
		}
		splitSummary = &SplitSummary{
			WasSplit:        true,
			Strategy:        strategy,
			Groups:          groups,
			SharedTypesFile: "types.go",
		}
	}

	// Build context
	ctx := &ReadmeContext{
		Timestamp:   time.Now(),
		PackageName: cg.result.PackageName,
		OASVersion:  "2.0",
		Config: &GeneratorConfigSummary{
			GenerateTypes:           cg.g.GenerateTypes,
			GenerateClient:          cg.g.GenerateClient,
			GenerateSecurity:        cg.g.GenerateSecurity,
			GenerateOAuth2Flows:     cg.g.GenerateOAuth2Flows,
			GenerateCredentialMgmt:  cg.g.GenerateCredentialMgmt,
			GenerateSecurityEnforce: cg.g.GenerateSecurityEnforce,
			GenerateOIDCDiscovery:   cg.g.GenerateOIDCDiscovery,
		},
		GeneratedFiles:  fileSummaries,
		SecuritySchemes: secSummaries,
		SplitInfo:       splitSummary,
	}

	// Extract API info
	if cg.doc.Info != nil {
		ctx.APITitle = cg.doc.Info.Title
		ctx.APIVersion = cg.doc.Info.Version
		ctx.APIDescription = cg.doc.Info.Description
	}

	content := g.GenerateReadme(ctx)

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "README.md",
		Content: []byte(content),
	})

	return nil
}

// oas2HttpMethods defines the HTTP methods supported in OAS 2.0.
// Unlike OAS 3.0+, OAS 2.0 does not support Trace or Query methods.
var oas2HttpMethods = []string{
	httputil.MethodGet,
	httputil.MethodPut,
	httputil.MethodPost,
	httputil.MethodDelete,
	httputil.MethodOptions,
	httputil.MethodHead,
	httputil.MethodPatch,
}

// generateServerResponses generates typed response helpers for OAS 2.0
func (cg *oas2CodeGenerator) generateServerResponses() error {
	if len(cg.doc.Paths) == 0 {
		return nil
	}

	// Build template data
	data := ServerResponsesFileData{
		Header: HeaderData{
			PackageName: cg.result.PackageName,
		},
		Operations: make([]ResponseOperationData, 0),
	}

	// Track generated methods to avoid duplicates
	generatedMethods := make(map[string]bool)

	// Sort paths for deterministic output
	pathKeys := make([]string, 0, len(cg.doc.Paths))
	for path := range cg.doc.Paths {
		pathKeys = append(pathKeys, path)
	}
	sort.Strings(pathKeys)

	for _, path := range pathKeys {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range oas2HttpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			if generatedMethods[methodName] {
				continue
			}
			generatedMethods[methodName] = true

			// Build response operation data
			opData := ResponseOperationData{
				MethodName:   methodName,
				ResponseType: methodName + "Response",
				StatusCodes:  cg.buildStatusCodes(op),
			}

			data.Operations = append(data.Operations, opData)
		}
	}

	// Execute template
	formatted, err := executeTemplate("responses.go.tmpl", data)
	if err != nil {
		cg.addIssue("server_responses.go", fmt.Sprintf("failed to execute template: %v", err), SeverityWarning)
		return err
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server_responses.go",
		Content: formatted,
	})

	return nil
}

// buildStatusCodes builds status code data for an operation's responses (OAS 2.0)
func (cg *oas2CodeGenerator) buildStatusCodes(op *parser.Operation) []StatusCodeData {
	if op.Responses == nil {
		return nil
	}

	// Pre-allocate: 1 for default + status codes
	codes := make([]StatusCodeData, 0, 1+len(op.Responses.Codes))

	// Process default response first
	if op.Responses.Default != nil {
		statusData := cg.buildStatusCodeData("default", op.Responses.Default)
		codes = append(codes, statusData)
	}

	// Get sorted status codes from Codes map
	statusKeys := make([]string, 0, len(op.Responses.Codes))
	for code := range op.Responses.Codes {
		statusKeys = append(statusKeys, code)
	}
	sort.Strings(statusKeys)

	for _, code := range statusKeys {
		resp := op.Responses.Codes[code]
		if resp == nil {
			continue
		}
		statusData := cg.buildStatusCodeData(code, resp)
		codes = append(codes, statusData)
	}

	return codes
}

// buildStatusCodeData builds data for a single status code response (OAS 2.0)
func (cg *oas2CodeGenerator) buildStatusCodeData(code string, resp *parser.Response) StatusCodeData {
	statusData := StatusCodeData{
		Code:        code,
		Description: resp.Description,
	}

	// Determine method name and code type
	switch {
	case code == "default":
		statusData.MethodName = "StatusDefault"
		statusData.IsDefault = true
		statusData.StatusCodeInt = 500 // Use 500 as default status
	case len(code) == 3 && strings.HasSuffix(code, "XX"):
		// Wildcard like 2XX, 4XX, 5XX
		statusData.IsWildcard = true
		statusData.MethodName = "Status" + code
		// Use first code in range
		switch code[0] {
		case '2':
			statusData.StatusCodeInt = 200
			statusData.IsSuccess = true
		case '3':
			statusData.StatusCodeInt = 300
		case '4':
			statusData.StatusCodeInt = 400
		case '5':
			statusData.StatusCodeInt = 500
		}
	default:
		// Specific status code
		statusData.MethodName = "Status" + code
		var statusInt int
		if _, err := fmt.Sscanf(code, "%d", &statusInt); err == nil {
			statusData.StatusCodeInt = statusInt
			statusData.IsSuccess = statusInt >= 200 && statusInt < 300
		}
	}

	// OAS 2.0: Response has direct Schema field (not Content map)
	if resp.Schema != nil {
		statusData.HasBody = true
		statusData.ContentType = "application/json" // Default for OAS 2.0
		statusData.BodyType = cg.schemaToGoType(resp.Schema, true)
	}

	return statusData
}

// generateServerBinder generates parameter binding helpers for OAS 2.0
func (cg *oas2CodeGenerator) generateServerBinder() error {
	if len(cg.doc.Paths) == 0 {
		return nil
	}

	// Build template data
	data := ServerBinderFileData{
		Header: HeaderData{
			PackageName: cg.result.PackageName,
		},
		Operations: make([]BinderOperationData, 0),
	}

	// Track generated methods to avoid duplicates
	generatedMethods := make(map[string]bool)

	// Sort paths for deterministic output
	pathKeys := make([]string, 0, len(cg.doc.Paths))
	for path := range cg.doc.Paths {
		pathKeys = append(pathKeys, path)
	}
	sort.Strings(pathKeys)

	for _, path := range pathKeys {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range oas2HttpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			if generatedMethods[methodName] {
				continue
			}
			generatedMethods[methodName] = true

			// Build binder operation data
			opData := cg.buildBinderOperationData(methodName, op)
			data.Operations = append(data.Operations, opData)
		}
	}

	// Execute template
	formatted, err := executeTemplate("binder.go.tmpl", data)
	if err != nil {
		cg.addIssue("server_binder.go", fmt.Sprintf("failed to execute template: %v", err), SeverityWarning)
		return err
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server_binder.go",
		Content: formatted,
	})

	return nil
}

// buildBinderOperationData builds binding data for a single operation (OAS 2.0)
func (cg *oas2CodeGenerator) buildBinderOperationData(methodName string, op *parser.Operation) BinderOperationData {
	opData := BinderOperationData{
		MethodName:  methodName,
		RequestType: methodName + "Request",
	}

	// Process parameters
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}

		// OAS 2.0: Body parameter is handled separately
		if param.In == parser.ParamInBody {
			if param.Schema != nil {
				opData.HasBody = true
				opData.BodyType = cg.schemaToGoType(param.Schema, true)
			}
			continue
		}

		paramData := ParamBindData{
			Name:      param.Name,
			FieldName: toFieldName(param.Name),
			GoType:    cg.paramToGoType(param),
			Required:  param.Required,
			IsPointer: !param.Required && param.In != parser.ParamInPath,
		}

		// OAS 2.0: Type is directly on the parameter (not in Schema)
		paramData.SchemaType = cg.getOAS2ParamSchemaType(param)

		switch param.In {
		case parser.ParamInPath:
			opData.PathParams = append(opData.PathParams, paramData)
		case parser.ParamInQuery:
			opData.QueryParams = append(opData.QueryParams, paramData)
		case parser.ParamInHeader:
			opData.HeaderParams = append(opData.HeaderParams, paramData)
			// Note: OAS 2.0 does not support cookie parameters
		}
	}

	return opData
}

// getOAS2ParamSchemaType returns the schema type for an OAS 2.0 parameter.
// OAS 2.0 parameters have direct Type field instead of Schema.Type.
func (cg *oas2CodeGenerator) getOAS2ParamSchemaType(param *parser.Parameter) string {
	if param == nil {
		return "string"
	}

	// OAS 2.0: Type is directly on the parameter
	if param.Type != "" {
		return param.Type
	}

	// Fall back to schema type if present (for body parameters)
	if param.Schema != nil {
		switch t := param.Schema.Type.(type) {
		case string:
			return t
		case []any:
			if len(t) > 0 {
				if s, ok := t[0].(string); ok {
					return s
				}
			}
		case []string:
			if len(t) > 0 {
				return t[0]
			}
		}
	}

	return "string"
}

// generateServerMiddleware generates validation middleware for OAS 2.0
func (cg *oas2CodeGenerator) generateServerMiddleware() error {
	// The middleware template is static - it uses httpvalidator for validation
	// No per-operation data needed since it validates dynamically
	data := ServerMiddlewareFileData{
		Header: HeaderData{
			PackageName: cg.result.PackageName,
		},
	}

	formatted, err := executeTemplate("middleware.go.tmpl", data)
	if err != nil {
		cg.addIssue("server_middleware.go", fmt.Sprintf("failed to execute template: %v", err), SeverityWarning)
		return err
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server_middleware.go",
		Content: formatted,
	})
	return nil
}

// generateServerRouter generates HTTP router code for OAS 2.0
func (cg *oas2CodeGenerator) generateServerRouter() error {
	if len(cg.doc.Paths) == 0 {
		return nil
	}

	// Track generated methods to avoid duplicates
	generatedMethods := make(map[string]bool)

	// Sort paths for deterministic output
	pathKeys := make([]string, 0, len(cg.doc.Paths))
	for path := range cg.doc.Paths {
		pathKeys = append(pathKeys, path)
	}
	sort.Strings(pathKeys)

	// Build router data
	data := ServerRouterFileData{
		Header: HeaderData{
			PackageName: cg.result.PackageName,
		},
		Operations: make([]RouterOperationData, 0),
	}

	for _, path := range pathKeys {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range oas2HttpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			if generatedMethods[methodName] {
				continue
			}
			generatedMethods[methodName] = true

			opData := RouterOperationData{
				Path:        path,
				Method:      strings.ToUpper(method),
				MethodName:  methodName,
				RequestType: methodName + "Request",
			}

			// Collect path parameters with type info for proper conversion in templates
			for _, param := range op.Parameters {
				if param != nil && param.In == parser.ParamInPath {
					opData.PathParams = append(opData.PathParams, ParamBindData{
						Name:       param.Name,
						FieldName:  toFieldName(param.Name),
						GoType:     cg.paramToGoType(param),
						Required:   param.Required,
						SchemaType: cg.getOAS2ParamSchemaType(param),
					})
				}
			}

			data.Operations = append(data.Operations, opData)
		}
	}

	// Select template based on router type
	templateName := "router.go.tmpl"
	if cg.g.ServerRouter == "chi" {
		templateName = "router_chi.go.tmpl"
	}

	formatted, err := executeTemplate(templateName, data)
	if err != nil {
		cg.addIssue("server_router.go", fmt.Sprintf("failed to execute template: %v", err), SeverityWarning)
		return err
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server_router.go",
		Content: formatted,
	})
	return nil
}

// generateServerStubs generates testable stub implementations for OAS 2.0
func (cg *oas2CodeGenerator) generateServerStubs() error {
	if len(cg.doc.Paths) == 0 {
		return nil
	}

	// Track generated methods to avoid duplicates
	generatedMethods := make(map[string]bool)

	// Sort paths for deterministic output
	pathKeys := make([]string, 0, len(cg.doc.Paths))
	for path := range cg.doc.Paths {
		pathKeys = append(pathKeys, path)
	}
	sort.Strings(pathKeys)

	// Build stubs data
	data := ServerStubsFileData{
		Header: HeaderData{
			PackageName: cg.result.PackageName,
		},
		Operations: make([]StubOperationData, 0),
	}

	for _, path := range pathKeys {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range oas2HttpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			if generatedMethods[methodName] {
				continue
			}
			generatedMethods[methodName] = true

			// Determine response type
			responseType := "*" + methodName + "Response"
			if !cg.g.ServerResponses {
				responseType = "any"
			}

			opData := StubOperationData{
				MethodName:   methodName,
				RequestType:  methodName + "Request",
				ResponseType: responseType,
			}

			data.Operations = append(data.Operations, opData)
		}
	}

	formatted, err := executeTemplate("stubs.go.tmpl", data)
	if err != nil {
		cg.addIssue("server_stubs.go", fmt.Sprintf("failed to execute template: %v", err), SeverityWarning)
		return err
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server_stubs.go",
		Content: formatted,
	})
	return nil
}
