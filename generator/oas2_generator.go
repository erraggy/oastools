package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/erraggy/oastools/internal/httputil"
	"github.com/erraggy/oastools/internal/maputil"
	"github.com/erraggy/oastools/parser"
)

// oas2CodeGenerator handles code generation for OAS 2.0 documents
type oas2CodeGenerator struct {
	baseCodeGenerator
	doc *parser.OAS2Document
}

func newOAS2CodeGenerator(g *Generator, doc *parser.OAS2Document, result *GenerateResult) *oas2CodeGenerator {
	cg := &oas2CodeGenerator{
		doc: doc,
	}
	cg.initBase(g, result)

	// Analyze document for file splitting
	splitter := &FileSplitter{
		MaxLinesPerFile:      g.MaxLinesPerFile,
		MaxTypesPerFile:      g.MaxTypesPerFile,
		MaxOperationsPerFile: g.MaxOperationsPerFile,
		SplitByTag:           g.SplitByTag,
		SplitByPathPrefix:    g.SplitByPathPrefix,
	}
	cg.splitPlan = splitter.AnalyzeOAS2(doc)

	// Populate base fields for shared methods
	cg.paths = doc.Paths
	cg.oasVersion = parser.OASVersion20
	cg.httpMethods = oas2HttpMethods
	cg.statusCodeDataBuilder = cg.buildStatusCodeData
	cg.binderOperationDataBuilder = cg.buildBinderOperationData

	return cg
}

// generateTypes generates type definitions from schemas
func (cg *oas2CodeGenerator) generateTypes() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitTypes()
	}

	return cg.generateSingleTypes()
}

// collectSchemas extracts all schemas from definitions and populates schemaNames mapping.
// Returns a sorted slice of schema entries for deterministic output.
// Duplicate type names (e.g., "user_profile" and "UserProfile" both becoming "UserProfile")
// are detected and skipped with a warning.
func (cg *oas2CodeGenerator) collectSchemas() []oas2SchemaEntry {
	var schemas []oas2SchemaEntry
	if cg.doc.Definitions != nil {
		for name, schema := range cg.doc.Definitions {
			if schema == nil {
				continue
			}
			// Check for duplicate type names (e.g., "user_profile" and "UserProfile" both become "UserProfile")
			typeName := toTypeName(name)
			if cg.generatedTypes[typeName] {
				cg.addIssue(fmt.Sprintf("definitions.%s", name),
					fmt.Sprintf("duplicate type name %s - skipping", typeName), SeverityWarning)
				continue
			}
			cg.generatedTypes[typeName] = true

			schemas = append(schemas, oas2SchemaEntry{name: name, schema: schema})
			cg.schemaNames["#/definitions/"+name] = typeName
		}
	}

	// Sort schemas for deterministic output
	sort.Slice(schemas, func(i, j int) bool {
		return schemas[i].name < schemas[j].name
	})

	return schemas
}

// generateSingleTypes generates all types in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleTypes() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Collect imports
	imports := make(map[string]bool)

	// Process schemas from definitions
	schemas := cg.collectSchemas()

	// Check for time imports
	for _, entry := range schemas {
		if needsTimeImport(entry.schema) {
			imports["time"] = true
			break
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		importList := make([]string, 0, len(imports))
		for imp := range imports {
			importList = append(importList, imp)
		}
		sort.Strings(importList)
		for _, imp := range importList {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate each schema
	for _, entry := range schemas {
		code, err := cg.generateSchemaType(entry.name, entry.schema)
		if err != nil {
			cg.addIssue("definitions."+entry.name, fmt.Sprintf("failed to generate type: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		buf.WriteString("\n")
		cg.result.GeneratedTypes++
	}

	// Format and append the file
	appendFormattedFile(cg.result, "types.go", &buf, cg.addIssue)

	return nil
}

// generateSplitTypes generates types split across multiple files
func (cg *oas2CodeGenerator) generateSplitTypes() error {
	// Build type maps from split plan
	sharedTypes, groupTypes := buildTypeGroupMaps(cg.splitPlan)

	// Get all schemas
	allSchemas := cg.collectSchemas()

	// Generate shared types file (types.go)
	if err := cg.generateOAS2TypesFile("types.go", "Shared types used across multiple operations", allSchemas, sharedTypes); err != nil {
		return err
	}

	// Generate per-group type files
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue
		}

		types := groupTypes[group.Name]
		if len(types) == 0 {
			continue
		}

		fileName := fmt.Sprintf("types_%s.go", group.Name)
		comment := fmt.Sprintf("%s types", group.DisplayName)
		if err := cg.generateOAS2TypesFile(fileName, comment, allSchemas, types); err != nil {
			cg.addIssue(fileName, fmt.Sprintf("failed to generate: %v", err), SeverityWarning)
		}
	}

	return nil
}

// generateOAS2TypesFile generates a types file with only the specified types
func (cg *oas2CodeGenerator) generateOAS2TypesFile(fileName, comment string, allSchemas []oas2SchemaEntry, includeTypes map[string]bool) error {
	// Build filtered types list (pre-allocate with reasonable capacity)
	filteredSchemas := make([]oas2SchemaEntry, 0, len(includeTypes))
	for _, entry := range allSchemas {
		typeName := toTypeName(entry.name)
		if includeTypes[typeName] || includeTypes[entry.name] {
			filteredSchemas = append(filteredSchemas, entry)
		}
	}

	if len(filteredSchemas) == 0 {
		return nil // Skip empty files
	}

	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n")
	if comment != "" {
		buf.WriteString(fmt.Sprintf("// %s\n", comment))
	}
	buf.WriteString("\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Collect imports
	imports := make(map[string]bool)
	for _, entry := range filteredSchemas {
		if needsTimeImport(entry.schema) {
			imports["time"] = true
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range imports {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate type definitions
	for _, entry := range filteredSchemas {
		code, err := cg.generateSchemaType(entry.name, entry.schema)
		if err != nil {
			cg.addIssue(fmt.Sprintf("definitions.%s", entry.name), fmt.Sprintf("failed to generate type: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		cg.result.GeneratedTypes++
	}

	// Format and append the file
	appendFormattedFile(cg.result, fileName, &buf, cg.addIssue)

	return nil
}

// oas2SchemaEntry holds a schema name and its definition
type oas2SchemaEntry struct {
	name   string
	schema *parser.Schema
}

// generateSchemaType generates Go code for a schema type
func (cg *oas2CodeGenerator) generateSchemaType(name string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	typeName := toTypeName(name)

	// Handle $ref
	if schema.Ref != "" {
		refType := cg.resolveRef(schema.Ref)
		buf.WriteString(fmt.Sprintf("// %s is an alias for %s.\n", typeName, refType))
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, refType))
		return buf.String(), nil
	}

	// Write documentation
	if schema.Description != "" {
		buf.WriteString(fmt.Sprintf("// %s %s\n", typeName, cleanDescription(schema.Description)))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents the %s schema.\n", typeName, name))
	}

	// Determine schema type
	schemaType := getSchemaType(schema)

	switch schemaType {
	case "object":
		// Generate struct
		buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		if schema.Properties != nil {
			cg.writeStructFields(&buf, schema, typeName, true)
		}
		buf.WriteString("}\n")

	case "array":
		// Generate type alias for array
		itemType := cg.getArrayItemType(schema)
		buf.WriteString(fmt.Sprintf("type %s []%s\n", typeName, itemType))

	case "string":
		// Check for enum
		if len(schema.Enum) > 0 {
			buf.WriteString(fmt.Sprintf("type %s string\n\n", typeName))
			buf.WriteString("const (\n")
			for _, e := range schema.Enum {
				enumVal := fmt.Sprintf("%v", e)
				enumName := typeName + toFieldName(enumVal)
				buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", enumName, typeName, enumVal))
			}
			buf.WriteString(")\n")
		} else {
			goType := stringFormatToGoType(schema.Format)
			buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))
		}

	case "integer":
		goType := integerFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "number":
		goType := numberFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "boolean":
		buf.WriteString(fmt.Sprintf("type %s = bool\n", typeName))

	default:
		// Handle allOf
		if len(schema.AllOf) > 0 {
			return cg.generateAllOfType(typeName, schema)
		}
		// Default to any
		buf.WriteString(fmt.Sprintf("type %s = any\n", typeName))
	}

	return buf.String(), nil
}

// generateAllOfType generates a type for allOf composition
func (cg *oas2CodeGenerator) generateAllOfType(typeName string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("// %s combines multiple schemas.\n", typeName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	for _, subSchema := range schema.AllOf {
		if subSchema.Ref != "" {
			refType := cg.resolveRef(subSchema.Ref)
			buf.WriteString(fmt.Sprintf("\t%s\n", refType))
		} else if subSchema.Properties != nil {
			// Inline properties (no description comments for allOf inline properties)
			cg.writeStructFields(&buf, subSchema, typeName, false)
		}
	}

	buf.WriteString("}\n")
	return buf.String(), nil
}

// writeStructFields writes struct fields for properties in sorted order.
// includeDescription controls whether to emit field description comments.
func (cg *oas2CodeGenerator) writeStructFields(buf *bytes.Buffer, schema *parser.Schema, typeName string, includeDescription bool) {
	propNames := make([]string, 0, len(schema.Properties))
	for propName := range schema.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	for _, propName := range propNames {
		propSchema := schema.Properties[propName]
		if propSchema == nil {
			continue
		}

		goType := cg.schemaToGoType(propSchema, isRequired(schema.Required, propName))

		// Check for self-reference (recursive type) - needs pointer indirection
		if isSelfReference(propSchema, typeName) &&
			!strings.HasPrefix(goType, "*") &&
			!strings.HasPrefix(goType, "[]") {
			goType = "*" + goType
		}

		fieldName := toFieldName(propName)
		jsonTag := propName
		if !isRequired(schema.Required, propName) {
			jsonTag += ",omitempty"
		}

		if includeDescription && propSchema.Description != "" {
			fmt.Fprintf(buf, "\t// %s\n", cleanDescription(propSchema.Description))
		}

		fmt.Fprintf(buf, "\t%s %s `json:%q`\n", fieldName, goType, jsonTag)
	}
}

// schemaToGoType converts a schema to a Go type string
func (cg *oas2CodeGenerator) schemaToGoType(schema *parser.Schema, required bool) string {
	// OAS 2.0 doesn't have nullable, so isNullable is always false
	return cg.schemaToGoTypeBase(schema, required, false, cg.schemaToGoType)
}

// getArrayItemType extracts the Go type for array items, handling $ref properly
func (cg *oas2CodeGenerator) getArrayItemType(schema *parser.Schema) string {
	return cg.baseCodeGenerator.getArrayItemType(schema, cg.schemaToGoType)
}

// generateClient generates HTTP client code for OAS 2.0
func (cg *oas2CodeGenerator) generateClient() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitClient()
	}

	return cg.generateSingleClient()
}

// generateSingleClient generates all client code in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleClient() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Write client struct, types, constructor, and options using shared boilerplate
	writeClientBoilerplate(&buf, cg.doc.Info)

	// Generate methods for each operation
	if cg.doc.Paths != nil {
		// Sort paths for deterministic output
		pathKeys := maputil.SortedKeys(cg.doc.Paths)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, parser.OASVersion20)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				code, err := cg.generateClientMethod(path, method, op)
				if err != nil {
					cg.addIssue(fmt.Sprintf("paths.%s.%s", path, method), fmt.Sprintf("failed to generate client method: %v", err), SeverityWarning)
					continue
				}
				buf.WriteString(code)
				cg.result.GeneratedOperations++
			}
		}
	}

	// Write helper functions
	buf.WriteString(clientHelpers)

	// Format and append the file
	appendFormattedFile(cg.result, "client.go", &buf, cg.addIssue)

	return nil
}

// generateSplitClient generates client code split across multiple files
func (cg *oas2CodeGenerator) generateSplitClient() error {
	// Generate the base client.go (struct, constructor, options, helpers - no operations)
	if err := cg.generateOAS2BaseClient(); err != nil {
		return err
	}

	// Build a map of operation ID to path/method for quick lookup
	opToPathMethod := buildOperationMap(cg.doc.Paths, parser.OASVersion20)

	// Generate a client file for each group
	for _, group := range cg.splitPlan.Groups {
		if group.IsShared {
			continue // Skip shared types group
		}

		if err := cg.generateOAS2ClientGroupFile(group, opToPathMethod); err != nil {
			cg.addIssue(fmt.Sprintf("client_%s.go", group.Name), fmt.Sprintf("failed to generate: %v", err), SeverityWarning)
		}
	}

	return nil
}

// generateOAS2BaseClient generates the base client.go with struct, constructor, and options (no operations)
func (cg *oas2CodeGenerator) generateOAS2BaseClient() error {
	return generateBaseClientShared(cg.result.PackageName, cg.doc.Info, cg.result, cg.addIssue)
}

// generateOAS2ClientGroupFile generates a client_{group}.go file with operations for a specific group
//
//nolint:unparam // error return kept for API consistency with other generate methods
func (cg *oas2CodeGenerator) generateOAS2ClientGroupFile(group FileGroup, opToPathMethod map[string]OperationMapping) error {
	var buf bytes.Buffer

	// Write header with comment about the group
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("// This file contains %s operations.\n\n", group.DisplayName))
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports (full set needed for operations)
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Generate each operation in this group using shared helper
	generateGroupClientMethods(&buf, group, opToPathMethod, cg.result, cg.addIssue, cg.generateClientMethod)

	// Format and append the file
	fileName := fmt.Sprintf("client_%s.go", group.Name)
	appendFormattedFile(cg.result, fileName, &buf, cg.addIssue)

	return nil
}

// generateClientMethod generates a client method for an operation
//
//nolint:unparam // error return kept for API consistency with interface requirements
func (cg *oas2CodeGenerator) generateClientMethod(path, method string, op *parser.Operation) (string, error) {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)

	// Build parameter list
	var params []string
	params = append(params, "ctx context.Context")

	// Process all parameters in a single pass
	var pathParams []pathParam
	var queryParams []*parser.Parameter
	var hasBody bool
	var bodyParamSchema *parser.Schema
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}
		switch param.In {
		case parser.ParamInPath:
			goType := cg.paramToGoType(param)
			paramName := toParamName(param.Name)
			params = append(params, fmt.Sprintf("%s %s", paramName, goType))
			pathParams = append(pathParams, pathParam{name: param.Name, varName: paramName})
		case parser.ParamInQuery:
			queryParams = append(queryParams, param)
		case parser.ParamInBody:
			if !hasBody { // Only use the first body param
				hasBody = true
				bodyParamSchema = param.Schema
			}
		}
	}
	if len(queryParams) > 0 {
		params = append(params, "params *"+methodName+"Params")
	}
	if hasBody {
		bodyType := "any"
		if bodyParamSchema != nil {
			bodyType = cg.schemaToGoType(bodyParamSchema, true)
		}
		params = append(params, "body "+bodyType)
	}

	// Generate method using shared helpers
	responseType := cg.getResponseType(op)
	contentType := "application/json" // OAS 2.0 always uses JSON for body params

	writeClientMethod(&buf, op, methodName, method, path, params, pathParams, queryParams,
		hasBody, contentType, responseType, cg.paramToGoType)

	return buf.String(), nil
}

// paramToGoType converts a parameter to its Go type
func (cg *oas2CodeGenerator) paramToGoType(param *parser.Parameter) string {
	// OAS 2.0 uses type directly on parameter
	return paramTypeToGoType(param.Type, param.Format)
}

// getResponseType determines the Go type for the success response
func (cg *oas2CodeGenerator) getResponseType(op *parser.Operation) string {
	if op.Responses == nil {
		return httpResponseType
	}

	// Check for 200, 201 responses
	for _, code := range []string{"200", "201"} {
		if resp := op.Responses.Codes[code]; resp != nil {
			// OAS 2.0 uses schema directly on response
			if resp.Schema != nil {
				goType := cg.schemaToGoType(resp.Schema, true)
				if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
					return "*" + goType
				}
				return goType
			}
		}
	}

	// Check default response
	if op.Responses.Default != nil && op.Responses.Default.Schema != nil {
		goType := cg.schemaToGoType(op.Responses.Default.Schema, true)
		if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
			return "*" + goType
		}
		return goType
	}

	return httpResponseType
}

// generateServer generates server interface code for OAS 2.0
func (cg *oas2CodeGenerator) generateServer() error {
	// Check if we should split into multiple files
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		return cg.generateSplitServer()
	}

	return cg.generateSingleServer()
}

// generateSingleServer generates all server code in a single file (original behavior)
func (cg *oas2CodeGenerator) generateSingleServer() error {
	// Use shared function with request type callback for single-file mode
	_, err := generateBaseServerShared(&baseServerContext{
		paths:                   cg.doc.Paths,
		oasVersion:              parser.OASVersion20,
		httpMethods:             oas2HttpMethods,
		packageName:             cg.result.PackageName,
		needsTime:               false, // OAS 2.0 doesn't support date-time in the same way
		result:                  cg.result,
		addIssue:                cg.addIssue,
		generateMethodSignature: cg.generateServerMethodSignature,
		getResponseType:         cg.getResponseType,
		generateRequestTypes:    cg.writeRequestTypes,
		schemaTypes:             cg.generatedTypes,
	})
	return err
}

// writeRequestTypes generates request types for all operations.
// This is used as a callback for single-file server generation.
func (cg *oas2CodeGenerator) writeRequestTypes(buf *bytes.Buffer, generatedMethods map[string]bool) {
	for _, path := range maputil.SortedKeys(cg.doc.Paths) {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, parser.OASVersion20)
		for _, method := range httpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			methodName := operationToMethodName(op, path, method)
			// Skip if method was not added to interface (was filtered as duplicate)
			if !generatedMethods[methodName] {
				continue
			}

			reqType := cg.generateRequestType(path, method, op)
			if reqType != "" {
				buf.WriteString(reqType)
			}
		}
	}
}

// generateSplitServer generates server code split across multiple files
func (cg *oas2CodeGenerator) generateSplitServer() error {
	return generateSplitServerShared(&splitServerContext{
		paths:               cg.doc.Paths,
		oasVersion:          parser.OASVersion20,
		splitPlan:           cg.splitPlan,
		result:              cg.result,
		addIssue:            cg.addIssue,
		generateBaseServer:  cg.generateOAS2BaseServer,
		generateRequestType: cg.generateRequestType,
	})
}

// generateOAS2BaseServer generates the base server.go with interface and unimplemented struct.
// Returns a map of generated method names (to exclude duplicates from request type generation).
//
//nolint:unparam // error return kept for API consistency and future extensibility
func (cg *oas2CodeGenerator) generateOAS2BaseServer() (map[string]bool, error) {
	return generateBaseServerShared(&baseServerContext{
		paths:                   cg.doc.Paths,
		oasVersion:              parser.OASVersion20,
		httpMethods:             oas2HttpMethods,
		packageName:             cg.result.PackageName,
		needsTime:               false, // OAS 2.0 doesn't support date-time in the same way
		schemaTypes:             cg.generatedTypes,
		result:                  cg.result,
		addIssue:                cg.addIssue,
		generateMethodSignature: cg.generateServerMethodSignature,
		getResponseType:         cg.getResponseType,
	})
}

// generateServerMethodSignature generates the interface method signature
func (cg *oas2CodeGenerator) generateServerMethodSignature(path, method string, op *parser.Operation) string {
	return buildServerMethodSignature(path, method, op, cg.getResponseType(op), cg.generatedTypes)
}

// generateRequestType generates a request struct for an operation
func (cg *oas2CodeGenerator) generateRequestType(path, method string, op *parser.Operation) string {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)
	wrapperName := resolveWrapperName(methodName, cg.generatedTypes)

	buf.WriteString(fmt.Sprintf("// %s contains the request data for %s.\n", wrapperName, methodName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", wrapperName))

	// Categorize parameters in a single pass
	var pathParams, queryParams, headerParams []*parser.Parameter
	var bodyParam *parser.Parameter
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}
		switch param.In {
		case parser.ParamInPath:
			pathParams = append(pathParams, param)
		case parser.ParamInQuery:
			queryParams = append(queryParams, param)
		case parser.ParamInHeader:
			headerParams = append(headerParams, param)
		case parser.ParamInBody:
			if bodyParam == nil { // OAS 2.0 allows only one body parameter
				bodyParam = param
			}
		}
	}

	// Path parameters
	for _, param := range pathParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
	}

	// Query parameters
	for _, param := range queryParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		if !param.Required {
			buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
	}

	// Header parameters
	for _, param := range headerParams {
		goType := cg.paramToGoType(param)
		fieldName := toFieldName(param.Name)
		if !param.Required {
			buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
	}

	// Body parameter (OAS 2.0)
	if bodyParam != nil {
		bodyType := "any"
		if bodyParam.Schema != nil {
			bodyType = cg.schemaToGoType(bodyParam.Schema, true)
		}
		buf.WriteString(fmt.Sprintf("\tBody %s\n", bodyType))
	}

	// HTTP request
	buf.WriteString("\tHTTPRequest *http.Request\n")

	buf.WriteString("}\n\n")

	return buf.String()
}

// generateSecurityHelpers generates security helper code based on configuration
func (cg *oas2CodeGenerator) generateSecurityHelpers() {
	generateAllSecurityHelpers(cg.g, cg.doc.SecurityDefinitions, fullSecurityCallbacks{
		generateSecurityHelpersFile: cg.generateSecurityHelpersFile,
		generateOAuth2Files:         cg.generateOAuth2Files,
		generateCredentials:         cg.generateCredentialsFile,
		generateSecurityEnforce:     cg.generateSecurityEnforceFile,
		generateOIDCDiscovery:       cg.generateOIDCDiscoveryFile,
		generateReadme:              cg.generateReadmeFile,
	})
}

// generateSecurityEnforceFile generates security enforcement code.
// If file splitting is enabled and needed, generates multiple files.
func (cg *oas2CodeGenerator) generateSecurityEnforceFile() {
	// Check if we should split
	if cg.splitPlan != nil && cg.splitPlan.NeedsSplit {
		cg.generateSplitSecurityEnforce()
		return
	}
	cg.generateSingleSecurityEnforce()
}

// generateSingleSecurityEnforce generates all security enforcement in a single file.
func (cg *oas2CodeGenerator) generateSingleSecurityEnforce() {
	opSecurity := ExtractOperationSecurityOAS2(cg.doc)
	generateSingleSecurityEnforceShared(cg.securityContext(), opSecurity, cg.doc.Security)
}

// generateSplitSecurityEnforce generates security enforcement split across multiple files.
func (cg *oas2CodeGenerator) generateSplitSecurityEnforce() {
	opSecurity := ExtractOperationSecurityOAS2(cg.doc)
	generateSplitSecurityEnforceShared(cg.securityContext(), opSecurity, cg.doc.Security)
}

// generateReadmeFile generates the README.md file
func (cg *oas2CodeGenerator) generateReadmeFile(schemes map[string]*parser.SecurityScheme) {
	g := NewReadmeGenerator()

	// Build version-specific security scheme summaries
	secSummaries := buildSecuritySchemeSummariesOAS2(schemes)

	// Build context using shared helper
	builder := &readmeContextBuilder{
		PackageName: cg.result.PackageName,
		OASVersion:  "2.0",
		Config:      cg.g,
		SplitPlan:   cg.splitPlan,
		Files:       cg.result.Files,
		Info:        cg.doc.Info,
	}
	ctx := buildReadmeContextShared(builder, secSummaries)

	content := g.GenerateReadme(ctx)

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "README.md",
		Content: []byte(content),
	})
}

// oas2HttpMethods defines the HTTP methods supported in OAS 2.0.
// Unlike OAS 3.0+, OAS 2.0 does not support Trace or Query methods.
var oas2HttpMethods = []string{
	httputil.MethodGet,
	httputil.MethodPut,
	httputil.MethodPost,
	httputil.MethodDelete,
	httputil.MethodOptions,
	httputil.MethodHead,
	httputil.MethodPatch,
}

// buildStatusCodeData builds data for a single status code response (OAS 2.0)
func (cg *oas2CodeGenerator) buildStatusCodeData(code string, resp *parser.Response) StatusCodeData {
	// Parse status code metadata using shared helper
	statusData := parseStatusCodeMetadata(code)
	statusData.Description = resp.Description

	// OAS 2.0: Response has direct Schema field (not Content map)
	if resp.Schema != nil {
		statusData.HasBody = true
		statusData.ContentType = "application/json" // Default for OAS 2.0
		statusData.BodyType = cg.schemaToGoType(resp.Schema, true)
	}

	return statusData
}

// buildBinderOperationData builds binding data for a single operation (OAS 2.0)
func (cg *oas2CodeGenerator) buildBinderOperationData(methodName string, op *parser.Operation) BinderOperationData {
	opData := BinderOperationData{
		MethodName:  methodName,
		RequestType: resolveWrapperName(methodName, cg.generatedTypes),
	}

	// Process parameters
	for _, param := range op.Parameters {
		if param == nil {
			continue
		}

		// OAS 2.0: Body parameter is handled separately
		if param.In == parser.ParamInBody {
			if param.Schema != nil {
				opData.HasBody = true
				opData.BodyType = cg.schemaToGoType(param.Schema, true)
			}
			continue
		}

		paramData := ParamBindData{
			Name:      param.Name,
			FieldName: toFieldName(param.Name),
			GoType:    cg.paramToGoType(param),
			Required:  param.Required,
			IsPointer: !param.Required && param.In != parser.ParamInPath,
		}

		// OAS 2.0: Type is directly on the parameter (not in Schema)
		paramData.SchemaType = cg.getOAS2ParamSchemaType(param)

		switch param.In {
		case parser.ParamInPath:
			opData.PathParams = append(opData.PathParams, paramData)
		case parser.ParamInQuery:
			opData.QueryParams = append(opData.QueryParams, paramData)
		case parser.ParamInHeader:
			opData.HeaderParams = append(opData.HeaderParams, paramData)
			// Note: OAS 2.0 does not support cookie parameters
		}
	}

	return opData
}

// getOAS2ParamSchemaType returns the schema type for an OAS 2.0 parameter.
// OAS 2.0 parameters have direct Type field instead of Schema.Type.
func (cg *oas2CodeGenerator) getOAS2ParamSchemaType(param *parser.Parameter) string {
	if param == nil {
		return "string"
	}

	// OAS 2.0: Type is directly on the parameter
	if param.Type != "" {
		return param.Type
	}

	// Fall back to schema type if present (for body parameters)
	if param.Schema != nil {
		switch t := param.Schema.Type.(type) {
		case string:
			return t
		case []any:
			if len(t) > 0 {
				if s, ok := t[0].(string); ok {
					return s
				}
			}
		case []string:
			if len(t) > 0 {
				return t[0]
			}
		}
	}

	return "string"
}

// generateServerRouter generates HTTP router code for OAS 2.0
func (cg *oas2CodeGenerator) generateServerRouter() error {
	return generateServerRouterShared(&serverRouterContext{
		paths:        cg.doc.Paths,
		oasVersion:   parser.OASVersion20,
		httpMethods:  oas2HttpMethods,
		packageName:  cg.result.PackageName,
		serverRouter: cg.g.ServerRouter,
		schemaTypes:  cg.generatedTypes,
		result:       cg.result,
		addIssue:     cg.addIssue,
		paramToBindData: func(param *parser.Parameter) ParamBindData {
			return ParamBindData{
				Name:       param.Name,
				FieldName:  toFieldName(param.Name),
				GoType:     cg.paramToGoType(param),
				Required:   param.Required,
				SchemaType: cg.getOAS2ParamSchemaType(param),
			}
		},
	})
}
