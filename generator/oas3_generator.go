package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
	"unicode"

	"github.com/erraggy/oastools/internal/httputil"
	"github.com/erraggy/oastools/parser"
)

// oas3CodeGenerator handles code generation for OAS 3.x documents
type oas3CodeGenerator struct {
	g      *Generator
	doc    *parser.OAS3Document
	result *GenerateResult
	// schemaNames maps schema references to generated type names
	schemaNames map[string]string
}

func newOAS3CodeGenerator(g *Generator, doc *parser.OAS3Document, result *GenerateResult) *oas3CodeGenerator {
	return &oas3CodeGenerator{
		g:           g,
		doc:         doc,
		result:      result,
		schemaNames: make(map[string]string),
	}
}

// generateTypes generates type definitions from schemas
func (cg *oas3CodeGenerator) generateTypes() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Collect imports
	imports := make(map[string]bool)

	// Process schemas from components
	var schemas []schemaEntry
	if cg.doc.Components != nil && cg.doc.Components.Schemas != nil {
		for name, schema := range cg.doc.Components.Schemas {
			if schema == nil {
				continue
			}
			schemas = append(schemas, schemaEntry{name: name, schema: schema})
			cg.schemaNames["#/components/schemas/"+name] = toTypeName(name)
		}
	}

	// Sort schemas for deterministic output
	sort.Slice(schemas, func(i, j int) bool {
		return schemas[i].name < schemas[j].name
	})

	// Check for time imports
	for _, entry := range schemas {
		if needsTimeImport(entry.schema) {
			imports["time"] = true
			break
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		var importList []string
		for imp := range imports {
			importList = append(importList, imp)
		}
		sort.Strings(importList)
		for _, imp := range importList {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate each schema
	for _, entry := range schemas {
		code, err := cg.generateSchemaType(entry.name, entry.schema)
		if err != nil {
			cg.addIssue("components.schemas."+entry.name, fmt.Sprintf("failed to generate type: %v", err), SeverityWarning)
			continue
		}
		buf.WriteString(code)
		buf.WriteString("\n")
		cg.result.GeneratedTypes++
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, use unformatted code
		cg.addIssue("types.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "types.go",
		Content: formatted,
	})

	return nil
}

// schemaEntry holds a schema name and its definition
type schemaEntry struct {
	name   string
	schema *parser.Schema
}

// generateSchemaType generates Go code for a schema type
func (cg *oas3CodeGenerator) generateSchemaType(name string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	typeName := toTypeName(name)

	// Handle $ref
	if schema.Ref != "" {
		refType := cg.resolveRef(schema.Ref)
		buf.WriteString(fmt.Sprintf("// %s is an alias for %s.\n", typeName, refType))
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, refType))
		return buf.String(), nil
	}

	// Write documentation
	if schema.Description != "" {
		buf.WriteString(fmt.Sprintf("// %s %s\n", typeName, cleanDescription(schema.Description)))
	} else {
		buf.WriteString(fmt.Sprintf("// %s represents the %s schema.\n", typeName, name))
	}

	// Determine schema type
	schemaType := getSchemaType(schema)

	switch schemaType {
	case "object":
		// Generate struct
		buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		if schema.Properties != nil {
			// Sort properties for deterministic output
			var propNames []string
			for propName := range schema.Properties {
				propNames = append(propNames, propName)
			}
			sort.Strings(propNames)

			for _, propName := range propNames {
				propSchema := schema.Properties[propName]
				if propSchema == nil {
					continue
				}

				goType := cg.schemaToGoType(propSchema, isRequired(schema.Required, propName))
				fieldName := toFieldName(propName)
				jsonTag := propName
				if !isRequired(schema.Required, propName) {
					jsonTag += ",omitempty"
				}

				// Add field comment
				if propSchema.Description != "" {
					buf.WriteString(fmt.Sprintf("\t// %s\n", cleanDescription(propSchema.Description)))
				}

				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, jsonTag))
			}
		}
		// Handle additionalProperties
		if schema.AdditionalProperties != nil {
			if addProps, ok := schema.AdditionalProperties.(*parser.Schema); ok {
				goType := cg.schemaToGoType(addProps, true)
				buf.WriteString("\t// AdditionalProperties holds additional properties.\n")
				buf.WriteString(fmt.Sprintf("\tAdditionalProperties map[string]%s `json:\"-\"`\n", goType))
			} else if addProps, ok := schema.AdditionalProperties.(bool); ok && addProps {
				buf.WriteString("\t// AdditionalProperties holds additional properties.\n")
				buf.WriteString("\tAdditionalProperties map[string]any `json:\"-\"`\n")
			}
		}
		buf.WriteString("}\n")

	case "array":
		// Generate type alias for array
		itemType := "any"
		if schema.Items != nil {
			if itemSchema, ok := schema.Items.(*parser.Schema); ok {
				itemType = cg.schemaToGoType(itemSchema, true)
			}
		}
		buf.WriteString(fmt.Sprintf("type %s []%s\n", typeName, itemType))

	case "string":
		// Check for enum
		if len(schema.Enum) > 0 {
			buf.WriteString(fmt.Sprintf("type %s string\n\n", typeName))
			buf.WriteString("const (\n")
			for _, e := range schema.Enum {
				enumVal := fmt.Sprintf("%v", e)
				enumName := typeName + toFieldName(enumVal)
				buf.WriteString(fmt.Sprintf("\t%s %s = %q\n", enumName, typeName, enumVal))
			}
			buf.WriteString(")\n")
		} else {
			// Type alias for string with format
			goType := stringFormatToGoType(schema.Format)
			buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))
		}

	case "integer":
		goType := integerFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "number":
		goType := numberFormatToGoType(schema.Format)
		buf.WriteString(fmt.Sprintf("type %s = %s\n", typeName, goType))

	case "boolean":
		buf.WriteString(fmt.Sprintf("type %s = bool\n", typeName))

	default:
		// Handle allOf, oneOf, anyOf
		if len(schema.AllOf) > 0 {
			return cg.generateAllOfType(typeName, schema)
		}
		if len(schema.OneOf) > 0 || len(schema.AnyOf) > 0 {
			return cg.generateUnionType(typeName, schema)
		}
		// Default to any
		buf.WriteString(fmt.Sprintf("type %s = any\n", typeName))
	}

	return buf.String(), nil
}

// generateAllOfType generates a type for allOf composition
func (cg *oas3CodeGenerator) generateAllOfType(typeName string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("// %s combines multiple schemas.\n", typeName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	for _, subSchema := range schema.AllOf {
		if subSchema.Ref != "" {
			refType := cg.resolveRef(subSchema.Ref)
			buf.WriteString(fmt.Sprintf("\t%s\n", refType))
		} else if subSchema.Properties != nil {
			// Inline properties
			var propNames []string
			for propName := range subSchema.Properties {
				propNames = append(propNames, propName)
			}
			sort.Strings(propNames)

			for _, propName := range propNames {
				propSchema := subSchema.Properties[propName]
				if propSchema == nil {
					continue
				}
				goType := cg.schemaToGoType(propSchema, isRequired(subSchema.Required, propName))
				fieldName := toFieldName(propName)
				jsonTag := propName
				if !isRequired(subSchema.Required, propName) {
					jsonTag += ",omitempty"
				}
				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, jsonTag))
			}
		}
	}

	buf.WriteString("}\n")
	return buf.String(), nil
}

// generateUnionType generates a type for oneOf/anyOf (union types)
func (cg *oas3CodeGenerator) generateUnionType(typeName string, schema *parser.Schema) (string, error) {
	var buf bytes.Buffer

	schemas := schema.OneOf
	if len(schemas) == 0 {
		schemas = schema.AnyOf
	}

	buf.WriteString(fmt.Sprintf("// %s represents a union type.\n", typeName))
	buf.WriteString("// Only one of the fields should be set.\n")
	buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	for i, subSchema := range schemas {
		if subSchema.Ref != "" {
			refType := cg.resolveRef(subSchema.Ref)
			buf.WriteString(fmt.Sprintf("\t%s *%s\n", refType, refType))
		} else {
			buf.WriteString(fmt.Sprintf("\tVariant%d any `json:\"-\"`\n", i))
		}
	}

	buf.WriteString("}\n")

	cg.addIssue("components.schemas."+typeName, "union types (oneOf/anyOf) are generated as structs with pointer fields", SeverityInfo)

	return buf.String(), nil
}

// schemaToGoType converts a schema to a Go type string
func (cg *oas3CodeGenerator) schemaToGoType(schema *parser.Schema, required bool) string {
	if schema == nil {
		return "any"
	}

	// Handle $ref
	if schema.Ref != "" {
		refType := cg.resolveRef(schema.Ref)
		if !required && cg.g.UsePointers {
			return "*" + refType
		}
		return refType
	}

	schemaType := getSchemaType(schema)
	var goType string

	switch schemaType {
	case "string":
		goType = stringFormatToGoType(schema.Format)
	case "integer":
		goType = integerFormatToGoType(schema.Format)
	case "number":
		goType = numberFormatToGoType(schema.Format)
	case "boolean":
		goType = "bool"
	case "array":
		itemType := "any"
		if schema.Items != nil {
			if itemSchema, ok := schema.Items.(*parser.Schema); ok {
				itemType = cg.schemaToGoType(itemSchema, true)
			}
		}
		goType = "[]" + itemType
	case "object":
		if schema.Properties == nil && schema.AdditionalProperties != nil {
			// Map type
			valueType := "any"
			if addProps, ok := schema.AdditionalProperties.(*parser.Schema); ok {
				valueType = cg.schemaToGoType(addProps, true)
			}
			goType = "map[string]" + valueType
		} else {
			goType = "map[string]any"
		}
	default:
		goType = "any"
	}

	// Handle nullable (OAS 3.0) or type array with null (OAS 3.1+)
	isNullable := schema.Nullable || isTypeNullable(schema.Type)
	if !required && cg.g.UsePointers && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
		return "*" + goType
	}
	if isNullable && cg.g.UsePointers && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") && !strings.HasPrefix(goType, "*") {
		return "*" + goType
	}

	return goType
}

// resolveRef resolves a $ref to a Go type name
func (cg *oas3CodeGenerator) resolveRef(ref string) string {
	if typeName, ok := cg.schemaNames[ref]; ok {
		return typeName
	}
	// Extract name from ref path
	parts := strings.Split(ref, "/")
	if len(parts) > 0 {
		return toTypeName(parts[len(parts)-1])
	}
	return "any"
}

// addIssue adds a generation issue
func (cg *oas3CodeGenerator) addIssue(path, message string, severity Severity) {
	cg.result.Issues = append(cg.result.Issues, GenerateIssue{
		Path:     path,
		Message:  message,
		Severity: severity,
	})
}

// generateClient generates HTTP client code
func (cg *oas3CodeGenerator) generateClient() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString(")\n\n")

	// Write client struct
	buf.WriteString("// Client is the API client.\n")
	buf.WriteString("type Client struct {\n")
	buf.WriteString("\t// BaseURL is the base URL for API requests.\n")
	buf.WriteString("\tBaseURL string\n")
	buf.WriteString("\t// HTTPClient is the HTTP client to use for requests.\n")
	buf.WriteString("\tHTTPClient *http.Client\n")
	buf.WriteString("\t// RequestEditors are functions that can modify requests before sending.\n")
	buf.WriteString("\tRequestEditors []RequestEditorFn\n")
	buf.WriteString("}\n\n")

	// Write types
	buf.WriteString("// RequestEditorFn is a function that can modify an HTTP request.\n")
	buf.WriteString("type RequestEditorFn func(ctx context.Context, req *http.Request) error\n\n")

	buf.WriteString("// ClientOption is a function that configures a Client.\n")
	buf.WriteString("type ClientOption func(*Client) error\n\n")

	// Write constructor
	buf.WriteString("// NewClient creates a new API client.\n")
	buf.WriteString("func NewClient(baseURL string, opts ...ClientOption) (*Client, error) {\n")
	buf.WriteString("\tc := &Client{\n")
	buf.WriteString("\t\tBaseURL:    strings.TrimSuffix(baseURL, \"/\"),\n")
	buf.WriteString("\t\tHTTPClient: http.DefaultClient,\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tfor _, opt := range opts {\n")
	buf.WriteString("\t\tif err := opt(c); err != nil {\n")
	buf.WriteString("\t\t\treturn nil, err\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn c, nil\n")
	buf.WriteString("}\n\n")

	// Write client options
	buf.WriteString("// WithHTTPClient sets the HTTP client.\n")
	buf.WriteString("func WithHTTPClient(client *http.Client) ClientOption {\n")
	buf.WriteString("\treturn func(c *Client) error {\n")
	buf.WriteString("\t\tc.HTTPClient = client\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// WithRequestEditor adds a request editor function.\n")
	buf.WriteString("func WithRequestEditor(fn RequestEditorFn) ClientOption {\n")
	buf.WriteString("\treturn func(c *Client) error {\n")
	buf.WriteString("\t\tc.RequestEditors = append(c.RequestEditors, fn)\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Generate methods for each operation
	if cg.doc.Paths != nil {
		// Sort paths for deterministic output
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, cg.doc.OASVersion)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				code, err := cg.generateClientMethod(path, method, op)
				if err != nil {
					cg.addIssue(fmt.Sprintf("paths.%s.%s", path, method), fmt.Sprintf("failed to generate client method: %v", err), SeverityWarning)
					continue
				}
				buf.WriteString(code)
				cg.result.GeneratedOperations++
			}
		}
	}

	// Write helper functions
	buf.WriteString(clientHelpers)

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		cg.addIssue("client.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "client.go",
		Content: formatted,
	})

	return nil
}

// generateClientMethod generates a client method for an operation
//
//nolint:unparam // error return kept for API consistency with interface requirements
func (cg *oas3CodeGenerator) generateClientMethod(path, method string, op *parser.Operation) (string, error) {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)

	// Build parameter list
	var params []string
	params = append(params, "ctx context.Context")

	// Path parameters
	var pathParams []pathParam
	for _, param := range op.Parameters {
		if param != nil && param.In == parser.ParamInPath {
			goType := cg.paramToGoType(param)
			paramName := toParamName(param.Name)
			params = append(params, fmt.Sprintf("%s %s", paramName, goType))
			pathParams = append(pathParams, pathParam{name: param.Name, varName: paramName})
		}
	}

	// Query parameters - group into params struct if many
	var queryParams []*parser.Parameter
	for _, param := range op.Parameters {
		if param != nil && param.In == parser.ParamInQuery {
			queryParams = append(queryParams, param)
		}
	}
	if len(queryParams) > 0 {
		params = append(params, "params *"+methodName+"Params")
	}

	// Request body
	hasBody := op.RequestBody != nil
	if hasBody {
		bodyType := cg.getRequestBodyType(op.RequestBody)
		params = append(params, "body "+bodyType)
	}

	// Write method documentation
	if op.Summary != "" {
		buf.WriteString(fmt.Sprintf("// %s %s\n", methodName, op.Summary))
	} else if op.Description != "" {
		buf.WriteString(fmt.Sprintf("// %s %s\n", methodName, cleanDescription(op.Description)))
	} else {
		buf.WriteString(fmt.Sprintf("// %s calls %s %s\n", methodName, strings.ToUpper(method), path))
	}
	if op.Deprecated {
		buf.WriteString("// Deprecated: This operation is deprecated.\n")
	}

	// Write method signature
	responseType := cg.getResponseType(op)
	buf.WriteString(fmt.Sprintf("func (c *Client) %s(%s) (%s, error) {\n", methodName, strings.Join(params, ", "), responseType))

	// Build URL
	buf.WriteString("\tpath := ")
	if len(pathParams) > 0 {
		buf.WriteString("fmt.Sprintf(\"")
		pathTemplate := path
		for _, pp := range pathParams {
			pathTemplate = strings.ReplaceAll(pathTemplate, "{"+pp.name+"}", "%v")
		}
		buf.WriteString(pathTemplate)
		buf.WriteString("\"")
		for _, pp := range pathParams {
			buf.WriteString(", " + pp.varName)
		}
		buf.WriteString(")\n")
	} else {
		buf.WriteString(fmt.Sprintf("%q\n", path))
	}

	// Build query string
	if len(queryParams) > 0 {
		buf.WriteString("\tquery := make(url.Values)\n")
		buf.WriteString("\tif params != nil {\n")
		for _, param := range queryParams {
			paramName := toFieldName(param.Name)
			if param.Required {
				buf.WriteString(fmt.Sprintf("\t\tquery.Set(%q, fmt.Sprintf(\"%%v\", params.%s))\n", param.Name, paramName))
			} else {
				buf.WriteString(fmt.Sprintf("\t\tif params.%s != nil {\n", paramName))
				buf.WriteString(fmt.Sprintf("\t\t\tquery.Set(%q, fmt.Sprintf(\"%%v\", *params.%s))\n", param.Name, paramName))
				buf.WriteString("\t\t}\n")
			}
		}
		buf.WriteString("\t}\n")
		buf.WriteString("\tif len(query) > 0 {\n")
		buf.WriteString("\t\tpath += \"?\" + query.Encode()\n")
		buf.WriteString("\t}\n")
	}

	// Create request
	if hasBody {
		buf.WriteString("\tbodyData, err := json.Marshal(body)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"marshal request body: %%w\", err)\n", zeroValue(responseType)))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, %q, c.BaseURL+path, bytes.NewReader(bodyData))\n", strings.ToUpper(method)))
	} else {
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, %q, c.BaseURL+path, nil)\n", strings.ToUpper(method)))
	}
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"create request: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")

	// Set content type for requests with body
	if hasBody {
		buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}
	buf.WriteString("\treq.Header.Set(\"Accept\", \"application/json\")\n")

	// Apply request editors
	buf.WriteString("\tfor _, editor := range c.RequestEditors {\n")
	buf.WriteString("\t\tif err := editor(ctx, req); err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\t\treturn %s, fmt.Errorf(\"request editor: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")

	// Execute request
	buf.WriteString("\tresp, err := c.HTTPClient.Do(req)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"execute request: %%w\", err)\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer resp.Body.Close()\n")

	// Handle response
	buf.WriteString("\tif resp.StatusCode >= 400 {\n")
	buf.WriteString("\t\tbody, _ := io.ReadAll(resp.Body)\n")
	buf.WriteString(fmt.Sprintf("\t\treturn %s, &APIError{StatusCode: resp.StatusCode, Body: body}\n", zeroValue(responseType)))
	buf.WriteString("\t}\n")

	// Parse response body
	if responseType != "" && responseType != "*http.Response" {
		if strings.HasPrefix(responseType, "*") {
			buf.WriteString(fmt.Sprintf("\tvar result %s\n", responseType[1:]))
			buf.WriteString("\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"decode response: %%w\", err)\n", zeroValue(responseType)))
			buf.WriteString("\t}\n")
			buf.WriteString("\treturn &result, nil\n")
		} else {
			buf.WriteString(fmt.Sprintf("\tvar result %s\n", responseType))
			buf.WriteString("\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n")
			buf.WriteString(fmt.Sprintf("\t\treturn %s, fmt.Errorf(\"decode response: %%w\", err)\n", zeroValue(responseType)))
			buf.WriteString("\t}\n")
			buf.WriteString("\treturn result, nil\n")
		}
	} else {
		buf.WriteString("\treturn resp, nil\n")
	}

	buf.WriteString("}\n\n")

	// Generate params struct if needed
	if len(queryParams) > 0 {
		buf.WriteString(fmt.Sprintf("// %sParams contains query parameters for %s.\n", methodName, methodName))
		buf.WriteString(fmt.Sprintf("type %sParams struct {\n", methodName))
		for _, param := range queryParams {
			goType := cg.paramToGoType(param)
			fieldName := toFieldName(param.Name)
			if param.Description != "" {
				buf.WriteString(fmt.Sprintf("\t// %s\n", cleanDescription(param.Description)))
			}
			if !param.Required {
				buf.WriteString(fmt.Sprintf("\t%s *%s `json:%q`\n", fieldName, goType, param.Name+",omitempty"))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %s `json:%q`\n", fieldName, goType, param.Name))
			}
		}
		buf.WriteString("}\n\n")
	}

	return buf.String(), nil
}

type pathParam struct {
	name    string
	varName string
}

// paramToGoType converts a parameter to its Go type
func (cg *oas3CodeGenerator) paramToGoType(param *parser.Parameter) string {
	if param.Schema != nil {
		return cg.schemaToGoType(param.Schema, param.Required)
	}
	// Fallback for OAS 2.0 style parameters
	switch param.Type {
	case "string":
		return stringFormatToGoType(param.Format)
	case "integer":
		return integerFormatToGoType(param.Format)
	case "number":
		return numberFormatToGoType(param.Format)
	case "boolean":
		return "bool"
	case "array":
		return "[]string"
	default:
		return "string"
	}
}

// getRequestBodyType determines the Go type for a request body
func (cg *oas3CodeGenerator) getRequestBodyType(rb *parser.RequestBody) string {
	if rb == nil {
		return "any"
	}
	// Look for JSON content type
	for contentType, mediaType := range rb.Content {
		if strings.Contains(contentType, "json") && mediaType != nil && mediaType.Schema != nil {
			return cg.schemaToGoType(mediaType.Schema, true)
		}
	}
	return "any"
}

// getResponseType determines the Go type for the success response
func (cg *oas3CodeGenerator) getResponseType(op *parser.Operation) string {
	if op.Responses == nil {
		return "*http.Response"
	}

	// Check for 200, 201, 2XX responses
	for _, code := range []string{"200", "201", "2XX"} {
		if resp := op.Responses.Codes[code]; resp != nil {
			for contentType, mediaType := range resp.Content {
				if strings.Contains(contentType, "json") && mediaType != nil && mediaType.Schema != nil {
					goType := cg.schemaToGoType(mediaType.Schema, true)
					if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
						return "*" + goType
					}
					return goType
				}
			}
		}
	}

	// Check default response
	if op.Responses.Default != nil {
		for contentType, mediaType := range op.Responses.Default.Content {
			if strings.Contains(contentType, "json") && mediaType != nil && mediaType.Schema != nil {
				goType := cg.schemaToGoType(mediaType.Schema, true)
				if !strings.HasPrefix(goType, "*") && !strings.HasPrefix(goType, "[]") && !strings.HasPrefix(goType, "map") {
					return "*" + goType
				}
				return goType
			}
		}
	}

	return "*http.Response"
}

// generateServer generates server interface code
func (cg *oas3CodeGenerator) generateServer() error {
	var buf bytes.Buffer

	// Write header
	buf.WriteString("// Code generated by oastools. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cg.result.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString(")\n\n")

	// Generate server interface
	buf.WriteString("// ServerInterface represents the server API.\n")
	buf.WriteString("type ServerInterface interface {\n")

	if cg.doc.Paths != nil {
		// Sort paths for deterministic output
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, cg.doc.OASVersion)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				sig := cg.generateServerMethodSignature(path, method, op)
				buf.WriteString(sig)
			}
		}
	}

	buf.WriteString("}\n\n")

	// Generate request types
	for _, path := range func() []string {
		var keys []string
		if cg.doc.Paths != nil {
			for k := range cg.doc.Paths {
				keys = append(keys, k)
			}
		}
		sort.Strings(keys)
		return keys
	}() {
		pathItem := cg.doc.Paths[path]
		if pathItem == nil {
			continue
		}

		operations := parser.GetOperations(pathItem, cg.doc.OASVersion)
		for _, method := range httpMethods {
			op := operations[method]
			if op == nil {
				continue
			}

			reqType := cg.generateRequestType(path, method, op)
			if reqType != "" {
				buf.WriteString(reqType)
			}
		}
	}

	// Write unimplemented server
	buf.WriteString("// UnimplementedServer provides default implementations that return errors.\n")
	buf.WriteString("type UnimplementedServer struct{}\n\n")

	// Generate unimplemented methods
	if cg.doc.Paths != nil {
		var pathKeys []string
		for path := range cg.doc.Paths {
			pathKeys = append(pathKeys, path)
		}
		sort.Strings(pathKeys)

		for _, path := range pathKeys {
			pathItem := cg.doc.Paths[path]
			if pathItem == nil {
				continue
			}

			operations := parser.GetOperations(pathItem, cg.doc.OASVersion)
			for _, method := range httpMethods {
				op := operations[method]
				if op == nil {
					continue
				}

				methodName := operationToMethodName(op, path, method)
				responseType := cg.getResponseType(op)

				buf.WriteString(fmt.Sprintf("func (s *UnimplementedServer) %s(ctx context.Context, req *%sRequest) (%s, error) {\n",
					methodName, methodName, responseType))
				buf.WriteString(fmt.Sprintf("\treturn %s, ErrNotImplemented\n", zeroValue(responseType)))
				buf.WriteString("}\n\n")
			}
		}
	}

	// Write error type
	buf.WriteString("// ErrNotImplemented is returned by UnimplementedServer methods.\n")
	buf.WriteString("var ErrNotImplemented = &NotImplementedError{}\n\n")
	buf.WriteString("// NotImplementedError indicates an operation is not implemented.\n")
	buf.WriteString("type NotImplementedError struct{}\n\n")
	buf.WriteString("func (e *NotImplementedError) Error() string { return \"not implemented\" }\n\n")

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		cg.addIssue("server.go", fmt.Sprintf("failed to format generated code: %v", err), SeverityWarning)
		formatted = buf.Bytes()
	}

	cg.result.Files = append(cg.result.Files, GeneratedFile{
		Name:    "server.go",
		Content: formatted,
	})

	return nil
}

// generateServerMethodSignature generates the interface method signature
func (cg *oas3CodeGenerator) generateServerMethodSignature(path, method string, op *parser.Operation) string {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)
	responseType := cg.getResponseType(op)

	// Write comment
	if op.Summary != "" {
		buf.WriteString(fmt.Sprintf("\t// %s %s\n", methodName, op.Summary))
	}
	if op.Deprecated {
		buf.WriteString("\t// Deprecated: This operation is deprecated.\n")
	}

	buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, req *%sRequest) (%s, error)\n", methodName, methodName, responseType))

	return buf.String()
}

// generateRequestType generates a request struct for an operation
func (cg *oas3CodeGenerator) generateRequestType(path, method string, op *parser.Operation) string {
	var buf bytes.Buffer

	methodName := operationToMethodName(op, path, method)

	buf.WriteString(fmt.Sprintf("// %sRequest contains the request data for %s.\n", methodName, methodName))
	buf.WriteString(fmt.Sprintf("type %sRequest struct {\n", methodName))

	// Path parameters
	for _, param := range op.Parameters {
		if param != nil && param.In == parser.ParamInPath {
			goType := cg.paramToGoType(param)
			fieldName := toFieldName(param.Name)
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
	}

	// Query parameters
	for _, param := range op.Parameters {
		if param != nil && param.In == parser.ParamInQuery {
			goType := cg.paramToGoType(param)
			fieldName := toFieldName(param.Name)
			if !param.Required {
				buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
			}
		}
	}

	// Header parameters
	for _, param := range op.Parameters {
		if param != nil && param.In == parser.ParamInHeader {
			goType := cg.paramToGoType(param)
			fieldName := toFieldName(param.Name)
			if !param.Required {
				buf.WriteString(fmt.Sprintf("\t%s *%s\n", fieldName, goType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
			}
		}
	}

	// Request body
	if op.RequestBody != nil {
		bodyType := cg.getRequestBodyType(op.RequestBody)
		buf.WriteString(fmt.Sprintf("\tBody %s\n", bodyType))
	}

	// HTTP request
	buf.WriteString("\tHTTPRequest *http.Request\n")

	buf.WriteString("}\n\n")

	return buf.String()
}

// httpMethods returns all HTTP methods in a consistent order
var httpMethods = []string{
	httputil.MethodGet,
	httputil.MethodPut,
	httputil.MethodPost,
	httputil.MethodDelete,
	httputil.MethodOptions,
	httputil.MethodHead,
	httputil.MethodPatch,
	httputil.MethodTrace,
	httputil.MethodQuery,
}

// Helper constants
const clientHelpers = `
// APIError represents an API error response.
type APIError struct {
	StatusCode int
	Body       []byte
}

func (e *APIError) Error() string {
	return fmt.Sprintf("API error: status %d: %s", e.StatusCode, string(e.Body))
}

// Ensure unused imports don't cause errors
var (
	_ = bytes.NewReader
	_ = context.Background
	_ = json.Marshal
	_ = fmt.Sprintf
	_ = io.ReadAll
	_ = http.NewRequest
	_ = url.Values{}
	_ = strings.TrimSpace
)
`

// Helper functions

func toTypeName(s string) string {
	// Convert to PascalCase and ensure valid Go identifier
	s = strings.ReplaceAll(s, "-", " ")
	s = strings.ReplaceAll(s, "_", " ")
	s = strings.ReplaceAll(s, ".", " ")

	words := strings.Fields(s)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[:1]) + word[1:]
		}
	}

	result := strings.Join(words, "")
	if len(result) == 0 {
		return "Type"
	}

	// Ensure first character is a letter
	if !unicode.IsLetter(rune(result[0])) {
		result = "T" + result
	}

	return result
}

func toFieldName(s string) string {
	// Convert to PascalCase for exported fields
	return toTypeName(s)
}

func toParamName(s string) string {
	// Convert to camelCase for parameters
	name := toTypeName(s)
	if len(name) > 0 {
		return strings.ToLower(name[:1]) + name[1:]
	}
	return "param"
}

func operationToMethodName(op *parser.Operation, path, method string) string {
	if op.OperationID != "" {
		return toTypeName(op.OperationID)
	}
	// Generate from path and method
	pathPart := path
	pathPart = strings.ReplaceAll(pathPart, "/", " ")
	pathPart = strings.ReplaceAll(pathPart, "{", "By ")
	pathPart = strings.ReplaceAll(pathPart, "}", "")
	return toTypeName(method + " " + pathPart)
}

func cleanDescription(s string) string {
	// Clean up description for Go comments
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.TrimSpace(s)
	if len(s) > 200 {
		s = s[:197] + "..."
	}
	return s
}

func getSchemaType(schema *parser.Schema) string {
	if schema == nil {
		return ""
	}

	switch t := schema.Type.(type) {
	case string:
		return t
	case []any:
		// OAS 3.1+ type array
		for _, v := range t {
			if str, ok := v.(string); ok && str != "null" {
				return str
			}
		}
	}

	// Infer type from other fields
	if schema.Properties != nil {
		return "object"
	}
	if schema.Items != nil {
		return "array"
	}
	if len(schema.Enum) > 0 {
		return "string"
	}

	return ""
}

func isTypeNullable(t any) bool {
	if arr, ok := t.([]any); ok {
		for _, v := range arr {
			if str, ok := v.(string); ok && str == "null" {
				return true
			}
		}
	}
	return false
}

func isRequired(required []string, name string) bool {
	for _, r := range required {
		if r == name {
			return true
		}
	}
	return false
}

func stringFormatToGoType(format string) string {
	switch format {
	case "date-time":
		return "time.Time"
	case "date":
		return "string" // Could use time.Time with custom parsing
	case "time":
		return "string"
	case "byte":
		return "[]byte"
	case "binary":
		return "[]byte"
	default:
		return "string"
	}
}

func integerFormatToGoType(format string) string {
	switch format {
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	default:
		return "int64"
	}
}

func numberFormatToGoType(format string) string {
	switch format {
	case "float":
		return "float32"
	case "double":
		return "float64"
	default:
		return "float64"
	}
}

func needsTimeImport(schema *parser.Schema) bool {
	if schema == nil {
		return false
	}

	schemaType := getSchemaType(schema)
	if schemaType == "string" && schema.Format == "date-time" {
		return true
	}

	// Check properties
	for _, prop := range schema.Properties {
		if needsTimeImport(prop) {
			return true
		}
	}

	// Check items
	if items, ok := schema.Items.(*parser.Schema); ok {
		if needsTimeImport(items) {
			return true
		}
	}

	return false
}

func zeroValue(t string) string {
	if t == "" || t == "*http.Response" {
		return "nil"
	}
	if strings.HasPrefix(t, "*") || strings.HasPrefix(t, "[]") || strings.HasPrefix(t, "map") {
		return "nil"
	}
	return t + "{}"
}
