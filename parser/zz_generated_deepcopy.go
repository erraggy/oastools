// Code generated by internal/codegen/deepcopy; DO NOT EDIT.
//
// This file contains DeepCopy methods for parser package types.
// These methods provide type-aware deep copying that properly handles:
// - Pointer fields (deep copy the pointed value)
// - Slice fields (create new slice and copy elements)
// - Map fields (create new map and copy entries)
// - OAS-typed polymorphic fields (any/interface{} with known types)

package parser

// DeepCopy creates a deep copy of Components.
func (in *Components) DeepCopy() *Components {
	if in == nil {
		return nil
	}
	out := new(Components)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Components into out.
func (in *Components) DeepCopyInto(out *Components) {
	*out = *in

	if in.Schemas != nil {
		out.Schemas = make(map[string]*Schema, len(in.Schemas))
		for k, v := range in.Schemas {
			if v != nil {
				out.Schemas[k] = v.DeepCopy()
			}
		}
	}

	if in.Responses != nil {
		out.Responses = make(map[string]*Response, len(in.Responses))
		for k, v := range in.Responses {
			if v != nil {
				out.Responses[k] = v.DeepCopy()
			}
		}
	}

	if in.Parameters != nil {
		out.Parameters = make(map[string]*Parameter, len(in.Parameters))
		for k, v := range in.Parameters {
			if v != nil {
				out.Parameters[k] = v.DeepCopy()
			}
		}
	}

	if in.Examples != nil {
		out.Examples = make(map[string]*Example, len(in.Examples))
		for k, v := range in.Examples {
			if v != nil {
				out.Examples[k] = v.DeepCopy()
			}
		}
	}

	if in.RequestBodies != nil {
		out.RequestBodies = make(map[string]*RequestBody, len(in.RequestBodies))
		for k, v := range in.RequestBodies {
			if v != nil {
				out.RequestBodies[k] = v.DeepCopy()
			}
		}
	}

	if in.Headers != nil {
		out.Headers = make(map[string]*Header, len(in.Headers))
		for k, v := range in.Headers {
			if v != nil {
				out.Headers[k] = v.DeepCopy()
			}
		}
	}

	if in.SecuritySchemes != nil {
		out.SecuritySchemes = make(map[string]*SecurityScheme, len(in.SecuritySchemes))
		for k, v := range in.SecuritySchemes {
			if v != nil {
				out.SecuritySchemes[k] = v.DeepCopy()
			}
		}
	}

	if in.Links != nil {
		out.Links = make(map[string]*Link, len(in.Links))
		for k, v := range in.Links {
			if v != nil {
				out.Links[k] = v.DeepCopy()
			}
		}
	}

	out.Callbacks = deepCopyCallbacks(in.Callbacks)

	if in.PathItems != nil {
		out.PathItems = make(map[string]*PathItem, len(in.PathItems))
		for k, v := range in.PathItems {
			if v != nil {
				out.PathItems[k] = v.DeepCopy()
			}
		}
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Contact.
func (in *Contact) DeepCopy() *Contact {
	if in == nil {
		return nil
	}
	out := new(Contact)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Contact into out.
func (in *Contact) DeepCopyInto(out *Contact) {
	*out = *in

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Discriminator.
func (in *Discriminator) DeepCopy() *Discriminator {
	if in == nil {
		return nil
	}
	out := new(Discriminator)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Discriminator into out.
func (in *Discriminator) DeepCopyInto(out *Discriminator) {
	*out = *in

	out.Mapping = deepCopyStringMap(in.Mapping)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Encoding.
func (in *Encoding) DeepCopy() *Encoding {
	if in == nil {
		return nil
	}
	out := new(Encoding)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Encoding into out.
func (in *Encoding) DeepCopyInto(out *Encoding) {
	*out = *in

	if in.Headers != nil {
		out.Headers = make(map[string]*Header, len(in.Headers))
		for k, v := range in.Headers {
			if v != nil {
				out.Headers[k] = v.DeepCopy()
			}
		}
	}

	if in.Explode != nil {
		out.Explode = new(bool)
		*out.Explode = *in.Explode
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Example.
func (in *Example) DeepCopy() *Example {
	if in == nil {
		return nil
	}
	out := new(Example)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Example into out.
func (in *Example) DeepCopyInto(out *Example) {
	*out = *in

	out.Value = deepCopyJSONValue(in.Value)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of ExternalDocs.
func (in *ExternalDocs) DeepCopy() *ExternalDocs {
	if in == nil {
		return nil
	}
	out := new(ExternalDocs)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies ExternalDocs into out.
func (in *ExternalDocs) DeepCopyInto(out *ExternalDocs) {
	*out = *in

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Header.
func (in *Header) DeepCopy() *Header {
	if in == nil {
		return nil
	}
	out := new(Header)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Header into out.
func (in *Header) DeepCopyInto(out *Header) {
	*out = *in

	if in.Explode != nil {
		out.Explode = new(bool)
		*out.Explode = *in.Explode
	}

	if in.Schema != nil {
		out.Schema = in.Schema.DeepCopy()
	}

	out.Example = deepCopyJSONValue(in.Example)

	if in.Examples != nil {
		out.Examples = make(map[string]*Example, len(in.Examples))
		for k, v := range in.Examples {
			if v != nil {
				out.Examples[k] = v.DeepCopy()
			}
		}
	}

	if in.Content != nil {
		out.Content = make(map[string]*MediaType, len(in.Content))
		for k, v := range in.Content {
			if v != nil {
				out.Content[k] = v.DeepCopy()
			}
		}
	}

	if in.Items != nil {
		out.Items = in.Items.DeepCopy()
	}

	out.Default = deepCopyJSONValue(in.Default)

	if in.Maximum != nil {
		out.Maximum = new(float64)
		*out.Maximum = *in.Maximum
	}

	if in.Minimum != nil {
		out.Minimum = new(float64)
		*out.Minimum = *in.Minimum
	}

	if in.MaxLength != nil {
		out.MaxLength = new(int)
		*out.MaxLength = *in.MaxLength
	}

	if in.MinLength != nil {
		out.MinLength = new(int)
		*out.MinLength = *in.MinLength
	}

	if in.MaxItems != nil {
		out.MaxItems = new(int)
		*out.MaxItems = *in.MaxItems
	}

	if in.MinItems != nil {
		out.MinItems = new(int)
		*out.MinItems = *in.MinItems
	}

	out.Enum = deepCopyEnumSlice(in.Enum)

	if in.MultipleOf != nil {
		out.MultipleOf = new(float64)
		*out.MultipleOf = *in.MultipleOf
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Info.
func (in *Info) DeepCopy() *Info {
	if in == nil {
		return nil
	}
	out := new(Info)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Info into out.
func (in *Info) DeepCopyInto(out *Info) {
	*out = *in

	if in.Contact != nil {
		out.Contact = in.Contact.DeepCopy()
	}

	if in.License != nil {
		out.License = in.License.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Items.
func (in *Items) DeepCopy() *Items {
	if in == nil {
		return nil
	}
	out := new(Items)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Items into out.
func (in *Items) DeepCopyInto(out *Items) {
	*out = *in

	if in.Items != nil {
		out.Items = in.Items.DeepCopy()
	}

	out.Default = deepCopyJSONValue(in.Default)

	if in.Maximum != nil {
		out.Maximum = new(float64)
		*out.Maximum = *in.Maximum
	}

	if in.Minimum != nil {
		out.Minimum = new(float64)
		*out.Minimum = *in.Minimum
	}

	if in.MaxLength != nil {
		out.MaxLength = new(int)
		*out.MaxLength = *in.MaxLength
	}

	if in.MinLength != nil {
		out.MinLength = new(int)
		*out.MinLength = *in.MinLength
	}

	if in.MaxItems != nil {
		out.MaxItems = new(int)
		*out.MaxItems = *in.MaxItems
	}

	if in.MinItems != nil {
		out.MinItems = new(int)
		*out.MinItems = *in.MinItems
	}

	out.Enum = deepCopyEnumSlice(in.Enum)

	if in.MultipleOf != nil {
		out.MultipleOf = new(float64)
		*out.MultipleOf = *in.MultipleOf
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of License.
func (in *License) DeepCopy() *License {
	if in == nil {
		return nil
	}
	out := new(License)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies License into out.
func (in *License) DeepCopyInto(out *License) {
	*out = *in

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Link.
func (in *Link) DeepCopy() *Link {
	if in == nil {
		return nil
	}
	out := new(Link)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Link into out.
func (in *Link) DeepCopyInto(out *Link) {
	*out = *in

	out.Parameters = deepCopyExtensions(in.Parameters)

	out.RequestBody = deepCopyJSONValue(in.RequestBody)

	if in.Server != nil {
		out.Server = in.Server.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of MediaType.
func (in *MediaType) DeepCopy() *MediaType {
	if in == nil {
		return nil
	}
	out := new(MediaType)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies MediaType into out.
func (in *MediaType) DeepCopyInto(out *MediaType) {
	*out = *in

	if in.Schema != nil {
		out.Schema = in.Schema.DeepCopy()
	}

	out.Example = deepCopyJSONValue(in.Example)

	if in.Examples != nil {
		out.Examples = make(map[string]*Example, len(in.Examples))
		for k, v := range in.Examples {
			if v != nil {
				out.Examples[k] = v.DeepCopy()
			}
		}
	}

	if in.Encoding != nil {
		out.Encoding = make(map[string]*Encoding, len(in.Encoding))
		for k, v := range in.Encoding {
			if v != nil {
				out.Encoding[k] = v.DeepCopy()
			}
		}
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of OAS2Document.
func (in *OAS2Document) DeepCopy() *OAS2Document {
	if in == nil {
		return nil
	}
	out := new(OAS2Document)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies OAS2Document into out.
func (in *OAS2Document) DeepCopyInto(out *OAS2Document) {
	*out = *in

	if in.Info != nil {
		out.Info = in.Info.DeepCopy()
	}

	if in.Schemes != nil {
		out.Schemes = make([]string, len(in.Schemes))
		copy(out.Schemes, in.Schemes)
	}

	if in.Consumes != nil {
		out.Consumes = make([]string, len(in.Consumes))
		copy(out.Consumes, in.Consumes)
	}

	if in.Produces != nil {
		out.Produces = make([]string, len(in.Produces))
		copy(out.Produces, in.Produces)
	}

	out.Paths = deepCopyPaths(in.Paths)

	if in.Definitions != nil {
		out.Definitions = make(map[string]*Schema, len(in.Definitions))
		for k, v := range in.Definitions {
			if v != nil {
				out.Definitions[k] = v.DeepCopy()
			}
		}
	}

	if in.Parameters != nil {
		out.Parameters = make(map[string]*Parameter, len(in.Parameters))
		for k, v := range in.Parameters {
			if v != nil {
				out.Parameters[k] = v.DeepCopy()
			}
		}
	}

	if in.Responses != nil {
		out.Responses = make(map[string]*Response, len(in.Responses))
		for k, v := range in.Responses {
			if v != nil {
				out.Responses[k] = v.DeepCopy()
			}
		}
	}

	if in.SecurityDefinitions != nil {
		out.SecurityDefinitions = make(map[string]*SecurityScheme, len(in.SecurityDefinitions))
		for k, v := range in.SecurityDefinitions {
			if v != nil {
				out.SecurityDefinitions[k] = v.DeepCopy()
			}
		}
	}

	out.Security = deepCopySecurityRequirements(in.Security)

	if in.Tags != nil {
		out.Tags = make([]*Tag, len(in.Tags))
		for i, v := range in.Tags {
			if v != nil {
				out.Tags[i] = v.DeepCopy()
			}
		}
	}

	if in.ExternalDocs != nil {
		out.ExternalDocs = in.ExternalDocs.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of OAS3Document.
func (in *OAS3Document) DeepCopy() *OAS3Document {
	if in == nil {
		return nil
	}
	out := new(OAS3Document)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies OAS3Document into out.
func (in *OAS3Document) DeepCopyInto(out *OAS3Document) {
	*out = *in

	if in.Info != nil {
		out.Info = in.Info.DeepCopy()
	}

	if in.Servers != nil {
		out.Servers = make([]*Server, len(in.Servers))
		for i, v := range in.Servers {
			if v != nil {
				out.Servers[i] = v.DeepCopy()
			}
		}
	}

	out.Paths = deepCopyPaths(in.Paths)

	if in.Webhooks != nil {
		out.Webhooks = make(map[string]*PathItem, len(in.Webhooks))
		for k, v := range in.Webhooks {
			if v != nil {
				out.Webhooks[k] = v.DeepCopy()
			}
		}
	}

	if in.Components != nil {
		out.Components = in.Components.DeepCopy()
	}

	out.Security = deepCopySecurityRequirements(in.Security)

	if in.Tags != nil {
		out.Tags = make([]*Tag, len(in.Tags))
		for i, v := range in.Tags {
			if v != nil {
				out.Tags[i] = v.DeepCopy()
			}
		}
	}

	if in.ExternalDocs != nil {
		out.ExternalDocs = in.ExternalDocs.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of OAuthFlow.
func (in *OAuthFlow) DeepCopy() *OAuthFlow {
	if in == nil {
		return nil
	}
	out := new(OAuthFlow)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies OAuthFlow into out.
func (in *OAuthFlow) DeepCopyInto(out *OAuthFlow) {
	*out = *in

	out.Scopes = deepCopyStringMap(in.Scopes)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of OAuthFlows.
func (in *OAuthFlows) DeepCopy() *OAuthFlows {
	if in == nil {
		return nil
	}
	out := new(OAuthFlows)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies OAuthFlows into out.
func (in *OAuthFlows) DeepCopyInto(out *OAuthFlows) {
	*out = *in

	if in.Implicit != nil {
		out.Implicit = in.Implicit.DeepCopy()
	}

	if in.Password != nil {
		out.Password = in.Password.DeepCopy()
	}

	if in.ClientCredentials != nil {
		out.ClientCredentials = in.ClientCredentials.DeepCopy()
	}

	if in.AuthorizationCode != nil {
		out.AuthorizationCode = in.AuthorizationCode.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Operation.
func (in *Operation) DeepCopy() *Operation {
	if in == nil {
		return nil
	}
	out := new(Operation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Operation into out.
func (in *Operation) DeepCopyInto(out *Operation) {
	*out = *in

	if in.Tags != nil {
		out.Tags = make([]string, len(in.Tags))
		copy(out.Tags, in.Tags)
	}

	if in.ExternalDocs != nil {
		out.ExternalDocs = in.ExternalDocs.DeepCopy()
	}

	if in.Parameters != nil {
		out.Parameters = make([]*Parameter, len(in.Parameters))
		for i, v := range in.Parameters {
			if v != nil {
				out.Parameters[i] = v.DeepCopy()
			}
		}
	}

	if in.RequestBody != nil {
		out.RequestBody = in.RequestBody.DeepCopy()
	}

	if in.Responses != nil {
		out.Responses = in.Responses.DeepCopy()
	}

	out.Callbacks = deepCopyCallbacks(in.Callbacks)

	out.Security = deepCopySecurityRequirements(in.Security)

	if in.Servers != nil {
		out.Servers = make([]*Server, len(in.Servers))
		for i, v := range in.Servers {
			if v != nil {
				out.Servers[i] = v.DeepCopy()
			}
		}
	}

	if in.Consumes != nil {
		out.Consumes = make([]string, len(in.Consumes))
		copy(out.Consumes, in.Consumes)
	}

	if in.Produces != nil {
		out.Produces = make([]string, len(in.Produces))
		copy(out.Produces, in.Produces)
	}

	if in.Schemes != nil {
		out.Schemes = make([]string, len(in.Schemes))
		copy(out.Schemes, in.Schemes)
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Parameter.
func (in *Parameter) DeepCopy() *Parameter {
	if in == nil {
		return nil
	}
	out := new(Parameter)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Parameter into out.
func (in *Parameter) DeepCopyInto(out *Parameter) {
	*out = *in

	if in.Explode != nil {
		out.Explode = new(bool)
		*out.Explode = *in.Explode
	}

	if in.Schema != nil {
		out.Schema = in.Schema.DeepCopy()
	}

	out.Example = deepCopyJSONValue(in.Example)

	if in.Examples != nil {
		out.Examples = make(map[string]*Example, len(in.Examples))
		for k, v := range in.Examples {
			if v != nil {
				out.Examples[k] = v.DeepCopy()
			}
		}
	}

	if in.Content != nil {
		out.Content = make(map[string]*MediaType, len(in.Content))
		for k, v := range in.Content {
			if v != nil {
				out.Content[k] = v.DeepCopy()
			}
		}
	}

	if in.Items != nil {
		out.Items = in.Items.DeepCopy()
	}

	out.Default = deepCopyJSONValue(in.Default)

	if in.Maximum != nil {
		out.Maximum = new(float64)
		*out.Maximum = *in.Maximum
	}

	if in.Minimum != nil {
		out.Minimum = new(float64)
		*out.Minimum = *in.Minimum
	}

	if in.MaxLength != nil {
		out.MaxLength = new(int)
		*out.MaxLength = *in.MaxLength
	}

	if in.MinLength != nil {
		out.MinLength = new(int)
		*out.MinLength = *in.MinLength
	}

	if in.MaxItems != nil {
		out.MaxItems = new(int)
		*out.MaxItems = *in.MaxItems
	}

	if in.MinItems != nil {
		out.MinItems = new(int)
		*out.MinItems = *in.MinItems
	}

	out.Enum = deepCopyEnumSlice(in.Enum)

	if in.MultipleOf != nil {
		out.MultipleOf = new(float64)
		*out.MultipleOf = *in.MultipleOf
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of PathItem.
func (in *PathItem) DeepCopy() *PathItem {
	if in == nil {
		return nil
	}
	out := new(PathItem)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies PathItem into out.
func (in *PathItem) DeepCopyInto(out *PathItem) {
	*out = *in

	if in.Get != nil {
		out.Get = in.Get.DeepCopy()
	}

	if in.Put != nil {
		out.Put = in.Put.DeepCopy()
	}

	if in.Post != nil {
		out.Post = in.Post.DeepCopy()
	}

	if in.Delete != nil {
		out.Delete = in.Delete.DeepCopy()
	}

	if in.Options != nil {
		out.Options = in.Options.DeepCopy()
	}

	if in.Head != nil {
		out.Head = in.Head.DeepCopy()
	}

	if in.Patch != nil {
		out.Patch = in.Patch.DeepCopy()
	}

	if in.Trace != nil {
		out.Trace = in.Trace.DeepCopy()
	}

	if in.Query != nil {
		out.Query = in.Query.DeepCopy()
	}

	if in.Servers != nil {
		out.Servers = make([]*Server, len(in.Servers))
		for i, v := range in.Servers {
			if v != nil {
				out.Servers[i] = v.DeepCopy()
			}
		}
	}

	if in.Parameters != nil {
		out.Parameters = make([]*Parameter, len(in.Parameters))
		for i, v := range in.Parameters {
			if v != nil {
				out.Parameters[i] = v.DeepCopy()
			}
		}
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Reference.
func (in *Reference) DeepCopy() *Reference {
	if in == nil {
		return nil
	}
	out := new(Reference)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Reference into out.
func (in *Reference) DeepCopyInto(out *Reference) {
	*out = *in

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of RequestBody.
func (in *RequestBody) DeepCopy() *RequestBody {
	if in == nil {
		return nil
	}
	out := new(RequestBody)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies RequestBody into out.
func (in *RequestBody) DeepCopyInto(out *RequestBody) {
	*out = *in

	if in.Content != nil {
		out.Content = make(map[string]*MediaType, len(in.Content))
		for k, v := range in.Content {
			if v != nil {
				out.Content[k] = v.DeepCopy()
			}
		}
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Response.
func (in *Response) DeepCopy() *Response {
	if in == nil {
		return nil
	}
	out := new(Response)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Response into out.
func (in *Response) DeepCopyInto(out *Response) {
	*out = *in

	if in.Headers != nil {
		out.Headers = make(map[string]*Header, len(in.Headers))
		for k, v := range in.Headers {
			if v != nil {
				out.Headers[k] = v.DeepCopy()
			}
		}
	}

	if in.Content != nil {
		out.Content = make(map[string]*MediaType, len(in.Content))
		for k, v := range in.Content {
			if v != nil {
				out.Content[k] = v.DeepCopy()
			}
		}
	}

	if in.Links != nil {
		out.Links = make(map[string]*Link, len(in.Links))
		for k, v := range in.Links {
			if v != nil {
				out.Links[k] = v.DeepCopy()
			}
		}
	}

	if in.Schema != nil {
		out.Schema = in.Schema.DeepCopy()
	}

	out.Examples = deepCopyExtensions(in.Examples)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Responses.
func (in *Responses) DeepCopy() *Responses {
	if in == nil {
		return nil
	}
	out := new(Responses)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Responses into out.
func (in *Responses) DeepCopyInto(out *Responses) {
	*out = *in

	if in.Default != nil {
		out.Default = in.Default.DeepCopy()
	}

	if in.Codes != nil {
		out.Codes = make(map[string]*Response, len(in.Codes))
		for k, v := range in.Codes {
			if v != nil {
				out.Codes[k] = v.DeepCopy()
			}
		}
	}
}

// DeepCopy creates a deep copy of Schema.
func (in *Schema) DeepCopy() *Schema {
	if in == nil {
		return nil
	}
	out := new(Schema)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Schema into out.
func (in *Schema) DeepCopyInto(out *Schema) {
	*out = *in

	out.Type = deepCopySchemaType(in.Type)

	out.Items = deepCopySchemaOrBool(in.Items)

	out.AdditionalProperties = deepCopySchemaOrBool(in.AdditionalProperties)

	out.AdditionalItems = deepCopySchemaOrBool(in.AdditionalItems)

	out.ExclusiveMinimum = deepCopyBoolOrNumber(in.ExclusiveMinimum)

	out.ExclusiveMaximum = deepCopyBoolOrNumber(in.ExclusiveMaximum)

	out.Default = deepCopyJSONValue(in.Default)

	out.Example = deepCopyJSONValue(in.Example)

	out.Const = deepCopyJSONValue(in.Const)

	out.Enum = deepCopyEnumSlice(in.Enum)

	out.Examples = deepCopyEnumSlice(in.Examples)

	if in.MultipleOf != nil {
		out.MultipleOf = new(float64)
		*out.MultipleOf = *in.MultipleOf
	}

	if in.Maximum != nil {
		out.Maximum = new(float64)
		*out.Maximum = *in.Maximum
	}

	if in.Minimum != nil {
		out.Minimum = new(float64)
		*out.Minimum = *in.Minimum
	}

	if in.MaxLength != nil {
		out.MaxLength = new(int)
		*out.MaxLength = *in.MaxLength
	}

	if in.MinLength != nil {
		out.MinLength = new(int)
		*out.MinLength = *in.MinLength
	}

	if in.MaxItems != nil {
		out.MaxItems = new(int)
		*out.MaxItems = *in.MaxItems
	}

	if in.MinItems != nil {
		out.MinItems = new(int)
		*out.MinItems = *in.MinItems
	}

	if in.MaxContains != nil {
		out.MaxContains = new(int)
		*out.MaxContains = *in.MaxContains
	}

	if in.MinContains != nil {
		out.MinContains = new(int)
		*out.MinContains = *in.MinContains
	}

	if in.MaxProperties != nil {
		out.MaxProperties = new(int)
		*out.MaxProperties = *in.MaxProperties
	}

	if in.MinProperties != nil {
		out.MinProperties = new(int)
		*out.MinProperties = *in.MinProperties
	}

	if in.Discriminator != nil {
		out.Discriminator = in.Discriminator.DeepCopy()
	}

	if in.XML != nil {
		out.XML = in.XML.DeepCopy()
	}

	if in.ExternalDocs != nil {
		out.ExternalDocs = in.ExternalDocs.DeepCopy()
	}

	if in.Contains != nil {
		out.Contains = in.Contains.DeepCopy()
	}

	if in.PropertyNames != nil {
		out.PropertyNames = in.PropertyNames.DeepCopy()
	}

	if in.If != nil {
		out.If = in.If.DeepCopy()
	}

	if in.Then != nil {
		out.Then = in.Then.DeepCopy()
	}

	if in.Else != nil {
		out.Else = in.Else.DeepCopy()
	}

	if in.Not != nil {
		out.Not = in.Not.DeepCopy()
	}

	if in.Required != nil {
		out.Required = make([]string, len(in.Required))
		copy(out.Required, in.Required)
	}

	if in.PrefixItems != nil {
		out.PrefixItems = make([]*Schema, len(in.PrefixItems))
		for i, v := range in.PrefixItems {
			if v != nil {
				out.PrefixItems[i] = v.DeepCopy()
			}
		}
	}

	if in.AllOf != nil {
		out.AllOf = make([]*Schema, len(in.AllOf))
		for i, v := range in.AllOf {
			if v != nil {
				out.AllOf[i] = v.DeepCopy()
			}
		}
	}

	if in.AnyOf != nil {
		out.AnyOf = make([]*Schema, len(in.AnyOf))
		for i, v := range in.AnyOf {
			if v != nil {
				out.AnyOf[i] = v.DeepCopy()
			}
		}
	}

	if in.OneOf != nil {
		out.OneOf = make([]*Schema, len(in.OneOf))
		for i, v := range in.OneOf {
			if v != nil {
				out.OneOf[i] = v.DeepCopy()
			}
		}
	}

	if in.Properties != nil {
		out.Properties = make(map[string]*Schema, len(in.Properties))
		for k, v := range in.Properties {
			if v != nil {
				out.Properties[k] = v.DeepCopy()
			}
		}
	}

	if in.PatternProperties != nil {
		out.PatternProperties = make(map[string]*Schema, len(in.PatternProperties))
		for k, v := range in.PatternProperties {
			if v != nil {
				out.PatternProperties[k] = v.DeepCopy()
			}
		}
	}

	out.DependentRequired = deepCopyDependentRequired(in.DependentRequired)

	if in.DependentSchemas != nil {
		out.DependentSchemas = make(map[string]*Schema, len(in.DependentSchemas))
		for k, v := range in.DependentSchemas {
			if v != nil {
				out.DependentSchemas[k] = v.DeepCopy()
			}
		}
	}

	out.Vocabulary = deepCopyVocabulary(in.Vocabulary)

	if in.Defs != nil {
		out.Defs = make(map[string]*Schema, len(in.Defs))
		for k, v := range in.Defs {
			if v != nil {
				out.Defs[k] = v.DeepCopy()
			}
		}
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of SecurityScheme.
func (in *SecurityScheme) DeepCopy() *SecurityScheme {
	if in == nil {
		return nil
	}
	out := new(SecurityScheme)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies SecurityScheme into out.
func (in *SecurityScheme) DeepCopyInto(out *SecurityScheme) {
	*out = *in

	if in.Flows != nil {
		out.Flows = in.Flows.DeepCopy()
	}

	out.Scopes = deepCopyStringMap(in.Scopes)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Server.
func (in *Server) DeepCopy() *Server {
	if in == nil {
		return nil
	}
	out := new(Server)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Server into out.
func (in *Server) DeepCopyInto(out *Server) {
	*out = *in

	out.Variables = deepCopyServerVariables(in.Variables)

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of ServerVariable.
func (in *ServerVariable) DeepCopy() *ServerVariable {
	if in == nil {
		return nil
	}
	out := new(ServerVariable)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies ServerVariable into out.
func (in *ServerVariable) DeepCopyInto(out *ServerVariable) {
	*out = *in

	if in.Enum != nil {
		out.Enum = make([]string, len(in.Enum))
		copy(out.Enum, in.Enum)
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of Tag.
func (in *Tag) DeepCopy() *Tag {
	if in == nil {
		return nil
	}
	out := new(Tag)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies Tag into out.
func (in *Tag) DeepCopyInto(out *Tag) {
	*out = *in

	if in.ExternalDocs != nil {
		out.ExternalDocs = in.ExternalDocs.DeepCopy()
	}

	out.Extra = deepCopyExtensions(in.Extra)
}

// DeepCopy creates a deep copy of XML.
func (in *XML) DeepCopy() *XML {
	if in == nil {
		return nil
	}
	out := new(XML)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto copies XML into out.
func (in *XML) DeepCopyInto(out *XML) {
	*out = *in

	out.Extra = deepCopyExtensions(in.Extra)
}
