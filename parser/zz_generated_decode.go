// Code generated by internal/codegen/decode; DO NOT EDIT.
//
// This file contains decodeFromMap methods for parser package types.
// These methods populate struct fields directly from a map[string]any,
// avoiding the expensive marshal/unmarshal roundtrip used during $ref resolution.

package parser

import "github.com/erraggy/oastools/internal/httputil"

func (x *Components) decodeFromMap(m map[string]any) {
	if sub, ok := m["schemas"].(map[string]any); ok {
		x.Schemas = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.Schemas[k] = elem
			}
		}
	}
	if sub, ok := m["responses"].(map[string]any); ok {
		x.Responses = make(map[string]*Response, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Response)
				elem.decodeFromMap(vm)
				x.Responses[k] = elem
			}
		}
	}
	if sub, ok := m["parameters"].(map[string]any); ok {
		x.Parameters = make(map[string]*Parameter, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Parameter)
				elem.decodeFromMap(vm)
				x.Parameters[k] = elem
			}
		}
	}
	if sub, ok := m["examples"].(map[string]any); ok {
		x.Examples = make(map[string]*Example, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Example)
				elem.decodeFromMap(vm)
				x.Examples[k] = elem
			}
		}
	}
	if sub, ok := m["requestBodies"].(map[string]any); ok {
		x.RequestBodies = make(map[string]*RequestBody, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(RequestBody)
				elem.decodeFromMap(vm)
				x.RequestBodies[k] = elem
			}
		}
	}
	if sub, ok := m["headers"].(map[string]any); ok {
		x.Headers = make(map[string]*Header, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Header)
				elem.decodeFromMap(vm)
				x.Headers[k] = elem
			}
		}
	}
	if sub, ok := m["securitySchemes"].(map[string]any); ok {
		x.SecuritySchemes = make(map[string]*SecurityScheme, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(SecurityScheme)
				elem.decodeFromMap(vm)
				x.SecuritySchemes[k] = elem
			}
		}
	}
	if sub, ok := m["links"].(map[string]any); ok {
		x.Links = make(map[string]*Link, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Link)
				elem.decodeFromMap(vm)
				x.Links[k] = elem
			}
		}
	}
	if sub, ok := m["callbacks"].(map[string]any); ok {
		x.Callbacks = make(map[string]*Callback, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				x.Callbacks[k] = decodeCallback(vm)
			}
		}
	}
	if sub, ok := m["pathItems"].(map[string]any); ok {
		x.PathItems = make(map[string]*PathItem, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(PathItem)
				elem.decodeFromMap(vm)
				x.PathItems[k] = elem
			}
		}
	}
	if sub, ok := m["mediaTypes"].(map[string]any); ok {
		x.MediaTypes = make(map[string]*MediaType, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(MediaType)
				elem.decodeFromMap(vm)
				x.MediaTypes[k] = elem
			}
		}
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Contact) decodeFromMap(m map[string]any) {
	x.Name, _ = m["name"].(string)
	x.URL, _ = m["url"].(string)
	x.Email, _ = m["email"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Discriminator) decodeFromMap(m map[string]any) {
	x.PropertyName, _ = m["propertyName"].(string)
	x.Mapping = mapGetStringMap(m, "mapping")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Encoding) decodeFromMap(m map[string]any) {
	x.ContentType, _ = m["contentType"].(string)
	if sub, ok := m["headers"].(map[string]any); ok {
		x.Headers = make(map[string]*Header, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Header)
				elem.decodeFromMap(vm)
				x.Headers[k] = elem
			}
		}
	}
	x.Style, _ = m["style"].(string)
	x.Explode = mapGetBoolPtr(m, "explode")
	x.AllowReserved, _ = m["allowReserved"].(bool)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Example) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Summary, _ = m["summary"].(string)
	x.Description, _ = m["description"].(string)
	x.Value = m["value"]
	x.ExternalValue, _ = m["externalValue"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *ExternalDocs) decodeFromMap(m map[string]any) {
	x.Description, _ = m["description"].(string)
	x.URL, _ = m["url"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Header) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Description, _ = m["description"].(string)
	x.Required, _ = m["required"].(bool)
	x.Deprecated, _ = m["deprecated"].(bool)
	x.Style, _ = m["style"].(string)
	x.Explode = mapGetBoolPtr(m, "explode")
	if sub, ok := m["schema"].(map[string]any); ok {
		x.Schema = new(Schema)
		x.Schema.decodeFromMap(sub)
	}
	x.Example = m["example"]
	if sub, ok := m["examples"].(map[string]any); ok {
		x.Examples = make(map[string]*Example, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Example)
				elem.decodeFromMap(vm)
				x.Examples[k] = elem
			}
		}
	}
	if sub, ok := m["content"].(map[string]any); ok {
		x.Content = make(map[string]*MediaType, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(MediaType)
				elem.decodeFromMap(vm)
				x.Content[k] = elem
			}
		}
	}
	x.Type, _ = m["type"].(string)
	x.Format, _ = m["format"].(string)
	if sub, ok := m["items"].(map[string]any); ok {
		x.Items = new(Items)
		x.Items.decodeFromMap(sub)
	}
	x.CollectionFormat, _ = m["collectionFormat"].(string)
	x.Default = m["default"]
	x.Maximum = mapGetFloat64Ptr(m, "maximum")
	x.ExclusiveMaximum, _ = m["exclusiveMaximum"].(bool)
	x.Minimum = mapGetFloat64Ptr(m, "minimum")
	x.ExclusiveMinimum, _ = m["exclusiveMinimum"].(bool)
	x.MaxLength = mapGetIntPtr(m, "maxLength")
	x.MinLength = mapGetIntPtr(m, "minLength")
	x.Pattern, _ = m["pattern"].(string)
	x.MaxItems = mapGetIntPtr(m, "maxItems")
	x.MinItems = mapGetIntPtr(m, "minItems")
	x.UniqueItems, _ = m["uniqueItems"].(bool)
	if arr, ok := m["enum"].([]any); ok {
		x.Enum = arr
	}
	x.MultipleOf = mapGetFloat64Ptr(m, "multipleOf")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Info) decodeFromMap(m map[string]any) {
	x.Title, _ = m["title"].(string)
	x.Description, _ = m["description"].(string)
	x.TermsOfService, _ = m["termsOfService"].(string)
	if sub, ok := m["contact"].(map[string]any); ok {
		x.Contact = new(Contact)
		x.Contact.decodeFromMap(sub)
	}
	if sub, ok := m["license"].(map[string]any); ok {
		x.License = new(License)
		x.License.decodeFromMap(sub)
	}
	x.Version, _ = m["version"].(string)
	x.Summary, _ = m["summary"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Items) decodeFromMap(m map[string]any) {
	x.Type, _ = m["type"].(string)
	x.Format, _ = m["format"].(string)
	if sub, ok := m["items"].(map[string]any); ok {
		x.Items = new(Items)
		x.Items.decodeFromMap(sub)
	}
	x.CollectionFormat, _ = m["collectionFormat"].(string)
	x.Default = m["default"]
	x.Maximum = mapGetFloat64Ptr(m, "maximum")
	x.ExclusiveMaximum, _ = m["exclusiveMaximum"].(bool)
	x.Minimum = mapGetFloat64Ptr(m, "minimum")
	x.ExclusiveMinimum, _ = m["exclusiveMinimum"].(bool)
	x.MaxLength = mapGetIntPtr(m, "maxLength")
	x.MinLength = mapGetIntPtr(m, "minLength")
	x.Pattern, _ = m["pattern"].(string)
	x.MaxItems = mapGetIntPtr(m, "maxItems")
	x.MinItems = mapGetIntPtr(m, "minItems")
	x.UniqueItems, _ = m["uniqueItems"].(bool)
	if arr, ok := m["enum"].([]any); ok {
		x.Enum = arr
	}
	x.MultipleOf = mapGetFloat64Ptr(m, "multipleOf")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *License) decodeFromMap(m map[string]any) {
	x.Name, _ = m["name"].(string)
	x.URL, _ = m["url"].(string)
	x.Identifier, _ = m["identifier"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Link) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.OperationRef, _ = m["operationRef"].(string)
	x.OperationID, _ = m["operationId"].(string)
	if sub, ok := m["parameters"].(map[string]any); ok {
		x.Parameters = sub
	}
	x.RequestBody = m["requestBody"]
	x.Description, _ = m["description"].(string)
	if sub, ok := m["server"].(map[string]any); ok {
		x.Server = new(Server)
		x.Server.decodeFromMap(sub)
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *MediaType) decodeFromMap(m map[string]any) {
	if sub, ok := m["schema"].(map[string]any); ok {
		x.Schema = new(Schema)
		x.Schema.decodeFromMap(sub)
	}
	x.Example = m["example"]
	if sub, ok := m["examples"].(map[string]any); ok {
		x.Examples = make(map[string]*Example, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Example)
				elem.decodeFromMap(vm)
				x.Examples[k] = elem
			}
		}
	}
	if sub, ok := m["encoding"].(map[string]any); ok {
		x.Encoding = make(map[string]*Encoding, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Encoding)
				elem.decodeFromMap(vm)
				x.Encoding[k] = elem
			}
		}
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *OAS2Document) decodeFromMap(m map[string]any) {
	x.Swagger, _ = m["swagger"].(string)
	if sub, ok := m["info"].(map[string]any); ok {
		x.Info = new(Info)
		x.Info.decodeFromMap(sub)
	}
	x.Host, _ = m["host"].(string)
	x.BasePath, _ = m["basePath"].(string)
	x.Schemes = mapGetStringSlice(m, "schemes")
	x.Consumes = mapGetStringSlice(m, "consumes")
	x.Produces = mapGetStringSlice(m, "produces")
	if sub, ok := m["paths"].(map[string]any); ok {
		x.Paths = decodePaths(sub)
	}
	if sub, ok := m["definitions"].(map[string]any); ok {
		x.Definitions = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.Definitions[k] = elem
			}
		}
	}
	if sub, ok := m["parameters"].(map[string]any); ok {
		x.Parameters = make(map[string]*Parameter, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Parameter)
				elem.decodeFromMap(vm)
				x.Parameters[k] = elem
			}
		}
	}
	if sub, ok := m["responses"].(map[string]any); ok {
		x.Responses = make(map[string]*Response, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Response)
				elem.decodeFromMap(vm)
				x.Responses[k] = elem
			}
		}
	}
	if sub, ok := m["securityDefinitions"].(map[string]any); ok {
		x.SecurityDefinitions = make(map[string]*SecurityScheme, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(SecurityScheme)
				elem.decodeFromMap(vm)
				x.SecurityDefinitions[k] = elem
			}
		}
	}
	if arr, ok := m["security"].([]any); ok {
		x.Security = decodeSecurityRequirements(arr)
	}
	if arr, ok := m["tags"].([]any); ok {
		x.Tags = make([]*Tag, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Tag)
				elem.decodeFromMap(sub)
				x.Tags = append(x.Tags, elem)
			}
		}
	}
	if sub, ok := m["externalDocs"].(map[string]any); ok {
		x.ExternalDocs = new(ExternalDocs)
		x.ExternalDocs.decodeFromMap(sub)
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *OAS3Document) decodeFromMap(m map[string]any) {
	x.OpenAPI, _ = m["openapi"].(string)
	if sub, ok := m["info"].(map[string]any); ok {
		x.Info = new(Info)
		x.Info.decodeFromMap(sub)
	}
	if arr, ok := m["servers"].([]any); ok {
		x.Servers = make([]*Server, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Server)
				elem.decodeFromMap(sub)
				x.Servers = append(x.Servers, elem)
			}
		}
	}
	if sub, ok := m["paths"].(map[string]any); ok {
		x.Paths = decodePaths(sub)
	}
	if sub, ok := m["webhooks"].(map[string]any); ok {
		x.Webhooks = make(map[string]*PathItem, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(PathItem)
				elem.decodeFromMap(vm)
				x.Webhooks[k] = elem
			}
		}
	}
	if sub, ok := m["components"].(map[string]any); ok {
		x.Components = new(Components)
		x.Components.decodeFromMap(sub)
	}
	if arr, ok := m["security"].([]any); ok {
		x.Security = decodeSecurityRequirements(arr)
	}
	if arr, ok := m["tags"].([]any); ok {
		x.Tags = make([]*Tag, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Tag)
				elem.decodeFromMap(sub)
				x.Tags = append(x.Tags, elem)
			}
		}
	}
	if sub, ok := m["externalDocs"].(map[string]any); ok {
		x.ExternalDocs = new(ExternalDocs)
		x.ExternalDocs.decodeFromMap(sub)
	}
	x.JSONSchemaDialect, _ = m["jsonSchemaDialect"].(string)
	x.Self, _ = m["$self"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *OAuthFlow) decodeFromMap(m map[string]any) {
	x.AuthorizationURL, _ = m["authorizationUrl"].(string)
	x.TokenURL, _ = m["tokenUrl"].(string)
	x.RefreshURL, _ = m["refreshUrl"].(string)
	x.Scopes = mapGetStringMap(m, "scopes")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *OAuthFlows) decodeFromMap(m map[string]any) {
	if sub, ok := m["implicit"].(map[string]any); ok {
		x.Implicit = new(OAuthFlow)
		x.Implicit.decodeFromMap(sub)
	}
	if sub, ok := m["password"].(map[string]any); ok {
		x.Password = new(OAuthFlow)
		x.Password.decodeFromMap(sub)
	}
	if sub, ok := m["clientCredentials"].(map[string]any); ok {
		x.ClientCredentials = new(OAuthFlow)
		x.ClientCredentials.decodeFromMap(sub)
	}
	if sub, ok := m["authorizationCode"].(map[string]any); ok {
		x.AuthorizationCode = new(OAuthFlow)
		x.AuthorizationCode.decodeFromMap(sub)
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Operation) decodeFromMap(m map[string]any) {
	x.Tags = mapGetStringSlice(m, "tags")
	x.Summary, _ = m["summary"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["externalDocs"].(map[string]any); ok {
		x.ExternalDocs = new(ExternalDocs)
		x.ExternalDocs.decodeFromMap(sub)
	}
	x.OperationID, _ = m["operationId"].(string)
	if arr, ok := m["parameters"].([]any); ok {
		x.Parameters = make([]*Parameter, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Parameter)
				elem.decodeFromMap(sub)
				x.Parameters = append(x.Parameters, elem)
			}
		}
	}
	if sub, ok := m["requestBody"].(map[string]any); ok {
		x.RequestBody = new(RequestBody)
		x.RequestBody.decodeFromMap(sub)
	}
	if sub, ok := m["responses"].(map[string]any); ok {
		x.Responses = new(Responses)
		x.Responses.decodeFromMap(sub)
	}
	if sub, ok := m["callbacks"].(map[string]any); ok {
		x.Callbacks = make(map[string]*Callback, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				x.Callbacks[k] = decodeCallback(vm)
			}
		}
	}
	x.Deprecated, _ = m["deprecated"].(bool)
	if arr, ok := m["security"].([]any); ok {
		x.Security = decodeSecurityRequirements(arr)
	}
	if arr, ok := m["servers"].([]any); ok {
		x.Servers = make([]*Server, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Server)
				elem.decodeFromMap(sub)
				x.Servers = append(x.Servers, elem)
			}
		}
	}
	x.Consumes = mapGetStringSlice(m, "consumes")
	x.Produces = mapGetStringSlice(m, "produces")
	x.Schemes = mapGetStringSlice(m, "schemes")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Parameter) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Name, _ = m["name"].(string)
	x.In, _ = m["in"].(string)
	x.Description, _ = m["description"].(string)
	x.Required, _ = m["required"].(bool)
	x.Deprecated, _ = m["deprecated"].(bool)
	x.Style, _ = m["style"].(string)
	x.Explode = mapGetBoolPtr(m, "explode")
	x.AllowReserved, _ = m["allowReserved"].(bool)
	if sub, ok := m["schema"].(map[string]any); ok {
		x.Schema = new(Schema)
		x.Schema.decodeFromMap(sub)
	}
	x.Example = m["example"]
	if sub, ok := m["examples"].(map[string]any); ok {
		x.Examples = make(map[string]*Example, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Example)
				elem.decodeFromMap(vm)
				x.Examples[k] = elem
			}
		}
	}
	if sub, ok := m["content"].(map[string]any); ok {
		x.Content = make(map[string]*MediaType, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(MediaType)
				elem.decodeFromMap(vm)
				x.Content[k] = elem
			}
		}
	}
	x.Type, _ = m["type"].(string)
	x.Format, _ = m["format"].(string)
	x.AllowEmptyValue, _ = m["allowEmptyValue"].(bool)
	if sub, ok := m["items"].(map[string]any); ok {
		x.Items = new(Items)
		x.Items.decodeFromMap(sub)
	}
	x.CollectionFormat, _ = m["collectionFormat"].(string)
	x.Default = m["default"]
	x.Maximum = mapGetFloat64Ptr(m, "maximum")
	x.ExclusiveMaximum, _ = m["exclusiveMaximum"].(bool)
	x.Minimum = mapGetFloat64Ptr(m, "minimum")
	x.ExclusiveMinimum, _ = m["exclusiveMinimum"].(bool)
	x.MaxLength = mapGetIntPtr(m, "maxLength")
	x.MinLength = mapGetIntPtr(m, "minLength")
	x.Pattern, _ = m["pattern"].(string)
	x.MaxItems = mapGetIntPtr(m, "maxItems")
	x.MinItems = mapGetIntPtr(m, "minItems")
	x.UniqueItems, _ = m["uniqueItems"].(bool)
	if arr, ok := m["enum"].([]any); ok {
		x.Enum = arr
	}
	x.MultipleOf = mapGetFloat64Ptr(m, "multipleOf")
	x.Extra = extractExtensionsFromMap(m)
}

func (x *PathItem) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Summary, _ = m["summary"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["get"].(map[string]any); ok {
		x.Get = new(Operation)
		x.Get.decodeFromMap(sub)
	}
	if sub, ok := m["put"].(map[string]any); ok {
		x.Put = new(Operation)
		x.Put.decodeFromMap(sub)
	}
	if sub, ok := m["post"].(map[string]any); ok {
		x.Post = new(Operation)
		x.Post.decodeFromMap(sub)
	}
	if sub, ok := m["delete"].(map[string]any); ok {
		x.Delete = new(Operation)
		x.Delete.decodeFromMap(sub)
	}
	if sub, ok := m["options"].(map[string]any); ok {
		x.Options = new(Operation)
		x.Options.decodeFromMap(sub)
	}
	if sub, ok := m["head"].(map[string]any); ok {
		x.Head = new(Operation)
		x.Head.decodeFromMap(sub)
	}
	if sub, ok := m["patch"].(map[string]any); ok {
		x.Patch = new(Operation)
		x.Patch.decodeFromMap(sub)
	}
	if sub, ok := m["trace"].(map[string]any); ok {
		x.Trace = new(Operation)
		x.Trace.decodeFromMap(sub)
	}
	if sub, ok := m["query"].(map[string]any); ok {
		x.Query = new(Operation)
		x.Query.decodeFromMap(sub)
	}
	if arr, ok := m["servers"].([]any); ok {
		x.Servers = make([]*Server, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Server)
				elem.decodeFromMap(sub)
				x.Servers = append(x.Servers, elem)
			}
		}
	}
	if arr, ok := m["parameters"].([]any); ok {
		x.Parameters = make([]*Parameter, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Parameter)
				elem.decodeFromMap(sub)
				x.Parameters = append(x.Parameters, elem)
			}
		}
	}
	if sub, ok := m["additionalOperations"].(map[string]any); ok {
		x.AdditionalOperations = make(map[string]*Operation, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Operation)
				elem.decodeFromMap(vm)
				x.AdditionalOperations[k] = elem
			}
		}
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Reference) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Summary, _ = m["summary"].(string)
	x.Description, _ = m["description"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *RequestBody) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["content"].(map[string]any); ok {
		x.Content = make(map[string]*MediaType, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(MediaType)
				elem.decodeFromMap(vm)
				x.Content[k] = elem
			}
		}
	}
	x.Required, _ = m["required"].(bool)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Response) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["headers"].(map[string]any); ok {
		x.Headers = make(map[string]*Header, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Header)
				elem.decodeFromMap(vm)
				x.Headers[k] = elem
			}
		}
	}
	if sub, ok := m["content"].(map[string]any); ok {
		x.Content = make(map[string]*MediaType, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(MediaType)
				elem.decodeFromMap(vm)
				x.Content[k] = elem
			}
		}
	}
	if sub, ok := m["links"].(map[string]any); ok {
		x.Links = make(map[string]*Link, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Link)
				elem.decodeFromMap(vm)
				x.Links[k] = elem
			}
		}
	}
	if sub, ok := m["schema"].(map[string]any); ok {
		x.Schema = new(Schema)
		x.Schema.decodeFromMap(sub)
	}
	if sub, ok := m["examples"].(map[string]any); ok {
		x.Examples = sub
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Schema) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Schema, _ = m["$schema"].(string)
	x.Title, _ = m["title"].(string)
	x.Description, _ = m["description"].(string)
	x.Default = m["default"]
	if arr, ok := m["examples"].([]any); ok {
		x.Examples = arr
	}
	x.Type = m["type"]
	if arr, ok := m["enum"].([]any); ok {
		x.Enum = arr
	}
	x.Const = m["const"]
	x.MultipleOf = mapGetFloat64Ptr(m, "multipleOf")
	x.Maximum = mapGetFloat64Ptr(m, "maximum")
	x.ExclusiveMaximum = m["exclusiveMaximum"]
	x.Minimum = mapGetFloat64Ptr(m, "minimum")
	x.ExclusiveMinimum = m["exclusiveMinimum"]
	x.MaxLength = mapGetIntPtr(m, "maxLength")
	x.MinLength = mapGetIntPtr(m, "minLength")
	x.Pattern, _ = m["pattern"].(string)
	x.Items = decodeSchemaOrBool(m["items"])
	if arr, ok := m["prefixItems"].([]any); ok {
		x.PrefixItems = make([]*Schema, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(sub)
				x.PrefixItems = append(x.PrefixItems, elem)
			}
		}
	}
	x.AdditionalItems = decodeSchemaOrBool(m["additionalItems"])
	x.UnevaluatedItems = decodeSchemaOrBool(m["unevaluatedItems"])
	x.MaxItems = mapGetIntPtr(m, "maxItems")
	x.MinItems = mapGetIntPtr(m, "minItems")
	x.UniqueItems, _ = m["uniqueItems"].(bool)
	if sub, ok := m["contains"].(map[string]any); ok {
		x.Contains = new(Schema)
		x.Contains.decodeFromMap(sub)
	}
	x.MaxContains = mapGetIntPtr(m, "maxContains")
	x.MinContains = mapGetIntPtr(m, "minContains")
	if sub, ok := m["properties"].(map[string]any); ok {
		x.Properties = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.Properties[k] = elem
			}
		}
	}
	if sub, ok := m["patternProperties"].(map[string]any); ok {
		x.PatternProperties = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.PatternProperties[k] = elem
			}
		}
	}
	x.AdditionalProperties = decodeSchemaOrBool(m["additionalProperties"])
	x.UnevaluatedProperties = decodeSchemaOrBool(m["unevaluatedProperties"])
	x.Required = mapGetStringSlice(m, "required")
	if sub, ok := m["propertyNames"].(map[string]any); ok {
		x.PropertyNames = new(Schema)
		x.PropertyNames.decodeFromMap(sub)
	}
	x.MaxProperties = mapGetIntPtr(m, "maxProperties")
	x.MinProperties = mapGetIntPtr(m, "minProperties")
	x.DependentRequired = mapGetDependentRequired(m, "dependentRequired")
	if sub, ok := m["dependentSchemas"].(map[string]any); ok {
		x.DependentSchemas = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.DependentSchemas[k] = elem
			}
		}
	}
	if sub, ok := m["if"].(map[string]any); ok {
		x.If = new(Schema)
		x.If.decodeFromMap(sub)
	}
	if sub, ok := m["then"].(map[string]any); ok {
		x.Then = new(Schema)
		x.Then.decodeFromMap(sub)
	}
	if sub, ok := m["else"].(map[string]any); ok {
		x.Else = new(Schema)
		x.Else.decodeFromMap(sub)
	}
	if arr, ok := m["allOf"].([]any); ok {
		x.AllOf = make([]*Schema, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(sub)
				x.AllOf = append(x.AllOf, elem)
			}
		}
	}
	if arr, ok := m["anyOf"].([]any); ok {
		x.AnyOf = make([]*Schema, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(sub)
				x.AnyOf = append(x.AnyOf, elem)
			}
		}
	}
	if arr, ok := m["oneOf"].([]any); ok {
		x.OneOf = make([]*Schema, 0, len(arr))
		for _, item := range arr {
			if sub, ok := item.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(sub)
				x.OneOf = append(x.OneOf, elem)
			}
		}
	}
	if sub, ok := m["not"].(map[string]any); ok {
		x.Not = new(Schema)
		x.Not.decodeFromMap(sub)
	}
	x.Nullable, _ = m["nullable"].(bool)
	if sub, ok := m["discriminator"].(map[string]any); ok {
		x.Discriminator = new(Discriminator)
		x.Discriminator.decodeFromMap(sub)
	}
	x.ReadOnly, _ = m["readOnly"].(bool)
	x.WriteOnly, _ = m["writeOnly"].(bool)
	if sub, ok := m["xml"].(map[string]any); ok {
		x.XML = new(XML)
		x.XML.decodeFromMap(sub)
	}
	if sub, ok := m["externalDocs"].(map[string]any); ok {
		x.ExternalDocs = new(ExternalDocs)
		x.ExternalDocs.decodeFromMap(sub)
	}
	x.Example = m["example"]
	x.Deprecated, _ = m["deprecated"].(bool)
	x.Format, _ = m["format"].(string)
	x.ContentEncoding, _ = m["contentEncoding"].(string)
	x.ContentMediaType, _ = m["contentMediaType"].(string)
	if sub, ok := m["contentSchema"].(map[string]any); ok {
		x.ContentSchema = new(Schema)
		x.ContentSchema.decodeFromMap(sub)
	}
	x.CollectionFormat, _ = m["collectionFormat"].(string)
	x.ID, _ = m["$id"].(string)
	x.Anchor, _ = m["$anchor"].(string)
	x.DynamicRef, _ = m["$dynamicRef"].(string)
	x.DynamicAnchor, _ = m["$dynamicAnchor"].(string)
	x.Vocabulary = mapGetBoolMap(m, "$vocabulary")
	x.Comment, _ = m["$comment"].(string)
	if sub, ok := m["$defs"].(map[string]any); ok {
		x.Defs = make(map[string]*Schema, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				elem := new(Schema)
				elem.decodeFromMap(vm)
				x.Defs[k] = elem
			}
		}
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *SecurityScheme) decodeFromMap(m map[string]any) {
	x.Ref, _ = m["$ref"].(string)
	x.Type, _ = m["type"].(string)
	x.Description, _ = m["description"].(string)
	x.Name, _ = m["name"].(string)
	x.In, _ = m["in"].(string)
	x.Scheme, _ = m["scheme"].(string)
	x.BearerFormat, _ = m["bearerFormat"].(string)
	if sub, ok := m["flows"].(map[string]any); ok {
		x.Flows = new(OAuthFlows)
		x.Flows.decodeFromMap(sub)
	}
	x.Flow, _ = m["flow"].(string)
	x.AuthorizationURL, _ = m["authorizationUrl"].(string)
	x.TokenURL, _ = m["tokenUrl"].(string)
	x.Scopes = mapGetStringMap(m, "scopes")
	x.OpenIDConnectURL, _ = m["openIdConnectUrl"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Server) decodeFromMap(m map[string]any) {
	x.URL, _ = m["url"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["variables"].(map[string]any); ok {
		x.Variables = make(map[string]ServerVariable, len(sub))
		for k, v := range sub {
			if vm, ok := v.(map[string]any); ok {
				var sv ServerVariable
				sv.decodeFromMap(vm)
				x.Variables[k] = sv
			}
		}
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *ServerVariable) decodeFromMap(m map[string]any) {
	x.Enum = mapGetStringSlice(m, "enum")
	x.Default, _ = m["default"].(string)
	x.Description, _ = m["description"].(string)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Tag) decodeFromMap(m map[string]any) {
	x.Name, _ = m["name"].(string)
	x.Description, _ = m["description"].(string)
	if sub, ok := m["externalDocs"].(map[string]any); ok {
		x.ExternalDocs = new(ExternalDocs)
		x.ExternalDocs.decodeFromMap(sub)
	}
	x.Extra = extractExtensionsFromMap(m)
}

func (x *XML) decodeFromMap(m map[string]any) {
	x.Name, _ = m["name"].(string)
	x.Namespace, _ = m["namespace"].(string)
	x.Prefix, _ = m["prefix"].(string)
	x.Attribute, _ = m["attribute"].(bool)
	x.Wrapped, _ = m["wrapped"].(bool)
	x.Extra = extractExtensionsFromMap(m)
}

func (x *Responses) decodeFromMap(m map[string]any) {
	x.Codes = make(map[string]*Response)
	for key, value := range m {
		sub, ok := value.(map[string]any)
		if !ok {
			continue
		}
		if key == "default" {
			x.Default = new(Response)
			x.Default.decodeFromMap(sub)
		} else if httputil.ValidateStatusCode(key) {
			resp := new(Response)
			resp.decodeFromMap(sub)
			x.Codes[key] = resp
		}
	}
}
