// Code generated by oastools. DO NOT EDIT.

package petstore

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// Client is the API client.
type Client struct {
	// BaseURL is the base URL for API requests.
	BaseURL string
	// HTTPClient is the HTTP client to use for requests.
	HTTPClient *http.Client
	// UserAgent is the User-Agent header value for requests.
	UserAgent string
	// RequestEditors are functions that can modify requests before sending.
	RequestEditors []RequestEditorFn
}

// RequestEditorFn is a function that can modify an HTTP request.
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ClientOption is a function that configures a Client.
type ClientOption func(*Client) error

// NewClient creates a new API client.
func NewClient(baseURL string, opts ...ClientOption) (*Client, error) {
	c := &Client{
		BaseURL:    strings.TrimSuffix(baseURL, "/"),
		HTTPClient: http.DefaultClient,
		UserAgent:  "oastools/dev/generated/Swagger Petstore",
	}
	for _, opt := range opts {
		if err := opt(c); err != nil {
			return nil, err
		}
	}
	return c, nil
}

// WithHTTPClient sets the HTTP client.
func WithHTTPClient(client *http.Client) ClientOption {
	return func(c *Client) error {
		c.HTTPClient = client
		return nil
	}
}

// WithRequestEditor adds a request editor function.
func WithRequestEditor(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithUserAgent sets the User-Agent header value.
func WithUserAgent(ua string) ClientOption {
	return func(c *Client) error {
		c.UserAgent = ua
		return nil
	}
}

// UpdatePet Update an existing pet
func (c *Client) UpdatePet(ctx context.Context, body Pet) (*http.Response, error) {
	path := "/pet"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "PUT", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// AddPet Add a new pet to the store
func (c *Client) AddPet(ctx context.Context, body Pet) (*http.Response, error) {
	path := "/pet"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// FindPetsByStatus Finds Pets by status
func (c *Client) FindPetsByStatus(ctx context.Context, params *FindPetsByStatusParams) ([]Pet, error) {
	path := "/pet/findByStatus"
	query := make(url.Values)
	if params != nil {
		query.Set("status", fmt.Sprintf("%v", params.Status))
	}
	if len(query) > 0 {
		path += "?" + query.Encode()
	}
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result []Pet
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return result, nil
}

// FindPetsByStatusParams contains query parameters for FindPetsByStatus.
type FindPetsByStatusParams struct {
	// Status values that need to be considered for filter
	Status []string `json:"status"`
}

// FindPetsByTags Finds Pets by tags
// Deprecated: This operation is deprecated.
func (c *Client) FindPetsByTags(ctx context.Context, params *FindPetsByTagsParams) ([]Pet, error) {
	path := "/pet/findByTags"
	query := make(url.Values)
	if params != nil {
		query.Set("tags", fmt.Sprintf("%v", params.Tags))
	}
	if len(query) > 0 {
		path += "?" + query.Encode()
	}
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result []Pet
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return result, nil
}

// FindPetsByTagsParams contains query parameters for FindPetsByTags.
type FindPetsByTagsParams struct {
	// Tags to filter by
	Tags []string `json:"tags"`
}

// GetPetById Find pet by ID
func (c *Client) GetPetById(ctx context.Context, petId int64) (*Pet, error) {
	path := fmt.Sprintf("/pet/%v", petId)
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result Pet
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// UpdatePetWithForm Updates a pet in the store with form data
func (c *Client) UpdatePetWithForm(ctx context.Context, petId int64) (*http.Response, error) {
	path := fmt.Sprintf("/pet/%v", petId)
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// DeletePet Deletes a pet
func (c *Client) DeletePet(ctx context.Context, petId int64) (*http.Response, error) {
	path := fmt.Sprintf("/pet/%v", petId)
	req, err := http.NewRequestWithContext(ctx, "DELETE", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// UploadFile uploads an image
func (c *Client) UploadFile(ctx context.Context, petId int64) (*ApiResponse, error) {
	path := fmt.Sprintf("/pet/%v/uploadImage", petId)
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result ApiResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// GetInventory Returns pet inventories by status
func (c *Client) GetInventory(ctx context.Context) (map[string]int32, error) {
	path := "/store/inventory"
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result map[string]int32
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return result, nil
}

// PlaceOrder Place an order for a pet
func (c *Client) PlaceOrder(ctx context.Context, body Order) (*Order, error) {
	path := "/store/order"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result Order
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// GetOrderById Find purchase order by ID
func (c *Client) GetOrderById(ctx context.Context, orderId int64) (*Order, error) {
	path := fmt.Sprintf("/store/order/%v", orderId)
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result Order
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// DeleteOrder Delete purchase order by ID
func (c *Client) DeleteOrder(ctx context.Context, orderId int64) (*http.Response, error) {
	path := fmt.Sprintf("/store/order/%v", orderId)
	req, err := http.NewRequestWithContext(ctx, "DELETE", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// CreateUser Create user
func (c *Client) CreateUser(ctx context.Context, body User) (*http.Response, error) {
	path := "/user"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// CreateUsersWithArrayInput Creates list of users with given input array
func (c *Client) CreateUsersWithArrayInput(ctx context.Context, body []User) (*http.Response, error) {
	path := "/user/createWithArray"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// CreateUsersWithListInput Creates list of users with given input array
func (c *Client) CreateUsersWithListInput(ctx context.Context, body []User) (*http.Response, error) {
	path := "/user/createWithList"
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "POST", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// LoginUser Logs user into the system
func (c *Client) LoginUser(ctx context.Context, params *LoginUserParams) (*string, error) {
	path := "/user/login"
	query := make(url.Values)
	if params != nil {
		query.Set("username", fmt.Sprintf("%v", params.Username))
		query.Set("password", fmt.Sprintf("%v", params.Password))
	}
	if len(query) > 0 {
		path += "?" + query.Encode()
	}
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result string
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// LoginUserParams contains query parameters for LoginUser.
type LoginUserParams struct {
	// The user name for login
	Username string `json:"username"`
	// The password for login in clear text
	Password string `json:"password"`
}

// LogoutUser Logs out current logged in user session
func (c *Client) LogoutUser(ctx context.Context) (*http.Response, error) {
	path := "/user/logout"
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// GetUserByName Get user by user name
func (c *Client) GetUserByName(ctx context.Context, username string) (*User, error) {
	path := fmt.Sprintf("/user/%v", username)
	req, err := http.NewRequestWithContext(ctx, "GET", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	var result User
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	return &result, nil
}

// UpdateUser Updated user
func (c *Client) UpdateUser(ctx context.Context, username string, body User) (*http.Response, error) {
	path := fmt.Sprintf("/user/%v", username)
	bodyData, err := json.Marshal(body)
	if err != nil {
		return nil, fmt.Errorf("marshal request body: %w", err)
	}
	req, err := http.NewRequestWithContext(ctx, "PUT", c.BaseURL+path, bytes.NewReader(bodyData))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// DeleteUser Delete user
func (c *Client) DeleteUser(ctx context.Context, username string) (*http.Response, error) {
	path := fmt.Sprintf("/user/%v", username)
	req, err := http.NewRequestWithContext(ctx, "DELETE", c.BaseURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Accept", "application/json")
	if c.UserAgent != "" {
		req.Header.Set("User-Agent", c.UserAgent)
	}
	for _, editor := range c.RequestEditors {
		if err := editor(ctx, req); err != nil {
			return nil, fmt.Errorf("request editor: %w", err)
		}
	}
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("execute request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return nil, &APIError{StatusCode: resp.StatusCode, Body: body}
	}
	return resp, nil
}

// APIError represents an API error response.
type APIError struct {
	StatusCode int
	Body       []byte
}

func (e *APIError) Error() string {
	return fmt.Sprintf("API error: status %d: %s", e.StatusCode, string(e.Body))
}
