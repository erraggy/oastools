// Code generated by oastools. DO NOT EDIT.

package petstore

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"
)

// PetstoreAuthOAuth2Config holds OAuth2 configuration.
type PetstoreAuthOAuth2Config struct {
	ClientID     string
	ClientSecret string
	RedirectURL  string
	Scopes       []string
}

// OAuth2Token represents an OAuth2 token response.
type OAuth2Token struct {
	AccessToken  string    `json:"access_token"`
	TokenType    string    `json:"token_type"`
	ExpiresIn    int       `json:"expires_in"`
	RefreshToken string    `json:"refresh_token,omitempty"`
	Scope        string    `json:"scope,omitempty"`
	ExpiresAt    time.Time `json:"-"`
}

// IsExpired returns true if the token is expired or will expire within the grace period.
func (t *OAuth2Token) IsExpired(grace time.Duration) bool {
	if t.ExpiresAt.IsZero() {
		return false
	}
	return time.Now().Add(grace).After(t.ExpiresAt)
}

// PetstoreAuthOAuth2Client handles OAuth2 token operations.
type PetstoreAuthOAuth2Client struct {
	Config           PetstoreAuthOAuth2Config
	AuthorizationURL string
	TokenURL         string
	HTTPClient       *http.Client
}

// NewPetstoreAuthOAuth2Client creates a new OAuth2 client.
func NewPetstoreAuthOAuth2Client(cfg PetstoreAuthOAuth2Config) *PetstoreAuthOAuth2Client {
	return &PetstoreAuthOAuth2Client{
		Config:           cfg,
		AuthorizationURL: "https://petstore.swagger.io/oauth/authorize",
		TokenURL:         "",
		HTTPClient:       http.DefaultClient,
	}
}

// GetImplicitAuthorizationURL returns the URL for implicit flow authorization.
// Deprecated: The implicit flow is deprecated for security reasons.
// Consider using authorization code flow with PKCE instead.
func (c *PetstoreAuthOAuth2Client) GetImplicitAuthorizationURL(state string) string {
	params := url.Values{
		"client_id":     {c.Config.ClientID},
		"redirect_uri":  {c.Config.RedirectURL},
		"response_type": {"token"},
		"scope":         {strings.Join(c.Config.Scopes, " ")},
		"state":         {state},
	}
	return c.AuthorizationURL + "?" + params.Encode()
}

// RefreshToken refreshes an access token using a refresh token.
func (c *PetstoreAuthOAuth2Client) RefreshToken(ctx context.Context, refreshToken string) (*OAuth2Token, error) {
	data := url.Values{
		"grant_type":    {"refresh_token"},
		"client_id":     {c.Config.ClientID},
		"client_secret": {c.Config.ClientSecret},
		"refresh_token": {refreshToken},
	}
	return c.doTokenRequest(ctx, data)
}

// WithPetstoreAuthOAuth2AutoRefresh configures automatic token refresh.
// The token will be refreshed when it expires or is within the grace period.
func WithPetstoreAuthOAuth2AutoRefresh(oauth2Client *PetstoreAuthOAuth2Client, token *OAuth2Token, gracePeriod time.Duration) ClientOption {
	var mu sync.Mutex
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, func(ctx context.Context, req *http.Request) error {
			mu.Lock()
			defer mu.Unlock()

			if token.IsExpired(gracePeriod) && token.RefreshToken != "" {
				newToken, err := oauth2Client.RefreshToken(ctx, token.RefreshToken)
				if err != nil {
					return fmt.Errorf("failed to refresh token: %w", err)
				}
				*token = *newToken
			}

			req.Header.Set("Authorization", "Bearer "+token.AccessToken)
			return nil
		})
		return nil
	}
}

// doTokenRequest performs a token request and parses the response.
func (c *PetstoreAuthOAuth2Client) doTokenRequest(ctx context.Context, data url.Values) (*OAuth2Token, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.TokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("token request failed: %s", resp.Status)
	}

	var token OAuth2Token
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, err
	}

	if token.ExpiresIn > 0 {
		token.ExpiresAt = time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)
	}

	return &token, nil
}
