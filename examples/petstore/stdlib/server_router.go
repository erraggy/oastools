// Code generated by oastools. DO NOT EDIT.

package petstore

import (
	"context"
	"net/http"
	"strconv"

	"github.com/erraggy/oastools/httpvalidator"
	"github.com/erraggy/oastools/parser"
)

// ServerRouter routes HTTP requests to ServerInterface handlers.
type ServerRouter struct {
	server       ServerInterface
	pathMatcher  *httpvalidator.PathMatcherSet
	middleware   []func(http.Handler) http.Handler
	errorHandler func(r *http.Request, err error) // called when handler returns error
}

// RouterOption configures the ServerRouter.
type RouterOption func(*ServerRouter) error

// NewServerRouter creates a new ServerRouter that dispatches requests to the server.
// The parsed OpenAPI specification is required for path matching.
func NewServerRouter(server ServerInterface, parsed *parser.ParseResult, opts ...RouterOption) (*ServerRouter, error) {
	// Extract path templates from the spec
	var paths []string
	if doc, ok := parsed.OAS3Document(); ok {
		for path := range doc.Paths {
			paths = append(paths, path)
		}
	} else if doc, ok := parsed.OAS2Document(); ok {
		for path := range doc.Paths {
			paths = append(paths, path)
		}
	}

	pathMatcher, err := httpvalidator.NewPathMatcherSet(paths)
	if err != nil {
		return nil, err
	}

	r := &ServerRouter{
		server:      server,
		pathMatcher: pathMatcher,
	}

	for _, opt := range opts {
		if err := opt(r); err != nil {
			return nil, err
		}
	}

	return r, nil
}

// WithMiddleware adds middleware to the router.
// Middleware is applied in order (first added = outermost).
func WithMiddleware(mw ...func(http.Handler) http.Handler) RouterOption {
	return func(r *ServerRouter) error {
		r.middleware = append(r.middleware, mw...)
		return nil
	}
}

// WithErrorHandler sets a callback for logging handler errors.
// The callback receives the request and error for logging purposes.
// The error is NOT sent to the client - a generic message is returned instead.
func WithErrorHandler(handler func(r *http.Request, err error)) RouterOption {
	return func(r *ServerRouter) error {
		r.errorHandler = handler
		return nil
	}
}

// Handler returns an http.Handler that routes requests.
func (r *ServerRouter) Handler() http.Handler {
	var handler http.Handler = http.HandlerFunc(r.serveHTTP)

	// Apply middleware in reverse order so first added is outermost
	for i := len(r.middleware) - 1; i >= 0; i-- {
		handler = r.middleware[i](handler)
	}

	return handler
}

// ServeHTTP implements http.Handler.
func (r *ServerRouter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	r.Handler().ServeHTTP(w, req)
}

// serveHTTP is the internal handler that performs routing.
func (r *ServerRouter) serveHTTP(w http.ResponseWriter, req *http.Request) {
	template, params, found := r.pathMatcher.Match(req.URL.Path)
	if !found {
		http.NotFound(w, req)
		return
	}

	// Store path params in request context for handler access
	ctx := req.Context()
	for k, v := range params {
		ctx = context.WithValue(ctx, pathParamKey(k), v)
	}
	req = req.WithContext(ctx)

	// Route to appropriate handler based on path and method
	r.routeRequest(w, req, template)
}

// pathParamKey is the context key type for path parameters.
type pathParamKey string

// PathParam retrieves a path parameter from the request context.
func PathParam(r *http.Request, name string) string {
	if v := r.Context().Value(pathParamKey(name)); v != nil {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

// routeRequest routes a matched request to the appropriate handler.
func (r *ServerRouter) routeRequest(w http.ResponseWriter, req *http.Request, template string) {
	switch template + ":" + req.Method {

	case "/pet:PUT":
		r.handleUpdatePet(w, req)

	case "/pet:POST":
		r.handleAddPet(w, req)

	case "/pet/findByStatus:GET":
		r.handleFindPetsByStatus(w, req)

	case "/pet/findByTags:GET":
		r.handleFindPetsByTags(w, req)

	case "/pet/{petId}:GET":
		r.handleGetPetById(w, req)

	case "/pet/{petId}:POST":
		r.handleUpdatePetWithForm(w, req)

	case "/pet/{petId}:DELETE":
		r.handleDeletePet(w, req)

	case "/pet/{petId}/uploadImage:POST":
		r.handleUploadFile(w, req)

	case "/store/inventory:GET":
		r.handleGetInventory(w, req)

	case "/store/order:POST":
		r.handlePlaceOrder(w, req)

	case "/store/order/{orderId}:GET":
		r.handleGetOrderById(w, req)

	case "/store/order/{orderId}:DELETE":
		r.handleDeleteOrder(w, req)

	case "/user:POST":
		r.handleCreateUser(w, req)

	case "/user/createWithArray:POST":
		r.handleCreateUsersWithArrayInput(w, req)

	case "/user/createWithList:POST":
		r.handleCreateUsersWithListInput(w, req)

	case "/user/login:GET":
		r.handleLoginUser(w, req)

	case "/user/logout:GET":
		r.handleLogoutUser(w, req)

	case "/user/{username}:GET":
		r.handleGetUserByName(w, req)

	case "/user/{username}:PUT":
		r.handleUpdateUser(w, req)

	case "/user/{username}:DELETE":
		r.handleDeleteUser(w, req)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (r *ServerRouter) handleUpdatePet(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &UpdatePetRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.UpdatePet(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleAddPet(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &AddPetRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.AddPet(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleFindPetsByStatus(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &FindPetsByStatusRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.FindPetsByStatus(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleFindPetsByTags(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &FindPetsByTagsRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.FindPetsByTags(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleGetPetById(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &GetPetByIdRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: petId
	if v, err := strconv.ParseInt(PathParam(req, "petId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: petId")
		return
	} else {
		srvReq.PetId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.GetPetById(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleUpdatePetWithForm(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &UpdatePetWithFormRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: petId
	if v, err := strconv.ParseInt(PathParam(req, "petId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: petId")
		return
	} else {
		srvReq.PetId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.UpdatePetWithForm(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleDeletePet(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &DeletePetRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: petId
	if v, err := strconv.ParseInt(PathParam(req, "petId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: petId")
		return
	} else {
		srvReq.PetId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.DeletePet(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleUploadFile(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &UploadFileRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: petId
	if v, err := strconv.ParseInt(PathParam(req, "petId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: petId")
		return
	} else {
		srvReq.PetId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.UploadFile(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleGetInventory(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &GetInventoryRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.GetInventory(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handlePlaceOrder(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &PlaceOrderRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.PlaceOrder(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleGetOrderById(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &GetOrderByIdRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: orderId
	if v, err := strconv.ParseInt(PathParam(req, "orderId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: orderId")
		return
	} else {
		srvReq.OrderId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.GetOrderById(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleDeleteOrder(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &DeleteOrderRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: orderId
	if v, err := strconv.ParseInt(PathParam(req, "orderId"), 10, 64); err != nil {
		WriteError(w, http.StatusBadRequest, "invalid path parameter: orderId")
		return
	} else {
		srvReq.OrderId = int64(v)
	}

	// Call the server implementation
	resp, err := r.server.DeleteOrder(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleCreateUser(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &CreateUserRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.CreateUser(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleCreateUsersWithArrayInput(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &CreateUsersWithArrayInputRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.CreateUsersWithArrayInput(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleCreateUsersWithListInput(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &CreateUsersWithListInputRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.CreateUsersWithListInput(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleLoginUser(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &LoginUserRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.LoginUser(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleLogoutUser(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &LogoutUserRequest{
		HTTPRequest: req,
	}

	// Call the server implementation
	resp, err := r.server.LogoutUser(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleGetUserByName(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &GetUserByNameRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: username
	srvReq.Username = PathParam(req, "username")

	// Call the server implementation
	resp, err := r.server.GetUserByName(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleUpdateUser(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &UpdateUserRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: username
	srvReq.Username = PathParam(req, "username")

	// Call the server implementation
	resp, err := r.server.UpdateUser(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}

func (r *ServerRouter) handleDeleteUser(w http.ResponseWriter, req *http.Request) {
	ctx := req.Context()

	// Build request struct
	srvReq := &DeleteUserRequest{
		HTTPRequest: req,
	}

	// Extract path parameter: username
	srvReq.Username = PathParam(req, "username")

	// Call the server implementation
	resp, err := r.server.DeleteUser(ctx, srvReq)
	if err != nil {
		// Log the error if a handler is configured
		if r.errorHandler != nil {
			r.errorHandler(req, err)
		}
		// Return a generic error to avoid exposing internal details.
		// Use WithErrorHandler to log the actual error for debugging.
		WriteError(w, http.StatusInternalServerError, "internal server error")
		return
	}

	// Write response
	if respWriter, ok := any(resp).(interface {
		WriteTo(http.ResponseWriter) error
	}); ok {
		if err := respWriter.WriteTo(w); err != nil {
			// Response already started, can't write error - but log it
			if r.errorHandler != nil {
				r.errorHandler(req, err)
			}
			return
		}
		return
	}

	// Fallback: write as JSON
	WriteJSON(w, http.StatusOK, resp)
}
