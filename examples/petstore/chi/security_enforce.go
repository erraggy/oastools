// Code generated by oastools. DO NOT EDIT.

package petstore

import (
	"fmt"
	"strings"
)

// SecurityRequirement represents a security requirement for an operation.
type SecurityRequirement struct {
	// Scheme is the name of the security scheme.
	Scheme string
	// Scopes are the required OAuth2 scopes (empty for non-OAuth2 schemes).
	Scopes []string
}

// OperationSecurity maps operation IDs to their security requirements.
// Each operation may have multiple alternative security requirements (OR relationship).
// Within each requirement, multiple schemes may be required (AND relationship).
var OperationSecurity = map[string][]SecurityRequirement{
	"AddPet": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"DeletePet": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"FindPetsByStatus": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"FindPetsByTags": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"GetInventory": {
		{Scheme: "api_key"},
	},
	"GetPetById": {
		{Scheme: "api_key"},
	},
	"UpdatePet": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"UpdatePetWithForm": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
	"UploadFile": {
		{Scheme: "petstore_auth", Scopes: []string{"write:pets", "read:pets"}},
	},
}

// SecurityValidator validates that required security is configured.
type SecurityValidator struct {
	configuredSchemes map[string]bool
	configuredScopes  map[string]map[string]bool
}

// NewSecurityValidator creates a new security validator.
func NewSecurityValidator() *SecurityValidator {
	return &SecurityValidator{
		configuredSchemes: make(map[string]bool),
		configuredScopes:  make(map[string]map[string]bool),
	}
}

// ConfigureScheme marks a security scheme as configured with optional scopes.
func (v *SecurityValidator) ConfigureScheme(scheme string, scopes ...string) {
	v.configuredSchemes[scheme] = true
	if v.configuredScopes[scheme] == nil {
		v.configuredScopes[scheme] = make(map[string]bool)
	}
	for _, scope := range scopes {
		v.configuredScopes[scheme][scope] = true
	}
}

// ValidateOperation checks if the required security for an operation is configured.
// Returns nil if security is properly configured, or an error describing what's missing.
func (v *SecurityValidator) ValidateOperation(operationID string) error {
	reqs, ok := OperationSecurity[operationID]
	if !ok || len(reqs) == 0 {
		// No security required for this operation
		return nil
	}

	// Check if ANY of the security requirements are satisfied (OR relationship)
	for _, req := range reqs {
		if v.configuredSchemes[req.Scheme] {
			if len(req.Scopes) == 0 {
				// Scheme configured, no scopes required
				return nil
			}
			// Check if all required scopes are configured
			allScopes := true
			for _, scope := range req.Scopes {
				if !v.configuredScopes[req.Scheme][scope] {
					allScopes = false
					break
				}
			}
			if allScopes {
				return nil
			}
		}
	}

	return fmt.Errorf("operation %q requires one of: %v", operationID, formatRequirements(reqs))
}

// formatRequirements formats security requirements for error messages.
func formatRequirements(reqs []SecurityRequirement) string {
	var parts []string
	for _, req := range reqs {
		if len(req.Scopes) > 0 {
			parts = append(parts, fmt.Sprintf("%s (scopes: %v)", req.Scheme, req.Scopes))
		} else {
			parts = append(parts, req.Scheme)
		}
	}
	return fmt.Sprintf("[%s]", strings.Join(parts, ", "))
}
